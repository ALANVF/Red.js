// Generated by Haxe 4.3.1
(function ($hx_exports, $global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$_;
class Cycles {
	static push(value) {
		Cycles.cycles[Cycles.top] = value;
		Cycles.top++;
		if(Cycles.top == Cycles.end) {
			Cycles.reset();
			throw haxe_Exception.thrown("too deep");
		}
	}
	static pop() {
		if(Cycles.top > 0) {
			Cycles.cycles[Cycles.top--] = undefined;
		}
	}
	static popN(n) {
		if(Cycles.top - n < 0) {
			throw haxe_Exception.thrown("bad");
		}
		let value = undefined;
		Cycles.cycles.fill(value,Cycles.top,Cycles.top + n);
		Cycles.top -= n;
	}
	static reset() {
		let value = undefined;
		Cycles.cycles.fill(value,0,Cycles.top + 1);
		Cycles.top = 0;
	}
	static find(value) {
		if(Cycles.top == 0) {
			return false;
		}
		let _g = 0;
		let _g1 = Cycles.top + 1;
		while(_g < _g1) if(Cycles.cycles[_g++] == value) {
			return true;
		}
		return false;
	}
	static detect(value,buffer,part,isMold) {
		let node;
		if(((value) instanceof types_Object) == true) {
			let __anon0__o = value;
			let o = __anon0__o;
			node = o.ctx;
		} else {
			node = value.values;
		}
		if(Cycles.find(node)) {
			let s;
			let size;
			if(isMold) {
				let _hx_tmp;
				let _hx_tmp1;
				let _hx_tmp2;
				let _hx_tmp3;
				let _hx_tmp4;
				if(((value) instanceof types_Block) == true) {
					s = "[...]";
					size = 5;
				} else {
					_hx_tmp4 = ((value) instanceof types_Hash);
					if(_hx_tmp4 == true) {
						s = "[...]";
						size = 5;
					} else {
						_hx_tmp3 = ((value) instanceof types_Paren);
						if(_hx_tmp3 == true) {
							s = "(...)";
							size = 5;
						} else {
							_hx_tmp2 = ((value) instanceof types_Map);
							if(_hx_tmp2 == true) {
								s = "#[...]";
								size = 6;
							} else {
								_hx_tmp1 = ((value) instanceof types_Object);
								if(_hx_tmp1 == true) {
									s = "make object! [...]";
									size = 18;
								} else {
									_hx_tmp = ((value) instanceof types_base__$Path);
									if(_hx_tmp == true) {
										s = "...";
										size = 3;
									} else {
										throw haxe_Exception.thrown("bad");
									}
								}
							}
						}
					}
				}
			} else {
				s = "...";
				size = 3;
			}
			buffer.appendLiteral(s);
			return [part - size,true];
		} else {
			return [part,false];
		}
	}
}
Cycles.__name__ = true;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	matched(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	matchedPos() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
}
EReg.__name__ = true;
Object.assign(EReg.prototype, {
	__class__: EReg
});
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = true;
class Lambda {
	static exists(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) if(f(x.next())) {
			return true;
		}
		return false;
	}
}
Lambda.__name__ = true;
class Load {
	static _DATATYPES_() {
		return [[types_base_Context.GLOBAL.add("datatype!",Load__dummy = new types_Datatype("datatype!",0)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("unset!",Load__dummy = new types_Datatype("unset!",1)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("none!",Load__dummy = new types_Datatype("none!",2)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("logic!",Load__dummy = new types_Datatype("logic!",3)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("block!",Load__dummy = new types_Datatype("block!",4)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("paren!",Load__dummy = new types_Datatype("paren!",5)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("string!",Load__dummy = new types_Datatype("string!",6)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("file!",Load__dummy = new types_Datatype("file!",7)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("url!",Load__dummy = new types_Datatype("url!",8)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("char!",Load__dummy = new types_Datatype("char!",9)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("integer!",Load__dummy = new types_Datatype("integer!",10)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("float!",Load__dummy = new types_Datatype("float!",11)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("word!",Load__dummy = new types_Datatype("word!",12)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("set-word!",Load__dummy = new types_Datatype("set-word!",13)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("lit-word!",Load__dummy = new types_Datatype("lit-word!",14)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("get-word!",Load__dummy = new types_Datatype("get-word!",15)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("refinement!",Load__dummy = new types_Datatype("refinement!",16)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("issue!",Load__dummy = new types_Datatype("issue!",17)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("native!",Load__dummy = new types_Datatype("native!",18)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("action!",Load__dummy = new types_Datatype("action!",19)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("op!",Load__dummy = new types_Datatype("op!",20)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("function!",Load__dummy = new types_Datatype("function!",21)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("path!",Load__dummy = new types_Datatype("path!",22)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("lit-path!",Load__dummy = new types_Datatype("lit-path!",23)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("set-path!",Load__dummy = new types_Datatype("set-path!",24)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("get-path!",Load__dummy = new types_Datatype("get-path!",25)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("bitset!",Load__dummy = new types_Datatype("bitset!",26)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("point2D!",Load__dummy = new types_Datatype("point2D!",27)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("point3D!",Load__dummy = new types_Datatype("point3D!",28)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("object!",Load__dummy = new types_Datatype("object!",29)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("typeset!",Load__dummy = new types_Datatype("typeset!",30)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("error!",Load__dummy = new types_Datatype("error!",31)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("hash!",Load__dummy = new types_Datatype("hash!",32)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("pair!",Load__dummy = new types_Datatype("pair!",33)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("percent!",Load__dummy = new types_Datatype("percent!",34)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("tuple!",Load__dummy = new types_Datatype("tuple!",35)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("map!",Load__dummy = new types_Datatype("map!",36)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("binary!",Load__dummy = new types_Datatype("binary!",37)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("time!",Load__dummy = new types_Datatype("time!",38)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("tag!",Load__dummy = new types_Datatype("tag!",39)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("email!",Load__dummy = new types_Datatype("email!",40)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("date!",Load__dummy = new types_Datatype("date!",41)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("money!",Load__dummy = new types_Datatype("money!",42)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("ref!",Load__dummy = new types_Datatype("ref!",43)).symbol,Load__dummy]];
	}
}
Load.__name__ = true;
var Load__dummy = null;
class Main {
	static main() {
		RedJS.initRuntime();
		setTimeout(function() {
			return (function($this) {
				var $r;
				$global.console.clear();
				$global.console.log("Build " + RedJS.BUILD + "\n");
				let readline = require("readline");
				let stdout = process.stdout;
				let io = readline.createInterface({ input : process.stdin, output : stdout});
				stdout.write(">> ");
				$r = io.on("line",function(input) {
					try {
						let res = RedJS.evalCode(input);
						if(res != types_Unset.UNSET) {
							$global.console.log("==",RedJS.mold(res));
						}
					} catch( _g ) {
						let _g1 = haxe_Exception.caught(_g);
						let e = _g1;
						$global.console.log(e.details());
						$global.console.log();
					}
					stdout.write(">> ");
				});
				return $r;
			}(this));
		},1);
	}
}
Main.__name__ = true;
Math.__name__ = true;
class RedJS {
	static initRuntime() {
		Runtime.registerDatatypes();
		types_base_Context.GLOBAL.value = new types_Object(types_base_Context.GLOBAL,-1,true);
		runtime_Words.build();
		types_base_Context.GLOBAL.add("make",new types_Action(null,null,[new types_base__$Param("type",types_base_QuotingKind.QVal,null,null),new types_base__$Param("spec",types_base_QuotingKind.QVal,null,null)],[],null,runtime_actions_datatypes_ActionActions.MAPPINGS.get("ACT_MAKE")));
		runtime_Eval.evalCode("\n\t\t\tmake: make action! [[\n\t\t\t\t\ttype\t [any-type!]\n\t\t\t\t\tspec\t [any-type!]\n\t\t\t\t\treturn:  [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_MAKE\n\t\t\t]\n\n\t\t\treflect: make action! [[\n\t\t\t\t\tvalue\t[any-type!]\n\t\t\t\t\tfield \t[word!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_REFLECT\n\t\t\t]\n\t\t\t\n\t\t\tto: make action! [[\n\t\t\t\t\ttype\t[any-type!]\n\t\t\t\t\tspec\t[any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_TO\n\t\t\t]\n\n\t\t\tform: make action! [[\n\t\t\t\t\tvalue\t  [any-type!]\n\t\t\t\t\t/part\n\t\t\t\t\t\tlimit [integer!]\n\t\t\t\t\treturn:\t  [string!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_FORM\n\t\t\t]\n\t\t\t\n\t\t\tmold: make action! [[\n\t\t\t\t\tvalue\t  [any-type!]\n\t\t\t\t\t/only\n\t\t\t\t\t/all\n\t\t\t\t\t/flat\n\t\t\t\t\t/part\n\t\t\t\t\t\tlimit [integer!]\n\t\t\t\t\treturn:\t  [string!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_MOLD\n\t\t\t]\n\t\t\t\n\t\t\tabsolute: make action! [[\n\t\t\t\t\tvalue\t[number! money! char! pair! time!]\n\t\t\t\t\treturn: [number! money! char! pair! time!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_ABSOLUTE\n\t\t\t]\n\n\t\t\tnegate: make action! [[\n\t\t\t\t\tnumber \t [number! money! bitset! pair! time!]\n\t\t\t\t\treturn:  [number! money! bitset! pair! time!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_NEGATE\n\t\t\t]\n\t\t\t\n\t\t\tadd: make action! [[\n\t\t\t\t\tvalue1\t[scalar! vector!]\n\t\t\t\t\tvalue2\t[scalar! vector!]\n\t\t\t\t\treturn: [scalar! vector!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_ADD\n\t\t\t]\n\n\t\t\tsubtract: make action! [[\n\t\t\t\t\tvalue1\t [scalar! vector!]\n\t\t\t\t\tvalue2\t [scalar! vector!]\n\t\t\t\t\treturn:  [scalar! vector!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_SUBTRACT\n\t\t\t]\n\n\t\t\tmultiply: make action! [[\n\t\t\t\t\tvalue1\t [number! money! char! pair! tuple! vector! time!]\n\t\t\t\t\tvalue2\t [number! money! char! pair! tuple! vector! time!]\n\t\t\t\t\treturn:  [number! money! char! pair! tuple! vector! time!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_MULTIPLY\n\t\t\t]\n\n\t\t\tdivide: make action! [[\n\t\t\t\t\tvalue1\t [number! money! char! pair! tuple! vector! time!]\n\t\t\t\t\tvalue2\t [number! money! char! pair! tuple! vector! time!]\n\t\t\t\t\treturn:  [number! money! char! pair! tuple! vector! time!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_DIVIDE\n\t\t\t]\n\n\t\t\tpower: make action! [[\n\t\t\t\t\tnumber\t [number!]\n\t\t\t\t\texponent [integer! float!]\n\t\t\t\t\treturn:\t [number!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_POWER\n\t\t\t]\n\n\t\t\tremainder: make action! [[\n\t\t\t\t\tvalue1 \t [number! money! char! pair! tuple! vector! time!]\n\t\t\t\t\tvalue2 \t [number! money! char! pair! tuple! vector! time!]\n\t\t\t\t\treturn:  [number! money! char! pair! tuple! vector! time!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_REMAINDER\n\t\t\t]\n\n\t\t\tround: make action! [[\n\t\t\t\t\tn\t\t[number! money! time! pair!]\n\t\t\t\t\t/to\n\t\t\t\t\tscale\t[number! money! time! pair!]\n\t\t\t\t\t/even\n\t\t\t\t\t/down\n\t\t\t\t\t/half-down\n\t\t\t\t\t/floor\n\t\t\t\t\t/ceiling\n\t\t\t\t\t/half-ceiling\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_ROUND\n\t\t\t]\n\n\t\t\teven?: make action! [[\n\t\t\t\t\tnumber \t [number! money! char! time!]\n\t\t\t\t\treturn:  [logic!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_EVEN?\n\t\t\t]\n\t\t\t\n\t\t\todd?: make action! [[\n\t\t\t\t\tnumber \t [number! money! char! time!]\n\t\t\t\t\treturn:  [logic!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_ODD?\n\t\t\t]\n\t\t\n\n\t\t\tand~: make action! [[\n\t\t\t\t\tvalue1\t[logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n\t\t\t\t\tvalue2\t[logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n\t\t\t\t\treturn:\t[logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_AND~\n\t\t\t]\n\n\t\t\tcomplement: make action! [[\n\t\t\t\t\tvalue\t[logic! integer! tuple! bitset! typeset! binary!]\n\t\t\t\t\treturn: [logic! integer! tuple! bitset! typeset! binary!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_COMPLEMENT\n\t\t\t]\n\n\t\t\tor~: make action! [[\n\t\t\t\t\tvalue1\t[logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n\t\t\t\t\tvalue2\t[logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n\t\t\t\t\treturn:\t[logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_OR~\n\t\t\t]\n\t\t\t\n\t\t\txor~: make action! [[\n\t\t\t\t\tvalue1\t[logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n\t\t\t\t\tvalue2\t[logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n\t\t\t\t\treturn:\t[logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_XOR~\n\t\t\t]\n\n\t\t\tappend: make action! [[\n\t\t\t\t\tseries\t   [series! bitset! port!]\n\t\t\t\t\tvalue\t   [any-type!]\n\t\t\t\t\t/part\n\t\t\t\t\t\tlength [number! series!]\n\t\t\t\t\t/only\n\t\t\t\t\t/dup\n\t\t\t\t\t\tcount  [integer!]\n\t\t\t\t\treturn:    [series! port! bitset!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_APPEND\n\t\t\t]\n\n\t\t\tat: make action! [[\n\t\t\t\t\tseries\t [series! port!]\n\t\t\t\t\tindex \t [integer! pair!]\n\t\t\t\t\treturn:  [series! port!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_AT\n\t\t\t]\n\t\t\t\n\t\t\tback: make action! [[\n\t\t\t\t\tseries\t [series! port!]\n\t\t\t\t\treturn:  [series! port!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_BACK\n\t\t\t]\n\n\t\t\tchange: make action! [[\n\t\t\t\t\tseries [series! port!]\n\t\t\t\t\tvalue [any-type!]\n\t\t\t\t\t/part\n\t\t\t\t\t\trange [number! series!]\n\t\t\t\t\t/only\n\t\t\t\t\t/dup\n\t\t\t\t\t\tcount [number!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_CHANGE\n\t\t\t]\n\n\t\t\tclear: make action! [[\n\t\t\t\t\tseries\t [series! port! bitset! map! none!]\n\t\t\t\t\treturn:  [series! port! bitset! map! none!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_CLEAR\n\t\t\t]\n\n\t\t\tcopy: make action! [[\n\t\t\t\t\tvalue\t [series! any-object! bitset! map!]\n\t\t\t\t\t/part\n\t\t\t\t\t\tlength [number! series! pair!]\n\t\t\t\t\t/deep\n\t\t\t\t\t/types\n\t\t\t\t\t\tkind [datatype!]\n\t\t\t\t\treturn:  [series! any-object! bitset! map!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_COPY\n\t\t\t]\n\n\t\t\tfind: make action! [[\n\t\t\t\t\tseries\t [series! bitset! typeset! map! none!]\n\t\t\t\t\tvalue \t [any-type!]\n\t\t\t\t\t/part\n\t\t\t\t\t\tlength [number! series!]\n\t\t\t\t\t/only\n\t\t\t\t\t/case\n\t\t\t\t\t/same\n\t\t\t\t\t/any\n\t\t\t\t\t/with\n\t\t\t\t\t\twild [string!]\n\t\t\t\t\t/skip\n\t\t\t\t\t\tsize [integer!]\n\t\t\t\t\t/last\n\t\t\t\t\t/reverse\n\t\t\t\t\t/tail\n\t\t\t\t\t/match\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_FIND\n\t\t\t]\n\n\t\t\thead: make action! [[\n\t\t\t\t\tseries\t [series! port!]\n\t\t\t\t\treturn:  [series! port!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_HEAD\n\t\t\t]\n\t\t\t\n\t\t\thead?: make action! [[\n\t\t\t\t\tseries\t [series! port!]\n\t\t\t\t\treturn:  [logic!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_HEAD?\n\t\t\t]\n\t\t\t\n\t\t\tindex?: make action! [[\n\t\t\t\t\tseries\t [series! port! any-word!]\n\t\t\t\t\treturn:  [integer!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_INDEX?\n\t\t\t]\n\n\t\t\tinsert: make action! [[\n\t\t\t\t\tseries\t   [series! port! bitset!]\n\t\t\t\t\tvalue\t   [any-type!]\n\t\t\t\t\t/part\n\t\t\t\t\t\tlength [number! series!]\n\t\t\t\t\t/only\n\t\t\t\t\t/dup\n\t\t\t\t\t\tcount  [integer!]\n\t\t\t\t\treturn:    [series! port! bitset!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_INSERT\n\t\t\t]\n\n\t\t\tlength?: make action! [[\n\t\t\t\t\tseries\t [series! port! bitset! map! tuple! none!]\n\t\t\t\t\treturn:  [integer! none!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_LENGTH?\n\t\t\t]\n\n\t\t\tmove: make action! [[\n\t\t\t\t\torigin\t   [series! port!]\n\t\t\t\t\ttarget\t   [series! port!]\n\t\t\t\t\t/part\n\t\t\t\t\t\tlength [integer!]\n\t\t\t\t\treturn:    [series! port!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_MOVE\n\t\t\t]\n\n\t\t\tnext: make action! [[\n\t\t\t\t\tseries\t [series! port!]\n\t\t\t\t\treturn:  [series! port!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_NEXT\n\t\t\t]\n\n\t\t\tpick: make action! [[\n\t\t\t\t\tseries\t [series! bitset! pair! tuple! money! date! time!]\n\t\t\t\t\tindex \t [scalar! any-string! any-word! block! logic! time!]\n\t\t\t\t\treturn:  [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_PICK\n\t\t\t]\n\n\t\t\tpoke: make action! [[\n\t\t\t\t\tseries\t [series! port! bitset!]\n\t\t\t\t\tindex \t [scalar! any-string! any-word! block! logic!]\n\t\t\t\t\tvalue \t [any-type!]\n\t\t\t\t\treturn:  [series! port! bitset!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_POKE\n\t\t\t]\n\n\t\t\tput: make action! [[\n\t\t\t\t\tseries\t [series! map! object!]\n\t\t\t\t\tkey \t [scalar! any-string! all-word! binary!]\n\t\t\t\t\tvalue \t [any-type!]\n\t\t\t\t\t/case\n\t\t\t\t\treturn:  [series! map! object!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_PUT\n\t\t\t]\n\n\t\t\tremove: make action! [[\n\t\t\t\t\tseries\t [series! port! bitset! map! none!]\n\t\t\t\t\t/part\n\t\t\t\t\t\tlength [number! char! series!]\n\t\t\t\t\t/key\n\t\t\t\t\t\tkey-arg [scalar! any-string! any-word! binary! block!]\n\t\t\t\t\treturn:  [series! port! bitset! map! none!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_REMOVE\n\t\t\t]\n\n\t\t\treverse: make action! [[\n\t\t\t\t\tseries\t [series! port! pair! tuple!]\n\t\t\t\t\t/part\n\t\t\t\t\t\tlength [number! series!]\n\t\t\t\t\t/skip\n\t\t\t\t\t\tsize [integer!]\n\t\t\t\t\treturn:  [series! port! pair! tuple!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_REVERSE\n\t\t\t]\n\n\n\t\t\tselect: make action! [[\n\t\t\t\t\tseries\t [series! any-object! map! none!]\n\t\t\t\t\tvalue \t [any-type!]\n\t\t\t\t\t/part\n\t\t\t\t\t\tlength [number! series!]\n\t\t\t\t\t/only\n\t\t\t\t\t/case\n\t\t\t\t\t/same\n\t\t\t\t\t/any\n\t\t\t\t\t/with\n\t\t\t\t\t\twild [string!]\n\t\t\t\t\t/skip\n\t\t\t\t\t\tsize [integer!]\n\t\t\t\t\t/last\n\t\t\t\t\t/reverse\n\t\t\t\t\treturn:  [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_SELECT\n\t\t\t]\n\t\t\t\n\t\t\tsort: make action! [[\n\t\t\t\t\tseries\t [series! port!]\n\t\t\t\t\t/case\n\t\t\t\t\t/skip\n\t\t\t\t\t\tsize [integer!]\n\t\t\t\t\t/compare\n\t\t\t\t\t\tcomparator [integer! block! any-function!]\n\t\t\t\t\t/part\n\t\t\t\t\t\tlength [number! series!]\n\t\t\t\t\t/all\n\t\t\t\t\t/reverse\n\t\t\t\t\t/stable\n\t\t\t\t\treturn:  [series!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_SORT\n\t\t\t]\n\n\t\t\tskip: make action! [[\n\t\t\t\t\tseries\t [series! port!]\n\t\t\t\t\toffset \t [integer! pair!]\n\t\t\t\t\treturn:  [series! port!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_SKIP\n\t\t\t]\n\n\t\t\tswap: make action! [[\n\t\t\t\t\tseries1  [series! port!]\n\t\t\t\t\tseries2  [series! port!]\n\t\t\t\t\treturn:  [series! port!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_SWAP\n\t\t\t]\n\t\t\t\n\t\t\ttail: make action! [[\n\t\t\t\t\tseries\t [series! port!]\n\t\t\t\t\treturn:  [series! port!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_TAIL\n\t\t\t]\n\t\t\t\n\t\t\ttail?: make action! [[\n\t\t\t\t\tseries\t [series! port!]\n\t\t\t\t\treturn:  [logic!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_TAIL?\n\t\t\t]\n\n\t\t\ttake: make action! [[\n\t\t\t\t\tseries\t [series! port! none!]\n\t\t\t\t\t/part\n\t\t\t\t\t\tlength [number! series!]\n\t\t\t\t\t/deep\n\t\t\t\t\t/last\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_TAKE\n\t\t\t]\n\t\t\t\n\t\t\ttrim: make action! [[\n\t\t\t\t\tseries\t[series! port!]\n\t\t\t\t\t/head\n\t\t\t\t\t/tail\n\t\t\t\t\t/auto\n\t\t\t\t\t/lines\n\t\t\t\t\t/all\n\t\t\t\t\t/with\n\t\t\t\t\t\tstr [char! string! binary! integer!]\n\t\t\t\t]\n\t\t\t\t#get-definition ACT_TRIM\n\t\t\t]\n\t\t");
		runtime_Eval.evalCode("\n\t\t\tif: make native! [[\n\t\t\t\t\tcond  \t [any-type!]\n\t\t\t\t\tthen-blk [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_IF\n\t\t\t]\n\t\t\t\n\t\t\tunless: make native! [[\n\t\t\t\t\tcond  \t [any-type!]\n\t\t\t\t\tthen-blk [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_UNLESS\n\t\t\t]\n\n\t\t\teither: make native! [[\n\t\t\t\t\tcond     [logic!]\n\t\t\t\t\ttrue-blk [block!]\n\t\t\t\t\telse-blk [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_EITHER\n\t\t\t]\n\n\t\t\tany: make native! [[\n\t\t\t\t\tconds [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_ANY\n\t\t\t]\n\t\t\t\n\t\t\tall: make native! [[\n\t\t\t\t\tconds [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_ALL\n\t\t\t]\n\n\t\t\tloop: make native! [[\n\t\t\t\t\tcount [integer!]\n\t\t\t\t\tbody  [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_LOOP\n\t\t\t]\n\n\t\t\trepeat: make native! [[\n\t\t\t\t\t'word [word!]\n\t\t\t\t\tvalue [integer! float!]\n\t\t\t\t\tbody  [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_REPEAT\n\t\t\t]\n\n\t\t\tforever: make native! [[\n\t\t\t\t\tbody   [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_FOREVER\n\t\t\t]\n\t\t\t\n\t\t\tforeach: make native! [[\n\t\t\t\t\t'word  [word! block!]\n\t\t\t\t\tseries [series! map!]\n\t\t\t\t\tbody   [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_FOREACH\n\t\t\t]\n\t\t\t\n\t\t\tforall: make native! [[\n\t\t\t\t\t'word [word!]\n\t\t\t\t\tbody  [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_FORALL\n\t\t\t]\n\t\t\t\n\t\t\tremove-each: make native! [[\n\t\t\t\t\t'word [word! block!]\n\t\t\t\t\tdata [series!]\n\t\t\t\t\tbody [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_REMOVE_EACH\n\t\t\t]\n\n\t\t\tfunc: make native! [[\n\t\t\t\t\tspec [block!]\n\t\t\t\t\tbody [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_FUNC\n\t\t\t]\n\n\t\t\tdoes: make native! [[\n\t\t\t\t\tbody [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_DOES\n\t\t\t]\n\t\t\t\n\t\t\thas: make native! [[\n\t\t\t\t\tvars [block!]\n\t\t\t\t\tbody [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_HAS\n\t\t\t]\n\n\t\t\tswitch: make native! [[\n\t\t\t\t\tvalue [any-type!]\n\t\t\t\t\tcases [block!]\n\t\t\t\t\t/default\n\t\t\t\t\t\tcase [block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_SWITCH\n\t\t\t]\n\t\t\t\n\t\t\tcase: make native! [[\n\t\t\t\t\tcases [block!]\n\t\t\t\t\t/all\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_CASE\n\t\t\t]\n\t\t\t\n\t\t\tdo: make native! [[\n\t\t\t\t\tvalue [any-type!]\n\t\t\t\t\t/expand\n\t\t\t\t\t/args\n\t\t\t\t\t\targ\n\t\t\t\t\t/next\n\t\t\t\t\t\tposition [word!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_DO\n\t\t\t]\n\t\t\t\n\t\t\treduce: make native! [[\n\t\t\t\t\tvalue [any-type!]\n\t\t\t\t\t/into\n\t\t\t\t\t\tout [any-block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_REDUCE\n\t\t\t]\n\n\t\t\tcompose: make native! [[\n\t\t\t\t\tvalue [block!]\n\t\t\t\t\t/deep\n\t\t\t\t\t/only\n\t\t\t\t\t/into\n\t\t\t\t\t\tout [any-block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_COMPOSE\n\t\t\t]\n\n\t\t\tget: make native! [[\n\t\t\t\t\tword\t[any-word! any-path! object!]\n\t\t\t\t\t/any\n\t\t\t\t\t/case\n\t\t\t\t\treturn: [any-type!]\n\t\t\t\t] \n\t\t\t\t#get-definition NAT_GET\n\t\t\t]\n\t\t\t\n\t\t\tset: make native! [[\n\t\t\t\t\tword\t[any-word! block! object! any-path!]\n\t\t\t\t\tvalue\t[any-type!]\n\t\t\t\t\t/any\n\t\t\t\t\t/case\n\t\t\t\t\t/only\n\t\t\t\t\t/some\n\t\t\t\t\treturn: [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_SET\n\t\t\t]\n\n\t\t\tprin: make native! [[\n\t\t\t\t\tvalue [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_PRIN\n\t\t\t]\n\n\t\t\tprint: make native! [[\n\t\t\t\t\tvalue [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_PRINT\n\t\t\t]\n\t\t\t\n\t\t\tequal?: make native! [[\n\t\t\t\t\tvalue1 [any-type!]\n\t\t\t\t\tvalue2 [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_EQUAL?\n\t\t\t]\n\t\t\t\n\t\t\tnot-equal?: make native! [[\n\t\t\t\t\tvalue1 [any-type!]\n\t\t\t\t\tvalue2 [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_NOT_EQUAL?\n\t\t\t]\n\t\t\t\n\t\t\tstrict-equal?: make native! [[\n\t\t\t\t\tvalue1 [any-type!]\n\t\t\t\t\tvalue2 [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_STRICT_EQUAL?\n\t\t\t]\n\t\t\t\n\t\t\tlesser?: make native! [[\n\t\t\t\t\tvalue1 [any-type!]\n\t\t\t\t\tvalue2 [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_LESSER?\n\t\t\t]\n\t\t\t\n\t\t\tgreater?: make native! [[\n\t\t\t\t\tvalue1 [any-type!]\n\t\t\t\t\tvalue2 [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_GREATER?\n\t\t\t]\n\t\t\t\n\t\t\tlesser-or-equal?: make native! [[\n\t\t\t\t\tvalue1 [any-type!]\n\t\t\t\t\tvalue2 [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_LESSER_OR_EQUAL?\n\t\t\t]\n\t\t\t\n\t\t\tgreater-or-equal?: make native! [[\n\t\t\t\t\tvalue1 [any-type!]\n\t\t\t\t\tvalue2 [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_GREATER_OR_EQUAL?\n\t\t\t]\n\t\t\t\n\t\t\tsame?: make native! [[\n\t\t\t\t\tvalue1 [any-type!]\n\t\t\t\t\tvalue2 [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_SAME?\n\t\t\t]\n\n\t\t\tnot: make native! [[\n\t\t\t\t\tvalue [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_NOT\n\t\t\t]\n\t\t\t\n\t\t\ttype?: make native! [[\n\t\t\t\t\tvalue [any-type!]\n\t\t\t\t\t/word\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_TYPE?\n\t\t\t]\n\n\t\t\t;stats\n\n\t\t\tbind: make native! [[\n\t\t\t\t\tword \t[block! any-word!]\n\t\t\t\t\tcontext [any-word! any-object! function!]\n\t\t\t\t\t/copy\n\t\t\t\t\treturn: [block! any-word!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_BIND\n\t\t\t]\n\t\t\t\n\t\t\tin: make native! [[\n\t\t\t\t\tobject [any-object!]\n\t\t\t\t\tword   [any-word!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_IN\n\t\t\t]\n\n\t\t\t; ...\n\n\t\t\tunion: make native! [[\n\t\t\t\t\tset1 [block! hash! string! bitset! typeset!]\n\t\t\t\t\tset2 [block! hash! string! bitset! typeset!]\n\t\t\t\t\t/case\n\t\t\t\t\t/skip\n\t\t\t\t\t\tsize [integer!]\n\t\t\t\t\treturn: [block! hash! string! bitset! typeset!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_UNION\n\t\t\t]\n\n\t\t\tunique: make native! [[\n\t\t\t\t\tset [block! hash! string!]\n\t\t\t\t\t/case\n\t\t\t\t\t/skip\n\t\t\t\t\t\tsize [integer!]\n\t\t\t\t\treturn: [block! hash! string!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_UNIQUE\n\t\t\t]\n\t\t\t\n\t\t\tintersect: make native! [[\n\t\t\t\t\tset1 [block! hash! string! bitset! typeset!]\n\t\t\t\t\tset2 [block! hash! string! bitset! typeset!]\n\t\t\t\t\t/case\n\t\t\t\t\t/skip\n\t\t\t\t\t\tsize [integer!]\n\t\t\t\t\treturn: [block! hash! string! bitset! typeset!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_INTERSECT\n\t\t\t]\n\t\t\t\n\t\t\tdifference: make native! [[\n\t\t\t\t\tset1 [block! hash! string! bitset! typeset! date!]\n\t\t\t\t\tset2 [block! hash! string! bitset! typeset! date!]\n\t\t\t\t\t/case\n\t\t\t\t\t/skip\n\t\t\t\t\t\tsize [integer!]\n\t\t\t\t\treturn: [block! hash! string! bitset! typeset! time!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_DIFFERENCE\n\t\t\t]\n\t\t\t\n\t\t\texclude: make native! [[\n\t\t\t\t\tset1 [block! hash! string! bitset! typeset!]\n\t\t\t\t\tset2 [block! hash! string! bitset! typeset!]\n\t\t\t\t\t/case\n\t\t\t\t\t/skip\n\t\t\t\t\t\tsize [integer!]\n\t\t\t\t\treturn: [block! hash! string! bitset! typeset!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_EXCLUDE\n\t\t\t]\n\t\t\n\n\t\t\t; ...\n\t\t\t\n\t\t\tmin: make native! [[value1 value2] #get-definition NAT_MIN]\n\t\t\tmax: make native! [[value1 value2] #get-definition NAT_MAX]\n\n\t\t\tshift: make native! [[\n\t\t\t\t\tdata [integer!]\n\t\t\t\t\tbits [integer!]\n\t\t\t\t\t/left\n\t\t\t\t\t/logical\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_SHIFT\n\t\t\t]\n\n\t\t\t; ...\n\n\t\t\tzero?: make native! [[\n\t\t\t\t\tvalue\t[number! money! pair! time! char! tuple!]\n\t\t\t\t\treturn: [logic!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_ZERO?\n\t\t\t]\n\t\t\t\n\t\t\t; ...\n\n\t\t\tconstruct: make native! [[\n\t\t\t\t\tblock [block!]\n\t\t\t\t\t/with\n\t\t\t\t\t\tobject [object!]\n\t\t\t\t\t/only\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_CONSTRUCT\n\t\t\t]\n\n\t\t\tvalue?: make native! [[\n\t\t\t\t\tvalue\n\t\t\t\t\treturn: [logic!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_VALUE?\n\t\t\t]\n\n\t\t\ttry: make native! [[\n\t\t\t\t\tblock\t[block!]\n\t\t\t\t\t/all\n\t\t\t\t\t/keep\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_TRY\n\t\t\t]\n\n\t\t\tuppercase: make native! [[\n\t\t\t\t\tstring\t\t[any-string! char!]\n\t\t\t\t\t/part\n\t\t\t\t\t\tlimit\t[number! any-string!]\n\t\t\t\t\treturn: \t[any-string! char!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_UPPERCASE\n\t\t\t]\n\t\t\t\n\t\t\tlowercase: make native! [[\n\t\t\t\t\tstring\t\t[any-string! char!]\n\t\t\t\t\t/part\n\t\t\t\t\t\tlimit\t[number! any-string!]\n\t\t\t\t\treturn:\t\t[any-string! char!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_LOWERCASE\n\t\t\t]\n\n\t\t\tas-pair: make native! [[\n\t\t\t\t\tx [integer! float!]\n\t\t\t\t\ty [integer! float!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_AS_PAIR\n\t\t\t]\n\n\t\t\tas-money: make native! [[\n\t\t\t\t\tcurrency [word!]\n\t\t\t\t\tamount   [integer! float!]\n\t\t\t\t\treturn:  [money!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_AS_MONEY\n\t\t\t]\n\n\t\t\tbreak: make native! [[\n\t\t\t\t\t/return\n\t\t\t\t\t\tvalue [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_BREAK\n\t\t\t]\n\t\t\t\n\t\t\tcontinue: make native! [[\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_CONTINUE\n\t\t\t]\n\t\t\t\n\t\t\texit: make native! [[\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_EXIT\n\t\t\t]\n\t\t\t\n\t\t\treturn: make native! [[\n\t\t\t\t\tvalue [any-type!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_RETURN\n\t\t\t]\n\n\t\t\tthrow: make native! [[\n\t\t\t\t\tvalue [any-type!]\n\t\t\t\t\t/name\n\t\t\t\t\t\tword [word!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_THROW\n\t\t\t]\n\n\t\t\tcatch: make native! [[\n\t\t\t\t\tblock [block!]\n\t\t\t\t\t/name\n\t\t\t\t\t\tword [word! block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_CATCH\n\t\t\t]\n\n\t\t\textend: make native! [[\n\t\t\t\t\tobj  [object! map!]\n\t\t\t\t\tspec [block! hash! map!]\n\t\t\t\t\t/case\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_EXTEND\n\t\t\t]\n\n\t\t\tunset: make native! [[\n\t\t\t\t\tword [word! block!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_UNSET\n\t\t\t]\n\n\t\t\tnew-line: make native! [[\n\t\t\t\t\tposition [any-list!]\n\t\t\t\t\tvalue\t [logic!]\n\t\t\t\t\t/all\n\t\t\t\t\t/skip\n\t\t\t\t\t\tsize [integer!]\n\t\t\t\t\treturn:  [any-list!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_NEW_LINE\n\t\t\t]\n\n\t\t\tnew-line?: make native! [[\n\t\t\t\t\tposition [any-list!]\n\t\t\t\t\treturn:  [logic!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_NEW_LINE?\n\t\t\t]\n\n\t\t\tcontext?: make native! [[\n\t\t\t\t\tword\t[any-word!]\n\t\t\t\t\treturn: [object! function! none!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_CONTEXT?\n\t\t\t]\n\n\t\t\tnow: make native! [[\n\t\t\t\t\t/year\n\t\t\t\t\t/month\n\t\t\t\t\t/day\n\t\t\t\t\t/time\n\t\t\t\t\t/zone\n\t\t\t\t\t/date\n\t\t\t\t\t/weekday\n\t\t\t\t\t/yearday\n\t\t\t\t\t/precise\n\t\t\t\t\t/utc\n\t\t\t\t\treturn: [date! time! integer!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_NOW\n\t\t\t]\n\n\t\t\tsign?: make native! [[\n\t\t\t\t\tnumber [number! money! time!]\n\t\t\t\t\treturn: [integer!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_SIGN?\n\t\t\t]\n\n\t\t\tas: make native! [[\n\t\t\t\t\ttype\t[datatype! block! paren! any-path! any-string!]\n\t\t\t\t\tspec\t[block! paren! any-path! any-string!]\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_AS\n\t\t\t]\n\n\t\t\tapply: make native! [[\n\t\t\t\t\tfunc\t[word! path! any-function!]\n\t\t\t\t\targs\t[block!]\n\t\t\t\t\t/all\n\t\t\t\t\t/safer\n\t\t\t\t]\n\t\t\t\t#get-definition NAT_APPLY\n\t\t\t]\n\n\t\t\t+: make op! :add\n\t\t\t-: make op! :subtract\n\t\t\t*: make op! :multiply\n\t\t\t/: make op! :divide\n\t\t\t%: make op! :remainder\n\t\t\t**: make op! :power\n\t\t\tand: make op! :and~\n\t\t\tor: make op! :or~\n\t\t\txor: make op! :xor~\n\t\t\t=: make op! :equal?\n\t\t\t<>: make op! :not-equal?\n\t\t\t==: make op! :strict-equal?\n\t\t\t=?: make op! :same?\n\t\t\t<: make op! :lesser?\n\t\t\t>: make op! :greater?\n\t\t\t<=: make op! :lesser-or-equal?\n\t\t\t>=: make op! :greater-or-equal?\n\t\t");
		runtime_Eval.evalCode("\n\t\t\tinternal!:\t\tmake typeset! [unset!]\n\t\t\texternal!:\t\tmake typeset! [] ;#if find config/modules 'view [event!]\n\t\t\tnumber!:\t\tmake typeset! [integer! float! percent!]\n\t\t\tany-point!:     make typeset! [point2D! point3D!]\n\t\t\tscalar!:\t\tunion number! union any-point! make typeset! [money! char! pair! tuple! time! date!]\n\t\t\tany-word!:\t\tmake typeset! [word! set-word! get-word! lit-word!] ;-- any bindable word\n\t\t\tall-word!:\t\tunion any-word! make typeset! [refinement! issue!]\t;-- all types of word nature\n\t\t\tany-list!:\t\tmake typeset! [block! paren! hash!]\n\t\t\tany-path!:\t\tmake typeset! [path! set-path! get-path! lit-path!]\n\t\t\tany-block!:\t\tunion any-path! any-list!\n\t\t\tany-function!:\tmake typeset! [native! action! op! function!] ;routine!\n\t\t\tany-object!:\tmake typeset! [object! error!] ;port!\n\t\t\tany-string!:\tmake typeset! [string! file! url! tag! email! ref!]\n\t\t\tseries!:\t\tunion make typeset! [binary!] union any-block! any-string! ;image! vector!\n\t\t\timmediate!:\t\tunion scalar! union all-word! make typeset! [none! logic! datatype! typeset! date!] ;handle!\n\t\t\tdefault!:\t\tunion series! union immediate! union any-object! union external! union any-function! make typeset! [map! bitset!]\n\t\t\tany-type!:\t\tunion default! internal!\n\n\t\t\tRed: none: #(none)\n\t\t\ttrue: yes: on: #(true)\n\t\t\tfalse: no: off: #(false)\n\n\t\t\tnewline: #\"^/\"\n\t\t\ttab: #\"^-\"\n\t\t");
		RedJS.printHandler = Util.IS_NODE ? function(s) {
			process.stdout.write(s + '\n');
		} : function(s) {
			console.log(s);
		};
		RedJS.prinHandler = Util.IS_NODE ? function(s) {
			process.stdout.write(s);
		} : function(s) {
			throw haxe_Exception.thrown("Can't use `prin` on web!");
		};
		RedJS.inputHandler = Util.IS_NODE ? function() {
			let readline = require("readline");
			let io = readline.createInterface({ input : process.stdin, output : process.stdout});
			let input_x = null;
			io.question("",function(_input) {
				input_x = _input;
			});
			while(input_x == null) {
			}
			return input_x;
		} : function() {
			throw haxe_Exception.thrown("Can't use user input on web");
		};
	}
	static evalCode(code) {
		return runtime_Eval.evalCode(code);
	}
	static form(value) {
		return runtime_actions_Form.call(value,runtime_actions_Form.defaultOptions).toJs();
	}
	static mold(value) {
		return runtime_actions_Mold.call(value,runtime_actions_Mold.defaultOptions).toJs();
	}
	static setPrintHandler(handler) {
		RedJS.printHandler = handler;
	}
	static setPrinHandler(handler) {
		RedJS.prinHandler = handler;
	}
	static setInputHandler(handler) {
		RedJS.inputHandler = handler;
	}
}
$hx_exports["RedJS"] = RedJS;
RedJS.__name__ = true;
class types_base_Symbol {
	constructor(name) {
		this.name = name;
	}
	equalsString(str,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		if(ignoreCase) {
			return this.name.toLowerCase() == str.toLowerCase();
		} else {
			return this.name == str;
		}
	}
	equalsSymbol(sym,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		if(ignoreCase) {
			return this.name.toLowerCase() == sym.name.toLowerCase();
		} else {
			return this == sym;
		}
	}
	static make(name) {
		let tmp;
		return types_base_Symbol.TABLE.get(name) ?? (types_base_Symbol.INDEXES.set(name, types_base_Symbol.MAX_INDEX++), types_base_Symbol.TABLE.set(name, tmp = new types_base_Symbol(name)), tmp);
	}
}
types_base_Symbol.__name__ = true;
Object.assign(types_base_Symbol.prototype, {
	__class__: types_base_Symbol
});
class types_base_Context {
	constructor(symbols,values) {
		this.value = null;
		if(symbols != null && values != null) {
			let _g = [];
			let _g1 = 0;
			let _g2 = symbols.length;
			while(_g1 < _g2) {
				let i = _g1++;
				_g.push(symbols[i].copyIn(this,i));
			}
			this.symbols = _g;
			this.values = values.slice();
		} else {
			this.symbols = [];
			this.values = [];
		}
	}
	offsetOf(word,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		if(ignoreCase) {
			return this.symbols.findIndex(function(w) {
				return w.equalsString(word);
			});
		} else {
			return this.symbols.findIndex(function(w) {
				return w.symbol.name == word;
			});
		}
	}
	offsetOfSymbol(sym,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		return this.symbols.findIndex(function(w) {
			return w.equalsSymbol(sym,ignoreCase);
		});
	}
	get(word,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let _g = this.offsetOf(word,ignoreCase);
		if(_g == -1) {
			throw haxe_Exception.thrown("Word `" + word + "` doesn't exist!");
		} else {
			return this.values[_g];
		}
	}
	getWord(word) {
		if(word.symbol == runtime_Words.SELF && word.index == -1 && this.value != null && ((this.value) instanceof types_Object)) {
			return this.value;
		}
		if(word.index == -1) {
			throw haxe_Exception.thrown("Word `" + word.symbol.name + " doesn't exist!");
		}
		return this.values[word.index];
	}
	getSymbol(word,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let _g = this.offsetOf(word,ignoreCase);
		if(_g == -1) {
			throw haxe_Exception.thrown("Word `" + word + "` doesn't exist!");
		} else {
			return this.symbols[_g];
		}
	}
	set(word,value,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let _g = this.offsetOf(word,ignoreCase);
		if(_g == -1) {
			throw haxe_Exception.thrown("Word `" + word + "` doesn't exist!");
		} else {
			this.values[_g] = value;
			return value;
		}
	}
	add(word,value,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		if(this.contains(word,ignoreCase)) {
			throw haxe_Exception.thrown("Word `" + word + "` already exists!");
		} else {
			let sym = new types_Word(types_base_Symbol.make(word),this,this.symbols.length);
			this.symbols.push(sym);
			this.values[sym.index] = value;
			return sym;
		}
	}
	addSymbol(symbol) {
		let index = this.findOrStore(symbol);
		if(index != -1) {
			return index;
		}
		return this.values.push(types_Unset.UNSET) - 1;
	}
	addOrSet(word,value,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let _g = this.offsetOf(word,ignoreCase);
		if(_g == -1) {
			let sym = new types_Word(types_base_Symbol.make(word),this,this.symbols.length);
			this.symbols.push(sym);
			this.values.push(value);
			return sym;
		} else {
			this.values[_g] = value;
			return this.symbols[_g];
		}
	}
	contains(word,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		return this.offsetOf(word,ignoreCase) != -1;
	}
	collectSetWords(block) {
		let origSize = this.symbols.length;
		let _gthis = block;
		let _this = block.values.slice(block.index);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _gthis.wrap(_this[i]);
		}
		let _g_current = 0;
		let _g_array = result;
		while(_g_current < _g_array.length) {
			let value = _g_array[_g_current++];
			if(((value) instanceof types_SetWord) == true) {
				let __anon0__word = value;
				let word = __anon0__word;
				this.addWord(word);
			}
		}
		return origSize < this.symbols.length;
	}
	findOrStore(symbol,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let index = this.offsetOfSymbol(symbol,ignoreCase);
		if(index == -1) {
			let word = new types_Word(symbol);
			let newIndex = this.symbols.push(word) - 1;
			word.context = this;
			word.index = newIndex;
			return -1;
		} else {
			return index;
		}
	}
	addWord(word,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let index = this.offsetOfSymbol(word.symbol,ignoreCase);
		if(index == -1) {
			let newIndex = this.symbols.push(word) - 1;
			word.context = this;
			word.index = newIndex;
			this.values.push(types_Unset.UNSET);
			return newIndex;
		} else {
			return index;
		}
	}
	addOrSetWord(word,value,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		this.values[this.addWord(word,ignoreCase)] = value;
	}
	bindWord(word) {
		let index = this.offsetOfSymbol(word.symbol);
		if(index != -1) {
			word.context = this;
			word.index = index;
		}
		return index;
	}
	bind(block,hasSelf,cache) {
		if(cache == null) {
			cache = new Set([]);
		} else if(cache.has(block)) {
			return;
		} else {
			cache.add(block);
		}
		let values = block.values;
		let _g = block.index;
		let _g1 = block.values.length;
		while(_g < _g1) {
			let i = _g++;
			let _g1 = values[i];
			let _hx_tmp;
			let _hx_tmp1;
			if(((_g1) instanceof types_base__$AnyWord) == true) {
				let __anon0__word = _g1;
				let word = __anon0__word;
				if(hasSelf && ((word) instanceof types_Word) && word.symbol == runtime_Words.SELF) {
					values[i] = word.copyIn(this,-1);
				} else {
					word = word.copyFrom(word);
					this.bindWord(word);
					values[i] = word;
				}
			} else {
				_hx_tmp1 = ((_g1) instanceof types_Refinement);
				if(_hx_tmp1 == true) {
					let __anon0__word = _g1;
					let word = __anon0__word;
					if(hasSelf && ((word) instanceof types_Word) && word.symbol == runtime_Words.SELF) {
						values[i] = word.copyIn(this,-1);
					} else {
						word = word.copyFrom(word);
						this.bindWord(word);
						values[i] = word;
					}
				} else {
					_hx_tmp = ((_g1) instanceof types_base__$BlockLike);
					if(_hx_tmp == true) {
						let __anon0__blk = _g1;
						let blk = __anon0__blk;
						this.bind(blk,hasSelf,cache);
					}
				}
			}
		}
		cache.delete(block);
	}
}
types_base_Context.__name__ = true;
Object.assign(types_base_Context.prototype, {
	__class__: types_base_Context
});
class types_base_IValue {
}
types_base_IValue.__name__ = true;
types_base_IValue.__isInterface__ = true;
class Value {
	get_TYPE_KIND() {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "src/types/Value.hx", lineNumber : 15, className : "types.Value", methodName : "get_TYPE_KIND"});
	}
	isTruthy() {
		return true;
	}
	isUnset() {
		return false;
	}
	isA(type) {
		return type.matchesTypeOfValue(this);
	}
	thisType() {
		return this.constructor;
	}
}
$hx_exports["Value"] = Value;
Value.__name__ = true;
Value.__interfaces__ = [types_base_IValue];
Object.assign(Value.prototype, {
	__class__: Value
});
class types_base_IDatatype {
}
types_base_IDatatype.__name__ = true;
types_base_IDatatype.__isInterface__ = true;
Object.assign(types_base_IDatatype.prototype, {
	__class__: types_base_IDatatype
});
class types_Datatype extends Value {
	constructor(name,kind) {
		super();
		this.name = name;
		this.kind = kind;
		types_Datatype.TYPES.set(kind,this);
	}
	matchesTypeOfValue(value) {
		return value.get_TYPE_KIND() == this.kind;
	}
	get_TYPE_KIND() {
		return 0;
	}
}
types_Datatype.__name__ = true;
types_Datatype.__interfaces__ = [types_base_IDatatype];
types_Datatype.__super__ = Value;
Object.assign(types_Datatype.prototype, {
	__class__: types_Datatype
});
class Runtime {
	static registerDatatypes() {
		;
		;
	}
}
Runtime.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		let v = parseInt(x);
		if(isNaN(v)) {
			return null;
		}
		return v;
	}
}
Std.__name__ = true;
class StringBuf {
	constructor() {
		this.b = "";
	}
}
StringBuf.__name__ = true;
Object.assign(StringBuf.prototype, {
	__class__: StringBuf
});
class StringTools {
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
}
StringTools.__name__ = true;
class Tokenizer {
	static matchRxWithGuardRx(rdr,guard,rx) {
		if(rdr.matchesRx(guard)) {
			return rdr.matchRx(rx);
		} else {
			return null;
		}
	}
	static matchRxWithGuard(rdr,guard,rx) {
		if(rdr.matches(guard)) {
			return rdr.matchRx(rx);
		} else {
			return null;
		}
	}
	static eatEmpty(rdr) {
		do rdr.trimSpace(); while(rdr.tryMatchRx(tokenizer_Regexps.comment) != null);
	}
	static makeNext(rdr) {
		Tokenizer.eatEmpty(rdr);
		let match = null;
		let res;
		match = rdr.tryMatchRx(tokenizer_Regexps.div);
		if(match != null) {
			res = tokenizer_Token.TWord(match[0]);
		} else {
			match = rdr.tryMatchRx(tokenizer_Regexps.getDiv);
			if(match != null) {
				res = tokenizer_Token.TGetWord(match[1]);
			} else {
				match = rdr.tryMatchRx(tokenizer_Regexps.litDiv);
				if(match != null) {
					res = tokenizer_Token.TLitWord(match[1]);
				} else {
					match = rdr.tryMatchRx(tokenizer_Regexps.setDiv);
					if(match != null) {
						res = tokenizer_Token.TSetWord(match[1]);
					} else {
						match = Tokenizer.matchRxWithGuard(rdr,tokenizer_RegexpChecks.ref,tokenizer_Regexps.ref);
						if(match != null) {
							res = tokenizer_Token.TRef(match[1]);
						} else {
							match = Tokenizer.matchRxWithGuard(rdr,tokenizer_RegexpChecks.refinement,tokenizer_Regexps.refinement);
							if(match != null) {
								res = tokenizer_Token.TRefinement(match[1]);
							} else {
								match = rdr.tryMatchRx(tokenizer_Regexps.hexa);
								if(match != null) {
									res = tokenizer_Token.TInteger(Util.mustParseInt("0x" + match[1]));
								} else {
									match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.file,tokenizer_Regexps.file);
									if(match != null) {
										let tmp = match[1];
										res = tokenizer_Token.TFile(tmp != null ? tmp : match[2]);
									} else {
										match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.url,tokenizer_Regexps.url);
										if(match != null) {
											res = tokenizer_Token.TUrl(match[0]);
										} else {
											let res1;
											if(rdr.tryMatch("-$")) {
												match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.float,tokenizer_Regexps.float);
												if(match == null) {
													match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.integer,tokenizer_Regexps.integer);
													res1 = match != null;
												} else {
													res1 = true;
												}
											} else {
												res1 = false;
											}
											if(res1) {
												res = tokenizer_Token.TMoney("-" + match[0]);
											} else {
												let res1;
												if(rdr.tryMatch("$") || rdr.tryMatch("+$")) {
													match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.float,tokenizer_Regexps.float);
													if(match == null) {
														match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.integer,tokenizer_Regexps.integer);
														res1 = match != null;
													} else {
														res1 = true;
													}
												} else {
													res1 = false;
												}
												if(res1) {
													res = tokenizer_Token.TMoney(match[0]);
												} else {
													match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.wordMoney,tokenizer_Regexps.wordMoney);
													if(match != null) {
														let neg = match[1];
														let region = match[2];
														if(rdr.tryMatch("$")) {
															let res1;
															match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.float,tokenizer_Regexps.float);
															if(match == null) {
																match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.integer,tokenizer_Regexps.integer);
																res1 = match != null;
															} else {
																res1 = true;
															}
															if(res1) {
																res = tokenizer_Token.TMoney(neg + match[0],region);
															} else {
																throw haxe_Exception.thrown("Invalid money!");
															}
														} else {
															rdr.pos -= region.length + neg.length;
															match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.word,tokenizer_Regexps.word);
															if(match != null) {
																res = tokenizer_Actions.word(rdr,match[0]);
															} else {
																throw haxe_Exception.thrown("Invalid word!");
															}
														}
													} else {
														match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.word,tokenizer_Regexps.word);
														if(match != null) {
															res = tokenizer_Actions.word(rdr,match[0]);
														} else {
															match = rdr.tryMatchRx(tokenizer_Regexps.specialWord);
															if(match != null) {
																let word = match[0];
																res = rdr.tryMatch(":") ? tokenizer_Token.TSetWord(word) : tokenizer_Token.TWord(word);
															} else if(rdr.tryMatch(":")) {
																let _hx_tmp;
																let _hx_tmp1 = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.word,tokenizer_Regexps.word);
																let _hx_tmp2 = _hx_tmp1;
																if(_hx_tmp2 == null) {
																	if(_hx_tmp1 == null) {
																		_hx_tmp = rdr.tryMatchRx(tokenizer_Regexps.specialWord);
																		let _hx_tmp1 = _hx_tmp;
																		if(_hx_tmp1 == null) {
																			throw haxe_Exception.thrown("error!");
																		} else if(_hx_tmp1.length == 1) {
																			let _g = _hx_tmp1[0];
																			if(rdr.peek() == ":") {
																				throw haxe_Exception.thrown("error!");
																			} else {
																				res = tokenizer_Token.TGetWord(_g);
																			}
																		} else {
																			throw haxe_Exception.thrown("error!");
																		}
																	} else {
																		_hx_tmp = rdr.tryMatchRx(tokenizer_Regexps.specialWord);
																		let _hx_tmp1 = _hx_tmp;
																		if(_hx_tmp1 == null) {
																			throw haxe_Exception.thrown("error!");
																		} else if(_hx_tmp1.length == 1) {
																			let _g = _hx_tmp1[0];
																			if(rdr.peek() == ":") {
																				throw haxe_Exception.thrown("error!");
																			} else {
																				res = tokenizer_Token.TGetWord(_g);
																			}
																		} else {
																			throw haxe_Exception.thrown("error!");
																		}
																	}
																} else if(_hx_tmp2.length == 1) {
																	let _g = _hx_tmp2[0];
																	if(rdr.peek() == ":") {
																		throw haxe_Exception.thrown("error!");
																	} else if(rdr.peek() == "/") {
																		let path = tokenizer_Actions.path(rdr,tokenizer_Token.TWord(_g));
																		if(rdr.peek() == ":") {
																			throw haxe_Exception.thrown("error!");
																		} else {
																			res = tokenizer_Token.TGetPath(path);
																		}
																	} else {
																		res = tokenizer_Token.TGetWord(_g);
																	}
																} else if(_hx_tmp1 == null) {
																	_hx_tmp = rdr.tryMatchRx(tokenizer_Regexps.specialWord);
																	let _hx_tmp1 = _hx_tmp;
																	if(_hx_tmp1 == null) {
																		throw haxe_Exception.thrown("error!");
																	} else if(_hx_tmp1.length == 1) {
																		let _g = _hx_tmp1[0];
																		if(rdr.peek() == ":") {
																			throw haxe_Exception.thrown("error!");
																		} else {
																			res = tokenizer_Token.TGetWord(_g);
																		}
																	} else {
																		throw haxe_Exception.thrown("error!");
																	}
																} else {
																	_hx_tmp = rdr.tryMatchRx(tokenizer_Regexps.specialWord);
																	let _hx_tmp1 = _hx_tmp;
																	if(_hx_tmp1 == null) {
																		throw haxe_Exception.thrown("error!");
																	} else if(_hx_tmp1.length == 1) {
																		let _g = _hx_tmp1[0];
																		if(rdr.peek() == ":") {
																			throw haxe_Exception.thrown("error!");
																		} else {
																			res = tokenizer_Token.TGetWord(_g);
																		}
																	} else {
																		throw haxe_Exception.thrown("error!");
																	}
																}
															} else if(rdr.tryMatch("'")) {
																let _hx_tmp;
																let _hx_tmp1 = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.word,tokenizer_Regexps.word);
																let _hx_tmp2 = _hx_tmp1;
																if(_hx_tmp2 == null) {
																	if(_hx_tmp1 == null) {
																		_hx_tmp = rdr.tryMatchRx(tokenizer_Regexps.specialWord);
																		let _hx_tmp1 = _hx_tmp;
																		if(_hx_tmp1 == null) {
																			throw haxe_Exception.thrown("error!");
																		} else if(_hx_tmp1.length == 1) {
																			let _g = _hx_tmp1[0];
																			if(rdr.peek() == ":") {
																				throw haxe_Exception.thrown("error!");
																			} else {
																				res = tokenizer_Token.TLitWord(_g);
																			}
																		} else {
																			throw haxe_Exception.thrown("error!");
																		}
																	} else {
																		_hx_tmp = rdr.tryMatchRx(tokenizer_Regexps.specialWord);
																		let _hx_tmp1 = _hx_tmp;
																		if(_hx_tmp1 == null) {
																			throw haxe_Exception.thrown("error!");
																		} else if(_hx_tmp1.length == 1) {
																			let _g = _hx_tmp1[0];
																			if(rdr.peek() == ":") {
																				throw haxe_Exception.thrown("error!");
																			} else {
																				res = tokenizer_Token.TLitWord(_g);
																			}
																		} else {
																			throw haxe_Exception.thrown("error!");
																		}
																	}
																} else if(_hx_tmp2.length == 1) {
																	let _g = _hx_tmp2[0];
																	if(rdr.peek() == ":") {
																		throw haxe_Exception.thrown("error!");
																	} else if(rdr.peek() == "/") {
																		let path = tokenizer_Actions.path(rdr,tokenizer_Token.TWord(_g));
																		if(rdr.peek() == ":") {
																			throw haxe_Exception.thrown("error!");
																		} else {
																			res = tokenizer_Token.TLitPath(path);
																		}
																	} else {
																		res = tokenizer_Token.TLitWord(_g);
																	}
																} else if(_hx_tmp1 == null) {
																	_hx_tmp = rdr.tryMatchRx(tokenizer_Regexps.specialWord);
																	let _hx_tmp1 = _hx_tmp;
																	if(_hx_tmp1 == null) {
																		throw haxe_Exception.thrown("error!");
																	} else if(_hx_tmp1.length == 1) {
																		let _g = _hx_tmp1[0];
																		if(rdr.peek() == ":") {
																			throw haxe_Exception.thrown("error!");
																		} else {
																			res = tokenizer_Token.TLitWord(_g);
																		}
																	} else {
																		throw haxe_Exception.thrown("error!");
																	}
																} else {
																	_hx_tmp = rdr.tryMatchRx(tokenizer_Regexps.specialWord);
																	let _hx_tmp1 = _hx_tmp;
																	if(_hx_tmp1 == null) {
																		throw haxe_Exception.thrown("error!");
																	} else if(_hx_tmp1.length == 1) {
																		let _g = _hx_tmp1[0];
																		if(rdr.peek() == ":") {
																			throw haxe_Exception.thrown("error!");
																		} else {
																			res = tokenizer_Token.TLitWord(_g);
																		}
																	} else {
																		throw haxe_Exception.thrown("error!");
																	}
																}
															} else {
																match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.issue,tokenizer_Regexps.issue);
																if(match != null) {
																	res = tokenizer_Token.TIssue(match[1]);
																} else {
																	match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.pair,tokenizer_Regexps.pair);
																	if(match != null) {
																		res = tokenizer_Token.TPair(Util.mustParseInt(match[1]),Util.mustParseInt(match[2]));
																	} else {
																		match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.time,tokenizer_Regexps.time);
																		if(match != null) {
																			let s = match[3];
																			res = tokenizer_Token.TTime(Util.mustParseInt(match[1]),Util.mustParseInt(match[2]),s == null ? 0 : parseFloat(s));
																		} else {
																			match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.date,tokenizer_Regexps.date);
																			if(match != null) {
																				res = tokenizer_Actions.date(match.groups);
																			} else if(rdr.matchesRx(tokenizer_RegexpChecks.specialFloat)) {
																				let tmp = tokenizer_Actions.specialFloat(rdr);
																				if(tmp == null) {
																					throw haxe_Exception.thrown("Invalid float literal!");
																				}
																				res = tokenizer_Token.TFloat(tmp);
																			} else {
																				match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.float,tokenizer_Regexps.float);
																				if(match != null) {
																					let float = parseFloat(match[0]);
																					res = rdr.tryMatch("%") ? tokenizer_Token.TPercent(float) : tokenizer_Token.TFloat(float);
																				} else {
																					match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.integer,tokenizer_Regexps.integer);
																					if(match != null) {
																						let integer = Util.mustParseInt(match[0]);
																						res = rdr.tryMatch("%") ? tokenizer_Token.TPercent(integer) : tokenizer_Token.TInteger(integer);
																					} else {
																						match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.tuple,tokenizer_Regexps.tuple);
																						if(match != null) {
																							let end = match.indexOf(undefined);
																							let _this = match.slice(1,end == -1 ? null : end);
																							let result = new Array(_this.length);
																							let _g = 0;
																							let _g1 = _this.length;
																							while(_g < _g1) {
																								let i = _g++;
																								result[i] = Util.mustParseInt(_this[i]);
																							}
																							res = tokenizer_Token.TTuple(result);
																						} else {
																							match = Tokenizer.matchRxWithGuard(rdr,tokenizer_RegexpChecks.char,tokenizer_Regexps.char);
																							if(match != null) {
																								res = tokenizer_Token.TChar(match[1]);
																							} else {
																								match = Tokenizer.matchRxWithGuard(rdr,tokenizer_RegexpChecks.string,tokenizer_Regexps.string);
																								if(match != null) {
																									res = tokenizer_Token.TString(match[1]);
																								} else if(rdr.tryMatch(tokenizer_RegexpChecks.multiString)) {
																									let out = "";
																									let level = 1;
																									_hx_loop2: while(level > 0) {
																										if(rdr.eof()) {
																											throw haxe_Exception.thrown("Syntax error: Invalid string! near \"" + out + "\"  at " + rdr.getLocStr());
																										}
																										let _g = rdr.next();
																										switch(_g) {
																										case "^":
																											let _g1 = rdr.next();
																											let out1;
																											switch(_g1) {
																											case "{":case "}":
																												out1 = _g1;
																												break;
																											default:
																												out1 = "^" + _g1;
																											}
																											out += out1;
																											break;
																										case "{":
																											out += "{";
																											++level;
																											break;
																										case "}":
																											if(level > 0) {
																												out += "}";
																												--level;
																											} else {
																												break _hx_loop2;
																											}
																											break;
																										default:
																											out += _g;
																										}
																									}
																									res = tokenizer_Token.TString(out);
																								} else {
																									match = rdr.tryMatchRx(tokenizer_Regexps.beginRawString);
																									if(match != null) {
																										let _g = rdr.matchSubstr("}" + match[1]);
																										if(_g == null) {
																											throw haxe_Exception.thrown("Invalid string literal");
																										} else {
																											res = tokenizer_Token.TRawString(_g);
																										}
																									} else {
																										match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.tag,tokenizer_Regexps.tag);
																										if(match != null) {
																											res = tokenizer_Token.TTag(match[1]);
																										} else if(rdr.tryMatch("2#{")) {
																											let out = "";
																											Tokenizer.eatEmpty(rdr);
																											while(!rdr.tryMatch("}")) {
																												let _g = 0;
																												while(_g < 8) {
																													++_g;
																													let _g1 = rdr.next();
																													switch(_g1) {
																													case "0":case "1":
																														out += _g1;
																														break;
																													default:
																														throw haxe_Exception.thrown("Unexpected character \"" + _g1 + "\" in binary! at " + rdr.getLocStr());
																													}
																												}
																												Tokenizer.eatEmpty(rdr);
																											}
																											res = tokenizer_Token.TBinary(out,2);
																										} else {
																											match = rdr.tryMatchRx(/(?:16)?#\{/);
																											if(match != null) {
																												let out = "";
																												Tokenizer.eatEmpty(rdr);
																												while(!rdr.tryMatch("}")) {
																													let _g = rdr.next(2);
																													if(/[a-fA-F\d]{2}$/.test(_g)) {
																														out += _g;
																													} else {
																														throw haxe_Exception.thrown("Unexpected character \"" + _g + "\" in binary! at " + rdr.getLocStr());
																													}
																													Tokenizer.eatEmpty(rdr);
																												}
																												res = tokenizer_Token.TBinary(out,16);
																											} else if(rdr.tryMatch("64#{")) {
																												let out = "";
																												Tokenizer.eatEmpty(rdr);
																												while(!rdr.tryMatch("}")) {
																													let _g = rdr.next();
																													if(/[a-zA-Z\d=\/+]$/.test(_g)) {
																														out += _g;
																													} else {
																														throw haxe_Exception.thrown("Unexpected character \"" + _g + "\" in binary! at " + rdr.getLocStr());
																													}
																													Tokenizer.eatEmpty(rdr);
																												}
																												res = tokenizer_Token.TBinary(out,64);
																											} else if(rdr.matches("(")) {
																												if(rdr.matchesRx(tokenizer_RegexpChecks.point)) {
																													rdr.match("(");
																													rdr.trimSpace();
																													res = tokenizer_Actions.point(rdr);
																												} else {
																													res = tokenizer_Token.TParen(tokenizer_Actions.delim(rdr,"paren!","(",")"));
																												}
																											} else if(rdr.matches("[")) {
																												res = tokenizer_Token.TBlock(tokenizer_Actions.delim(rdr,"block!","[","]"));
																											} else if(rdr.matches("#[")) {
																												res = tokenizer_Token.TMap(tokenizer_Actions.delim(rdr,"map!","#[","]"));
																											} else if(rdr.matches("#(")) {
																												res = tokenizer_Token.TConstruct(tokenizer_Actions.delim(rdr,"constructor!","#(",")"));
																											} else {
																												throw haxe_Exception.thrown("Syntax error: Invalid token \"" + rdr.peek() + "\" near \"" + rdr.stream.substr(rdr.pos,5) + "\" at " + rdr.getLocStr());
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		Tokenizer.eatEmpty(rdr);
		return res;
	}
	static tokenize(input) {
		tokenizer_Actions.makeNext = tokenizer_Actions.makeNext != null ? tokenizer_Actions.makeNext : Tokenizer.makeNext;
		let rdr = new tokenizer_Reader(input);
		let out = [];
		while(!rdr.eof()) out.push(Tokenizer.makeNext(rdr));
		return out;
	}
	static tokenToValue(token) {
		switch(token[1]) {
		case 0:
			return new types_Word(types_base_Symbol.make(token[2]));
		case 1:
			return new types_GetWord(types_base_Symbol.make(token[2]));
		case 2:
			return new types_SetWord(types_base_Symbol.make(token[2]));
		case 3:
			return new types_LitWord(types_base_Symbol.make(token[2]));
		case 4:
			let _g = token[2];
			let f = Tokenizer.tokenToValue;
			let result = new Array(_g.length);
			let _g1 = 0;
			let _g2 = _g.length;
			while(_g1 < _g2) {
				let i = _g1++;
				result[i] = f(_g[i]);
			}
			return new types_Path(result);
		case 5:
			let _g3 = token[2];
			let f1 = Tokenizer.tokenToValue;
			let result1 = new Array(_g3.length);
			let _g4 = 0;
			let _g5 = _g3.length;
			while(_g4 < _g5) {
				let i = _g4++;
				result1[i] = f1(_g3[i]);
			}
			return new types_GetPath(result1);
		case 6:
			let _g6 = token[2];
			let f2 = Tokenizer.tokenToValue;
			let result2 = new Array(_g6.length);
			let _g7 = 0;
			let _g8 = _g6.length;
			while(_g7 < _g8) {
				let i = _g7++;
				result2[i] = f2(_g6[i]);
			}
			return new types_SetPath(result2);
		case 7:
			let _g9 = token[2];
			let f3 = Tokenizer.tokenToValue;
			let result3 = new Array(_g9.length);
			let _g10 = 0;
			let _g11 = _g9.length;
			while(_g10 < _g11) {
				let i = _g10++;
				result3[i] = f3(_g9[i]);
			}
			return new types_LitPath(result3);
		case 8:
			return new types_Integer(token[2]);
		case 9:
			return new types_Float(token[2]);
		case 10:
			return new types_Percent(token[2] / 100);
		case 11:
			let _g12 = token[3];
			return new types_Money(util_Dec64.fromString(token[2]),_g12 == null || _g12 == "" ? null : new types_Word(types_base_Symbol.make(_g12)));
		case 12:
			return types_Char.fromRed(token[2]);
		case 13:
			return types_String.fromRed(token[2]);
		case 14:
			return types_String.fromString(token[2]);
		case 15:
			return new types_File(types_base__$String.codesFromRed(token[2]));
		case 16:
			return new types_Email(types_base__$String.codesFromRed(token[2]));
		case 17:
			return new types_Url(types_base__$String.codesFromRed(token[2]));
		case 18:
			return new types_Issue(types_base_Symbol.make(token[2]));
		case 19:
			return new types_Refinement(types_base_Symbol.make(token[2]));
		case 20:
			return new types_Tag(types_base__$String.codesFromRed(token[2]));
		case 21:
			return new types_Ref(types_base__$String.codesFromRed(token[2]));
		case 22:
			let _g13 = token[2];
			switch(token[3]) {
			case 2:
				return new types_Binary(_g13.match(/.{8}/g).map(x => parseInt(x, 2)));
			case 16:
				return new types_Binary(_g13.match(/../g).map(x => parseInt(x, 16)));
			case 64:
				return new types_Binary([...atob(_g13)].map(c => c.charCodeAt()));
			default:
				throw haxe_Exception.thrown("bad");
			}
			break;
		case 23:
			let _g14 = token[2];
			let result4 = new Array(_g14.length);
			let _g15 = 0;
			let _g16 = _g14.length;
			while(_g15 < _g16) {
				let i = _g15++;
				result4[i] = Tokenizer.tokenToValue(_g14[i]);
			}
			return new types_Block(result4);
		case 24:
			let _g17 = token[2];
			let result5 = new Array(_g17.length);
			let _g18 = 0;
			let _g19 = _g17.length;
			while(_g18 < _g19) {
				let i = _g18++;
				result5[i] = Tokenizer.tokenToValue(_g17[i]);
			}
			return new types_Paren(result5);
		case 25:
			let _g20 = token[2];
			let _g21 = [];
			let _g_current = 0;
			while(_g_current < _g20.length) {
				let value = Tokenizer.tokenToValue(_g20[_g_current++]);
				if((_g_current - 1) % 2 == 0) {
					_g21.push(types_Map.preprocessKey(value));
				} else {
					_g21.push(value);
				}
			}
			return new types_Map(_g21);
		case 26:
			return new types_Tuple(new Uint8ClampedArray(token[2]));
		case 27:
			return new types_Pair(token[2],token[3]);
		case 28:
			return new types_Point2D(token[2],token[3]);
		case 29:
			return new types_Point3D(token[2],token[3],token[4]);
		case 30:
			let _g22 = token[2];
			let _g23 = token[3];
			let _g24 = token[4];
			let res = new Date();
			switch(_g22[1]) {
			case 0:
				res.setFullYear(_g22[2],_g22[3] - 1,_g22[4]);
				break;
			case 1:
				res.setFullYear(_g22[2],0,_g22[3]);
				break;
			case 2:
				let _g25 = _g22[4];
				res = util_DateTools.weekToDate(_g22[2],_g22[3]);
				if(_g25 > 1) {
					res.setDate(res.getDate() + (_g25 - 1));
				}
				break;
			}
			if(_g23 != null) {
				switch(_g23[1]) {
				case 0:
					let _g26 = _g23[4];
					res.setHours(_g23[2]);
					res.setMinutes(_g23[3]);
					res.setSeconds(Math.trunc(_g26));
					res.setMilliseconds(_g26 * 1000 % 1000);
					break;
				case 1:
					let _g27 = _g23[2];
					res.setHours(Math.floor(_g27 / 10000) % 100);
					res.setMinutes(Math.floor(_g27 / 100) % 100);
					res.setSeconds(_g27 % 100);
					res.setMilliseconds(_g23[3]);
					break;
				case 2:
					let _g28 = _g23[2];
					res.setHours(Math.floor(_g28 / 10000) % 100);
					res.setMinutes(Math.floor(_g28 / 100) % 100);
					res.setSeconds(0);
					res.setMilliseconds(0);
					break;
				}
			} else {
				res.setHours(0);
				res.setMinutes(0);
				res.setSeconds(0);
				res.setMilliseconds(0);
			}
			if(_g24 != null) {
				let sign;
				let hours;
				let minutes;
				switch(_g24[1]) {
				case 0:
					sign = _g24[2];
					hours = _g24[3];
					minutes = _g24[4];
					break;
				case 1:
					let _g = _g24[3];
					sign = _g24[2];
					hours = Math.floor(_g / 100);
					minutes = _g % 100;
					break;
				case 2:
					sign = _g24[2];
					hours = _g24[3];
					minutes = 0;
					break;
				}
				if(minutes < 15) {
					minutes = 0;
				} else if(minutes < 30) {
					minutes = 15;
				} else if(minutes < 45) {
					minutes = 30;
				} else if(minutes < 60) {
					minutes = 45;
				} else if(minutes >= 60) {
					hours += Math.floor(minutes / 60);
					minutes %= 60;
				}
				if(sign == "-") {
					hours *= -1;
				}
				return new types_Date(res,new types_Time((Math.abs(hours) * 3600 + minutes * 60) * Math.sign(hours)));
			} else {
				return new types_Date(res,new types_Time(0));
			}
			break;
		case 31:
			let _g29 = token[2];
			return new types_Time((Math.abs(_g29) * 3600 + token[3] * 60 + token[4]) * Math.sign(_g29));
		case 32:
			let _g30 = token[2];
			if(_g30.length == 1) {
				let _g = _g30[0];
				if(_g[1] == 0) {
					switch(_g[2]) {
					case "false":
						return types_Logic.FALSE;
					case "none":case "none!":
						return types_None.NONE;
					case "true":
						return types_Logic.TRUE;
					default:
						throw haxe_Exception.thrown("NYI");
					}
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		}
	}
	static parse(input) {
		let _this = Tokenizer.tokenize(input);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = Tokenizer.tokenToValue(_this[i]);
		}
		return result;
	}
}
Tokenizer.__name__ = true;
class Util {
	static mustParseInt(str) {
		let _g = Std.parseInt(str);
		if(_g == null) {
			throw haxe_Exception.thrown("Value was null!");
		} else {
			return _g;
		}
	}
	static readUrl(url) {
		if(Util.IS_NODE) {
			return Util.CHILD_PROCESS.spawnSync("curl",[url]).stdout.toString();
		} else {
			return haxe_http_HttpJs.requestUrl(url);
		}
	}
	static toUpperCase(char) {
		if(97 <= char && char <= 122) {
			return char - 32;
		} else {
			return char;
		}
	}
}
Util.__name__ = true;
var haxe_StackItem = { __ename__:true,__constructs__:["CFunction","Module","FilePos","Method","LocalFunction"] };
haxe_StackItem.CFunction = ["CFunction",0];
haxe_StackItem.CFunction.toString = $estr;
haxe_StackItem.CFunction.__enum__ = haxe_StackItem;
haxe_StackItem.Module = function(m) { var $x = ["Module",1,m]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; }
haxe_StackItem.FilePos = function(s,file,line,column) { var $x = ["FilePos",2,s,file,line,column]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; }
haxe_StackItem.Method = function(classname,method) { var $x = ["Method",3,classname,method]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; }
haxe_StackItem.LocalFunction = function(v) { var $x = ["LocalFunction",4,v]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; }
class haxe_CallStack {
	static toString(stack) {
		let b = new StringBuf();
		let _g = 0;
		let _g1 = stack;
		while(_g < _g1.length) {
			let s = _g1[_g++];
			b.b += "\nCalled from ";
			haxe_CallStack.itemToString(b,s);
		}
		return b.b;
	}
	static subtract(this1,stack) {
		let startIndex = -1;
		let i = -1;
		while(++i < this1.length) {
			let _g = 0;
			let _g1 = stack.length;
			while(_g < _g1) if(haxe_CallStack.equalItems(this1[i],stack[_g++])) {
				if(startIndex < 0) {
					startIndex = i;
				}
				++i;
				if(i >= this1.length) {
					break;
				}
			} else {
				startIndex = -1;
			}
			if(startIndex >= 0) {
				break;
			}
		}
		if(startIndex >= 0) {
			return this1.slice(0,startIndex);
		} else {
			return this1;
		}
	}
	static equalItems(item1,item2) {
		if(item1 == null) {
			if(item2 == null) {
				return true;
			} else {
				return false;
			}
		} else {
			switch(item1[1]) {
			case 0:
				if(item2 == null) {
					return false;
				} else if(item2[1] == 0) {
					return true;
				} else {
					return false;
				}
				break;
			case 1:
				if(item2 == null) {
					return false;
				} else if(item2[1] == 1) {
					return item1[2] == item2[2];
				} else {
					return false;
				}
				break;
			case 2:
				if(item2 == null) {
					return false;
				} else if(item2[1] == 2) {
					if(item1[3] == item2[3] && item1[4] == item2[4] && item1[5] == item2[5]) {
						return haxe_CallStack.equalItems(item1[2],item2[2]);
					} else {
						return false;
					}
				} else {
					return false;
				}
				break;
			case 3:
				if(item2 == null) {
					return false;
				} else if(item2[1] == 3) {
					if(item1[2] == item2[2]) {
						return item1[3] == item2[3];
					} else {
						return false;
					}
				} else {
					return false;
				}
				break;
			case 4:
				if(item2 == null) {
					return false;
				} else if(item2[1] == 4) {
					return item1[2] == item2[2];
				} else {
					return false;
				}
				break;
			}
		}
	}
	static itemToString(b,s) {
		switch(s[1]) {
		case 0:
			b.b += "a C function";
			break;
		case 1:
			let _g = s[2];
			b.b = (b.b += "module ") + (_g == null ? "null" : "" + _g);
			break;
		case 2:
			let _g1 = s[2];
			let _g2 = s[3];
			let _g3 = s[4];
			let _g4 = s[5];
			if(_g1 != null) {
				haxe_CallStack.itemToString(b,_g1);
				b.b += " (";
			}
			b.b = (b.b += _g2 == null ? "null" : "" + _g2) + " line ";
			b.b += _g3 == null ? "null" : "" + _g3;
			if(_g4 != null) {
				b.b = (b.b += " column ") + (_g4 == null ? "null" : "" + _g4);
			}
			if(_g1 != null) {
				b.b += ")";
			}
			break;
		case 3:
			let _g5 = s[2];
			let _g6 = s[3];
			b.b = (b.b += Std.string(_g5 == null ? "<unknown>" : _g5)) + ".";
			b.b += _g6 == null ? "null" : "" + _g6;
			break;
		case 4:
			let _g7 = s[2];
			b.b = (b.b += "local function #") + (_g7 == null ? "null" : "" + _g7);
			break;
		}
	}
}
class haxe_IMap {
}
haxe_IMap.__name__ = true;
haxe_IMap.__isInterface__ = true;
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
		this.__skipStack = 0;
		let old = Error.prepareStackTrace;
		Error.prepareStackTrace = function(e) { return e.stack; }
		if(((native) instanceof Error)) {
			this.stack = native.stack;
		} else {
			let e = null;
			if(Error.captureStackTrace) {
				Error.captureStackTrace(this,haxe_Exception);
				e = this;
			} else {
				e = new Error();
				if(typeof(e.stack) == "undefined") {
					try { throw e; } catch(_) {}
					this.__skipStack++;
				}
			}
			this.stack = e.stack;
		}
		Error.prepareStackTrace = old;
	}
	unwrap() {
		return this.__nativeException;
	}
	toString() {
		return this.get_message();
	}
	details() {
		if(this.get_previous() == null) {
			let tmp = "Exception: " + this.toString();
			let tmp1 = this.get_stack();
			return tmp + (tmp1 == null ? "null" : haxe_CallStack.toString(tmp1));
		} else {
			let result = "";
			let e = this;
			let prev = null;
			while(e != null) {
				if(prev == null) {
					let result1 = "Exception: " + e.get_message();
					let tmp = e.get_stack();
					result = result1 + (tmp == null ? "null" : haxe_CallStack.toString(tmp)) + result;
				} else {
					let prevStack = haxe_CallStack.subtract(e.get_stack(),prev.get_stack());
					result = "Exception: " + e.get_message() + (prevStack == null ? "null" : haxe_CallStack.toString(prevStack)) + "\n\nNext " + result;
				}
				prev = e;
				e = e.get_previous();
			}
			return result;
		}
	}
	__shiftStack() {
		this.__skipStack++;
	}
	get_message() {
		return this.message;
	}
	get_previous() {
		return this.__previousException;
	}
	get_native() {
		return this.__nativeException;
	}
	get_stack() {
		let _g = this.__exceptionStack;
		if(_g == null) {
			let value = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.normalize(this.stack),this.__skipStack);
			this.setProperty("__exceptionStack",value);
			return value;
		} else {
			return _g;
		}
	}
	setProperty(name,value) {
		try {
			Object.defineProperty(this,name,{ value : value});
		} catch( _g ) {
			this[name] = value;
		}
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			e.__skipStack++;
			return e;
		}
	}
}
haxe_Exception.__name__ = true;
haxe_Exception.__super__ = Error;
Object.assign(haxe_Exception.prototype, {
	__class__: haxe_Exception
});
class haxe_Log {
	static formatOutput(v,infos) {
		let str = Std.string(v);
		if(infos == null) {
			return str;
		}
		let pstr = infos.fileName + ":" + infos.lineNumber;
		if(infos.customParams != null) {
			let _g = 0;
			let _g1 = infos.customParams;
			while(_g < _g1.length) str += ", " + Std.string(_g1[_g++]);
		}
		return pstr + ": " + str;
	}
	static trace(v,infos) {
		let str = haxe_Log.formatOutput(v,infos);
		if(typeof(console) != "undefined" && console.log != null) {
			console.log(str);
		}
	}
}
haxe_Log.__name__ = true;
class haxe_NativeStackTrace {
	static toHaxe(s,skip) {
		if(skip == null) {
			skip = 0;
		}
		if(s == null) {
			return [];
		} else if(typeof(s) == "string") {
			let stack = s.split("\n");
			if(stack[0] == "Error") {
				stack.shift();
			}
			let m = [];
			let _g = 0;
			let _g1 = stack.length;
			while(_g < _g1) {
				let i = _g++;
				if(skip > i) {
					continue;
				}
				let line = stack[i];
				let matched = line.match(/^    at ([$A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
				if(matched != null) {
					let path = matched[1].split(".");
					if(path[0] == "$hxClasses") {
						path.shift();
					}
					let meth = path.pop();
					let file = matched[2];
					let line = Std.parseInt(matched[3]);
					let column = Std.parseInt(matched[4]);
					m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line,column));
				} else {
					m.push(haxe_StackItem.Module(StringTools.trim(line)));
				}
			}
			return m;
		} else if(skip > 0 && Array.isArray(s)) {
			return s.slice(skip);
		} else {
			return s;
		}
	}
	static normalize(stack,skipItems) {
		if(skipItems == null) {
			skipItems = 0;
		}
		if(Array.isArray(stack) && skipItems > 0) {
			return stack.slice(skipItems);
		} else if(typeof(stack) == "string") {
			switch(stack.substring(0,6)) {
			case "Error\n":case "Error:":
				++skipItems;
				break;
			default:
			}
			return haxe_NativeStackTrace.skipLines(stack,skipItems);
		} else {
			return stack;
		}
	}
	static skipLines(stack,skip,pos) {
		if(pos == null) {
			pos = 0;
		}
		while(true) if(skip > 0) {
			pos = stack.indexOf("\n",pos);
			if(pos < 0) {
				return "";
			} else {
				skip = --skip;
				pos += 1;
				continue;
			}
		} else {
			return stack.substring(pos);
		}
	}
}
haxe_NativeStackTrace.__name__ = true;
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
		this.__skipStack++;
	}
	unwrap() {
		return this.value;
	}
}
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
Object.assign(haxe_ValueException.prototype, {
	__class__: haxe_ValueException
});
var haxe_ds_Either = { __ename__:true,__constructs__:["Left","Right"] };
haxe_ds_Either.Left = function(v) { var $x = ["Left",0,v]; $x.__enum__ = haxe_ds_Either; $x.toString = $estr; return $x; }
haxe_ds_Either.Right = function(v) { var $x = ["Right",1,v]; $x.__enum__ = haxe_ds_Either; $x.toString = $estr; return $x; }
class haxe_ds_IntMap {
	constructor() {
		this.h = { };
	}
}
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_IntMap.prototype, {
	__class__: haxe_ds_IntMap
});
var haxe_ds_Option = { __ename__:true,__constructs__:["Some","None"] };
haxe_ds_Option.Some = function(v) { var $x = ["Some",0,v]; $x.__enum__ = haxe_ds_Option; $x.toString = $estr; return $x; }
haxe_ds_Option.None = ["None",1];
haxe_ds_Option.None.toString = $estr;
haxe_ds_Option.None.__enum__ = haxe_ds_Option;
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
}
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_StringMap.prototype, {
	__class__: haxe_ds_StringMap
});
class haxe_exceptions_PosException extends haxe_Exception {
	constructor(message,previous,pos) {
		super(message,previous);
		if(pos == null) {
			this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
		} else {
			this.posInfos = pos;
		}
		this.__skipStack++;
	}
	toString() {
		return "" + super.toString() + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
}
haxe_exceptions_PosException.__name__ = true;
haxe_exceptions_PosException.__super__ = haxe_Exception;
Object.assign(haxe_exceptions_PosException.prototype, {
	__class__: haxe_exceptions_PosException
});
class haxe_exceptions_NotImplementedException extends haxe_exceptions_PosException {
	constructor(message,previous,pos) {
		if(message == null) {
			message = "Not implemented";
		}
		super(message,previous,pos);
		this.__skipStack++;
	}
}
haxe_exceptions_NotImplementedException.__name__ = true;
haxe_exceptions_NotImplementedException.__super__ = haxe_exceptions_PosException;
Object.assign(haxe_exceptions_NotImplementedException.prototype, {
	__class__: haxe_exceptions_NotImplementedException
});
class haxe_http_HttpBase {
	constructor(url) {
		if(haxe_http_HttpBase._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(url);
	}
	_hx_constructor(url) {
		this.url = url;
		this.headers = [];
		this.params = [];
		this.emptyOnData = $bind(this,this.onData);
	}
	onData(data) {
	}
	onBytes(data) {
	}
	onError(msg) {
	}
	onStatus(status) {
	}
	hasOnData() {
		return $bind(this,this.onData) != this.emptyOnData;
	}
	success(data) {
		this.responseBytes = data;
		this.responseAsString = null;
		if(this.hasOnData()) {
			this.onData(this.get_responseData());
		}
		this.onBytes(this.responseBytes);
	}
	get_responseData() {
		if(this.responseAsString == null && this.responseBytes != null) {
			this.responseAsString = this.responseBytes.getString(0,this.responseBytes.length,haxe_io_Encoding.UTF8);
		}
		return this.responseAsString;
	}
}
haxe_http_HttpBase.__name__ = true;
Object.assign(haxe_http_HttpBase.prototype, {
	__class__: haxe_http_HttpBase
});
class haxe_http_HttpJs extends haxe_http_HttpBase {
	constructor(url) {
		haxe_http_HttpBase._hx_skip_constructor = true;
		super();
		haxe_http_HttpBase._hx_skip_constructor = false;
		this._hx_constructor(url);
	}
	_hx_constructor(url) {
		this.async = true;
		this.withCredentials = false;
		super._hx_constructor(url);
	}
	request(post) {
		this.responseAsString = null;
		this.responseBytes = null;
		this.responseHeaders = null;
		let r = this.req = js_Browser.createXMLHttpRequest();
		let _gthis = this;
		let onreadystatechange = function(_) {
			if(r.readyState != 4) {
				return;
			}
			let s;
			try {
				s = r.status;
			} catch( _g ) {
				s = null;
			}
			if(s == 0 && js_Browser.get_supported() && $global.location != null) {
				let protocol = $global.location.protocol.toLowerCase();
				if(new EReg("^(?:about|app|app-storage|.+-extension|file|res|widget):$","").match(protocol)) {
					s = r.response != null ? 200 : 404;
				}
			}
			if(s == undefined) {
				s = null;
			}
			if(s != null) {
				_gthis.onStatus(s);
			}
			if(s != null && s >= 200 && s < 400) {
				_gthis.req = null;
				let headers = r.getAllResponseHeaders().split("\r\n");
				let _g = [];
				let _g1 = 0;
				let _g2 = headers;
				while(_g1 < _g2.length) {
					let v = _g2[_g1];
					++_g1;
					if(v != "") {
						_g.push(v);
					}
				}
				headers = _g;
				_gthis.responseHeaders = new haxe_ds_StringMap();
				let _g3 = 0;
				while(_g3 < headers.length) {
					let a = headers[_g3++].split(": ");
					let hname = a.shift();
					let hval = a.length == 1 ? a[0] : a.join(": ");
					hval = StringTools.ltrim(StringTools.rtrim(hval));
					_gthis.responseHeaders.h[hname] = hval;
				}
				_gthis.success(haxe_io_Bytes.ofData(r.response));
			} else if(s == null || s == 0 && r.response == null) {
				_gthis.req = null;
				_gthis.onError("Failed to connect or resolve host");
			} else if(s == null) {
				_gthis.req = null;
				let onreadystatechange = r.response != null ? haxe_io_Bytes.ofData(r.response) : null;
				_gthis.responseBytes = onreadystatechange;
				_gthis.onError("Http Error #" + r.status);
			} else {
				switch(s) {
				case 12007:
					_gthis.req = null;
					_gthis.onError("Unknown host");
					break;
				case 12029:
					_gthis.req = null;
					_gthis.onError("Failed to connect to host");
					break;
				default:
					_gthis.req = null;
					let onreadystatechange = r.response != null ? haxe_io_Bytes.ofData(r.response) : null;
					_gthis.responseBytes = onreadystatechange;
					_gthis.onError("Http Error #" + r.status);
				}
			}
		};
		if(this.async) {
			r.onreadystatechange = onreadystatechange;
		}
		let _g = this.postData;
		let _g1 = this.postBytes;
		let uri = _g == null ? _g1 == null ? null : new Blob([_g1.b.bufferValue]) : _g1 == null ? _g : null;
		if(uri != null) {
			post = true;
		} else {
			let _g = 0;
			let _g1 = this.params;
			while(_g < _g1.length) {
				let p = _g1[_g];
				++_g;
				if(uri == null) {
					uri = "";
				} else {
					uri = (uri == null ? "null" : Std.string(uri)) + "&";
				}
				let s = p.name;
				let uri1 = (uri == null ? "null" : Std.string(uri)) + encodeURIComponent(s) + "=";
				let s1 = p.value;
				uri = uri1 + encodeURIComponent(s1);
			}
		}
		try {
			if(post) {
				r.open("POST",this.url,this.async);
			} else if(uri != null) {
				r.open("GET",this.url + (this.url.split("?").length <= 1 ? "?" : "&") + (uri == null ? "null" : Std.string(uri)),this.async);
				uri = null;
			} else {
				r.open("GET",this.url,this.async);
			}
			r.responseType = "arraybuffer";
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			this.req = null;
			this.onError(_g1.toString());
			return;
		}
		r.withCredentials = this.withCredentials;
		if(!Lambda.exists(this.headers,function(h) {
			return h.name == "Content-Type";
		}) && post && this.postData == null) {
			r.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
		}
		let _g2 = 0;
		let _g3 = this.headers;
		while(_g2 < _g3.length) {
			let h = _g3[_g2];
			++_g2;
			r.setRequestHeader(h.name,h.value);
		}
		r.send(uri);
		if(!this.async) {
			onreadystatechange(null);
		}
	}
	static requestUrl(url) {
		let h = new haxe_http_HttpJs(url);
		h.async = false;
		let r = null;
		h.onData = function(d) {
			r = d;
		};
		h.onError = function(e) {
			throw haxe_Exception.thrown(e);
		};
		h.request(false);
		return r;
	}
}
haxe_http_HttpJs.__name__ = true;
haxe_http_HttpJs.__super__ = haxe_http_HttpBase;
Object.assign(haxe_http_HttpJs.prototype, {
	__class__: haxe_http_HttpJs
});
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
	blit(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	getString(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		let s = "";
		let b = this.b;
		let i = pos;
		let max = pos + len;
		switch(encoding[1]) {
		case 0:
			while(i < max) {
				let c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					let code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					let code = (c & 31) << 12 | (b[i++] & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else {
					let u = (c & 15) << 18 | (b[i++] & 127) << 12 | (b[i++] & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				let c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	static ofData(b) {
		let hb = b.hxBytes;
		if(hb != null) {
			return hb;
		}
		return new haxe_io_Bytes(b);
	}
}
haxe_io_Bytes.__name__ = true;
Object.assign(haxe_io_Bytes.prototype, {
	__class__: haxe_io_Bytes
});
var haxe_io_Encoding = { __ename__:true,__constructs__:["UTF8","RawNative"] };
haxe_io_Encoding.UTF8 = ["UTF8",0];
haxe_io_Encoding.UTF8.toString = $estr;
haxe_io_Encoding.UTF8.__enum__ = haxe_io_Encoding;
haxe_io_Encoding.RawNative = ["RawNative",1];
haxe_io_Encoding.RawNative.toString = $estr;
haxe_io_Encoding.RawNative.__enum__ = haxe_io_Encoding;
var haxe_io_Error = { __ename__:true,__constructs__:["Blocked","Overflow","OutsideBounds","Custom"] };
haxe_io_Error.Blocked = ["Blocked",0];
haxe_io_Error.Blocked.toString = $estr;
haxe_io_Error.Blocked.__enum__ = haxe_io_Error;
haxe_io_Error.Overflow = ["Overflow",1];
haxe_io_Error.Overflow.toString = $estr;
haxe_io_Error.Overflow.__enum__ = haxe_io_Error;
haxe_io_Error.OutsideBounds = ["OutsideBounds",2];
haxe_io_Error.OutsideBounds.toString = $estr;
haxe_io_Error.OutsideBounds.__enum__ = haxe_io_Error;
haxe_io_Error.Custom = function(e) { var $x = ["Custom",3,e]; $x.__enum__ = haxe_io_Error; $x.toString = $estr; return $x; }
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
Object.assign(haxe_iterators_ArrayIterator.prototype, {
	__class__: haxe_iterators_ArrayIterator
});
class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array) && o.__enum__ == null) {
			return Array;
		} else {
			let cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			let name = js_Boot.__nativeClassName(o);
			if(name != null) {
				return js_Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(((o) instanceof Array)) {
				if(o.__enum__) {
					if(o.length == 2) {
						return o[0];
					}
					let str = o[0] + "(";
					s = s + "\t";
					let _g = 2;
					let _g1 = o.length;
					while(true) {
						if(!(_g < _g1)) {
							break;
						}
						let i = (function($this) {
							var $r;
							_g = _g + 1;
							$r = _g - 1;
							return $r;
						}(this));
						if(i != 2) {
							str = str + ("," + js_Boot.__string_rec(o[i],s));
						} else {
							str = str + js_Boot.__string_rec(o[i],s);
						}
					}
					return str + ")";
				}
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
	static __interfLoop(cc,cl) {
		while(true) {
			if(cc == null) {
				return false;
			}
			if(cc == cl) {
				return true;
			}
			let intf = cc.__interfaces__;
			if(intf != null && (cc.__super__ == null || cc.__super__.__interfaces__ != intf)) {
				let _g = 0;
				let _g1 = intf.length;
				while(_g < _g1) {
					let i = intf[_g++];
					if(i == cl || js_Boot.__interfLoop(i,cl)) {
						return true;
					}
				}
			}
			cc = cc.__super__;
		}
	}
	static __instanceof(o,cl) {
		if(cl == null) {
			return false;
		}
		switch(cl) {
		case Array:
			if(((o) instanceof Array)) {
				return o.__enum__ == null;
			} else {
				return false;
			}
			break;
		case Bool:
			return typeof(o) == "boolean";
		case Dynamic:
			return o != null;
		case Float:
			return typeof(o) == "number";
		case Int:
			if(typeof(o) == "number") {
				return ((o | 0) === o);
			} else {
				return false;
			}
			break;
		case String:
			return typeof(o) == "string";
		default:
			if(o != null) {
				if(typeof(cl) == "function") {
					if(js_Boot.__downcastCheck(o,cl)) {
						return true;
					}
				} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
					if(((o) instanceof cl)) {
						return true;
					}
				}
			} else {
				return false;
			}
			if(cl == Class ? o.__name__ != null : false) {
				return true;
			}
			if(cl == Enum ? o.__ename__ != null : false) {
				return true;
			}
			return o.__enum__ == cl;
		}
	}
	static __downcastCheck(o,cl) {
		if(!((o) instanceof cl)) {
			if(cl.__isInterface__) {
				return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static __implements(o,iface) {
		return js_Boot.__interfLoop(js_Boot.getClass(o),iface);
	}
	static __cast(o,t) {
		if(o == null || js_Boot.__instanceof(o,t)) {
			return o;
		} else {
			throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
		}
	}
	static __nativeClassName(o) {
		let name = js_Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __isNativeObj(o) {
		return js_Boot.__nativeClassName(o) != null;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
js_Boot.__name__ = true;
class js_Browser {
	static get_supported() {
		if(typeof(window) != "undefined" && typeof(window.location) != "undefined") {
			return typeof(window.location.protocol) == "string";
		} else {
			return false;
		}
	}
	static createXMLHttpRequest() {
		if(typeof XMLHttpRequest != "undefined") {
			return new XMLHttpRequest();
		}
		if(typeof ActiveXObject != "undefined") {
			return new ActiveXObject("Microsoft.XMLHTTP");
		}
		throw haxe_Exception.thrown("Unable to create XMLHttpRequest object.");
	}
}
js_Browser.__name__ = true;
Math.__name__ = true;
class runtime_actions_datatypes_ValueActions {
	constructor() {
	}
	make(proto,spec) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	reflect(value,field) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	to(proto,spec) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	form(value,buffer,arg,part) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	compare(value1,value2,op) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	doMath(left,right,op) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	absolute(value) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	add(value1,value2) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	divide(value1,value2) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	multiply(value1,value2) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	negate(value) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	power(number,exponent) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	remainder(value1,value2) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	round(value,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	subtract(value1,value2) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	even_q(value) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	odd_q(value) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	and(value1,value2) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	complement(value) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	or(value1,value2) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	xor(value1,value2) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	append(series,value,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	at(series,index) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	back(series) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	change(series,value,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	clear(series) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	copy(value,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	find(series,value,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	head(series) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	head_q(series) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	index_q(series) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	insert(series,value,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	length_q(series) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	move(origin,target,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	next(series) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	pick(series,index) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	poke(series,index,value) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	put(series,key,value,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	remove(series,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	reverse(series,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	select(series,value,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	sort(series,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	skip(series,offset) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	swap(series1,series2) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	tail(series) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	tail_q(series) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	take(series,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	trim(series,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
}
runtime_actions_datatypes_ValueActions.__name__ = true;
Object.assign(runtime_actions_datatypes_ValueActions.prototype, {
	__class__: runtime_actions_datatypes_ValueActions
});
class runtime_actions_datatypes_DatatypeActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	form(value,buffer,_,part) {
		buffer.appendLiteralPart(value.name,value.name.length - 1);
		return part - value.name.length - 1;
	}
	mold(value,buffer,_,isAll,_1,_2,part,_3) {
		buffer.appendLiteral(value.name);
		return part - value.name.length;
	}
	compare(value1,value2,op) {
		switch(op) {
		case 0:case 1:case 2:case 9:case 11:
			if(((value2) instanceof types_Datatype) == true) {
				let __anon0__other = value2;
				let other = __anon0__other;
				if(value1.kind == other.kind) {
					return 0;
				} else {
					return 1;
				}
			} else {
				return 1;
			}
			break;
		default:
			return -2;
		}
	}
}
runtime_actions_datatypes_DatatypeActions.__name__ = true;
runtime_actions_datatypes_DatatypeActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_DatatypeActions.prototype, {
	__class__: runtime_actions_datatypes_DatatypeActions
});
class runtime_actions_datatypes_UnsetActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	make(_,_1) {
		return types_Unset.UNSET;
	}
	to(_,_1) {
		return types_Unset.UNSET;
	}
	form(_,_1,_2,part) {
		return part;
	}
	mold(_,buffer,_1,_2,_3,_4,part,_5) {
		buffer.appendLiteral("unset");
		return part - 5;
	}
	compare(value1,value2,op) {
		if(((value2) instanceof types_Unset)) {
			switch(op) {
			case 0:case 1:case 2:case 7:case 8:case 9:case 11:
				return 0;
			default:
				return -2;
			}
		} else {
			return -2;
		}
	}
}
runtime_actions_datatypes_UnsetActions.__name__ = true;
runtime_actions_datatypes_UnsetActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_UnsetActions.prototype, {
	__class__: runtime_actions_datatypes_UnsetActions
});
class runtime_actions_datatypes_NoneActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	make(_,_1) {
		return types_None.NONE;
	}
	to(_,_1) {
		return types_None.NONE;
	}
	form(_,buffer,_1,part) {
		buffer.appendLiteral("none");
		return part - 4;
	}
	mold(_,buffer,_1,isAll,_2,_3,part,_4) {
		if(isAll) {
			buffer.appendLiteral("#(none)");
			return part - 7;
		} else {
			return this.form(null,buffer,null,part);
		}
	}
	compare(value1,value2,op) {
		if(((value2) instanceof types_None)) {
			switch(op) {
			case 0:case 1:case 2:case 7:case 8:case 9:case 11:
				return 0;
			default:
				return -2;
			}
		} else {
			return -2;
		}
	}
	clear(none) {
		return none;
	}
}
runtime_actions_datatypes_NoneActions.__name__ = true;
runtime_actions_datatypes_NoneActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_NoneActions.prototype, {
	__class__: runtime_actions_datatypes_NoneActions
});
class runtime_actions_datatypes_LogicActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	make(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		if(((spec) instanceof types_Integer) == true) {
			let __anon0__int = spec;
			let int = __anon0__int;
			if(int.int) {
				return types_Logic.TRUE;
			} else {
				return types_Logic.FALSE;
			}
		} else {
			_hx_tmp1 = ((spec) instanceof types_Float);
			if(_hx_tmp1 == true) {
				let __anon0__float = spec;
				let float = __anon0__float;
				if(float.float) {
					return types_Logic.TRUE;
				} else {
					return types_Logic.FALSE;
				}
			} else {
				_hx_tmp = ((spec) instanceof types_Percent);
				if(_hx_tmp == true) {
					let __anon0__float = spec;
					let float = __anon0__float;
					if(float.float) {
						return types_Logic.TRUE;
					} else {
						return types_Logic.FALSE;
					}
				} else {
					return this.to(proto,spec);
				}
			}
		}
	}
	to(proto,spec) {
		let _hx_tmp;
		if(((spec) instanceof types_Logic) == true) {
			let __anon0__logic = spec;
			let logic = __anon0__logic;
			return logic;
		} else {
			_hx_tmp = ((spec) instanceof types_None);
			if(_hx_tmp == true) {
				return types_Logic.FALSE;
			} else {
				return types_Logic.TRUE;
			}
		}
	}
	form(value,buffer,_,part) {
		let str = value.cond ? "true" : "false";
		buffer.appendLiteral(str);
		return part - str.length;
	}
	mold(value,buffer,_,isAll,_1,_2,part,_3) {
		if(isAll) {
			let str = value.cond ? "#(true)" : "#(false)";
			buffer.appendLiteral(str);
			return part - str.length;
		} else {
			return this.form(value,buffer,null,part);
		}
	}
	compare(value1,value2,op) {
		if(((value2) instanceof types_Logic) == true) {
			let __anon0__logic2 = value2;
			let logic2 = __anon0__logic2;
			switch(op) {
			case 0:case 1:case 2:case 7:case 8:case 9:case 11:
				return +(value1.cond) - +(logic2.cond);
			default:
				return -2;
			}
		} else {
			return -2;
		}
	}
	complement(value) {
		if(!value.cond) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
	and(value1,value2) {
		if(((value2) instanceof types_Logic) == true) {
			let __anon0__logic2 = value2;
			let logic2 = __anon0__logic2;
			if(value1.cond && logic2.cond) {
				return types_Logic.TRUE;
			} else {
				return types_Logic.FALSE;
			}
		} else {
			throw haxe_Exception.thrown("bad");
		}
	}
	or(value1,value2) {
		if(((value2) instanceof types_Logic) == true) {
			let __anon0__logic2 = value2;
			let logic2 = __anon0__logic2;
			if(value1.cond || logic2.cond) {
				return types_Logic.TRUE;
			} else {
				return types_Logic.FALSE;
			}
		} else {
			throw haxe_Exception.thrown("bad");
		}
	}
	xor(value1,value2) {
		if(((value2) instanceof types_Logic) == true) {
			let __anon0__logic2 = value2;
			let logic2 = __anon0__logic2;
			if(value1.cond != logic2.cond) {
				return types_Logic.TRUE;
			} else {
				return types_Logic.FALSE;
			}
		} else {
			throw haxe_Exception.thrown("bad");
		}
	}
}
runtime_actions_datatypes_LogicActions.__name__ = true;
runtime_actions_datatypes_LogicActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_LogicActions.prototype, {
	__class__: runtime_actions_datatypes_LogicActions
});
class runtime_actions_datatypes_SeriesActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	at(series,index) {
		let i;
		let _hx_tmp;
		if(((index) instanceof types_Integer) == true) {
			let __anon0__int = index;
			let int = __anon0__int;
			i = int.int;
		} else {
			_hx_tmp = ((index) instanceof types_Pair);
			if(_hx_tmp == true) {
				let __anon0__pair = index;
				let pair = __anon0__pair;
				i = pair.x;
			} else {
				throw haxe_Exception.thrown("bad");
			}
		}
		return series.at(i);
	}
	back(series) {
		return series.skip(-1);
	}
	change(series,value,options) {
		let cnt;
		let tmp = options.dup;
		let _g = tmp != null ? tmp.count : null;
		let _hx_tmp;
		if(_g == null) {
			cnt = 1;
		} else {
			_hx_tmp = _g;
			let count = _hx_tmp;
			let int = count.asInt();
			if(int < 1) {
				return series;
			}
			cnt = int;
		}
		let isNeg = false;
		let isSelf = false;
		let s = series.values;
		let head = series.index;
		let size = series.values.length - series.index;
		let isBlk = ((series) instanceof types_base__$BlockLike);
		let series2 = value;
		let isValues;
		if(options.only && isBlk) {
			isValues = false;
		} else {
			isSelf = value.constructor == series.constructor && series.values == series2.values;
			isValues = isSelf;
		}
		let cell;
		let cellIdx;
		let items;
		if(isSelf || isValues) {
			let s2 = series2.values;
			cell = s2;
			cellIdx = series2.index;
			items = series2.values.length - series2.index;
		} else {
			cell = value;
			cellIdx = 0;
			items = 1;
		}
		let limit = cellIdx + items;
		let part = items;
		let hasPart = options.part != null;
		let tmp1 = options.part;
		let _g1 = tmp1 != null ? tmp1.range : null;
		let _hx_tmp1;
		if(_g1 == null) {
			size -= head;
		} else {
			_hx_tmp1 = _g1;
			let range = _hx_tmp1;
			let _hx_tmp;
			if(((range) instanceof types_Integer) == true) {
				let __anon0__int = range;
				let int = __anon0__int;
				part = int.int;
			} else {
				_hx_tmp = ((range) instanceof types_base__$SeriesOf);
				if(_hx_tmp == true) {
					let __anon0__ser2 = range;
					let ser2 = __anon0__ser2;
					if(!(ser2.constructor == series.constructor && ser2.values == series.values)) {
						throw haxe_Exception.thrown("bad");
					}
					part = ser2.index - head;
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
			if(part < 0) {
				part = -part;
				if(part > head) {
					part = head;
					head = 0;
				} else {
					head -= part;
				}
				series.index = head;
				isNeg = true;
			}
			size -= head;
			if(part > size) {
				part = size;
			}
		}
		let allAdded = 0;
		if(isBlk || isSelf) {
			let n = hasPart ? part : items * cnt;
			if(n > size) {
				n = size;
			}
			let added = hasPart ? items - part : items - size;
			n = series.values.length - series.index + added;
			if(n > series.values.length) {
				let _g = 0;
				let _g1 = n - series.values.length;
				while(_g < _g1) {
					let _ = _g++;
					s.splice(head,0,null);
				}
			}
			if(hasPart) {
				size -= part;
				s.splice(head,part);
			}
			let _hx_tmp;
			let _hx_tmp1;
			if((((cell) instanceof Array) && cell.__enum__ == null) == true) {
				let __anon0__s2 = cell;
				let s2 = __anon0__s2;
				if(hasPart) {
					let _g = 0;
					let _g1 = s2.length;
					while(_g < _g1) {
						let _ = _g++;
						s.splice(head,0,null);
					}
				}
				let _g = 0;
				allAdded = s2.length;
				let _g1 = allAdded;
				while(_g < _g1) {
					let i = _g++;
					s[head + i] = s2[cellIdx + i];
				}
			} else {
				_hx_tmp1 = ((cell) instanceof types_base__$BlockLike);
				if(_hx_tmp1 == true) {
					let __anon0__blk = cell;
					let blk = __anon0__blk;
					if(hasPart) {
						let _g = 0;
						let _g1 = blk.values.length - blk.index;
						while(_g < _g1) {
							let _ = _g++;
							s.splice(head,0,null);
						}
					}
					let _g = blk.index;
					allAdded = blk.values.length - blk.index;
					let _g1 = allAdded;
					while(_g < _g1) {
						let i = _g++;
						s[head + i] = blk.values[blk.index + i];
					}
				} else {
					_hx_tmp = ((cell) instanceof Value);
					if(_hx_tmp == true) {
						let __anon0__val = cell;
						let val = __anon0__val;
						if(hasPart) {
							let _g = 0;
							let _g1 = part;
							while(_g < _g1) {
								let _ = _g++;
								s.splice(head,0,null);
							}
						}
						allAdded = head + items;
						s.fill(val,head,allAdded);
					} else {
						throw haxe_Exception.thrown("bad");
					}
				}
			}
			if(hasPart) {
				while(s.includes(null)) s.remove(null);
			}
		} else {
			if(hasPart) {
				size -= part;
				s.splice(head,part);
			}
			let a = { ref : 0};
			if(((series) instanceof types_base__$String) == true) {
				let __anon0__str = series;
				let str = __anon0__str;
				items = runtime_actions_datatypes_StringActions.changeRange(str,cell,cellIdx,a,limit,hasPart);
			} else {
				throw haxe_Exception.thrown("bad");
			}
			allAdded = a.ref;
		}
		if(cnt > 1) {
			let src = series.index;
			let tail = series.values.length;
			let added = items;
			let n = added * cnt;
			if(hasPart) {
				n -= added;
			} else {
				n = src + n - tail;
			}
			size = tail - series.index + n;
			src += added;
			let orig = s.slice(head,head + allAdded);
			if(hasPart) {
				let _g = 0;
				let _g1 = (cnt - 1) * allAdded;
				while(_g < _g1) {
					let _ = _g++;
					s.splice(head + allAdded,0,null);
				}
			}
			let _g = 1;
			let _g1 = cnt;
			while(_g < _g1) {
				let c = _g++;
				let _g1 = 0;
				let _g2 = orig.length;
				while(_g1 < _g2) {
					let i = _g1++;
					s[head + allAdded * c + i] = orig[i];
				}
			}
		}
		series.index += items;
		return series;
	}
	clear(series) {
		series.values.splice(series.index,series.values.length - series.index);
		return series;
	}
	copy(series,options) {
		let s = series.values;
		let offset = series.index;
		let len = series.values.length;
		let part = Math.max((len - offset), 0);
		if(options.types != null) {
			throw haxe_Exception.thrown("NYI");
		}
		let tmp = options.part;
		if(tmp != null) {
			let _g = tmp.length;
			let _hx_tmp;
			if(_g != null) {
				_hx_tmp = _g;
				let p = _hx_tmp;
				let _hx_tmp1;
				let _hx_tmp2;
				if(((p) instanceof types_Integer) == true) {
					let __anon0__i = p;
					let i = __anon0__i;
					part = i.int;
				} else {
					_hx_tmp2 = ((p) instanceof types_Pair) ? p : null;
					if(_hx_tmp2 == null) {
						_hx_tmp1 = ((p) instanceof types_base__$SeriesOf);
						if(_hx_tmp1 == true) {
							let __anon0__s = p;
							let s = __anon0__s;
							if(series.values != s.values) {
								throw new runtime_actions_InvalidAction("Invalid action!");
							}
							part = s.index - series.index;
						} else {
							throw new runtime_actions_InvalidAction("Invalid action!");
						}
					} else {
						let _g = _hx_tmp2.get_TYPE_KIND();
						let x = _hx_tmp2.x;
						let y = _hx_tmp2.y;
						offset += x - 1;
						if(x < 0) {
							++offset;
						}
						if(offset < 0) {
							offset = 0;
						}
						part = y < x ? 0 : y - x;
					}
				}
				if(part < 0) {
					part *= -1;
					offset -= part;
					if(offset < 0) {
						offset = 0;
						part = series.index;
					}
				}
			}
		}
		if(offset > len) {
			part = 0;
			offset = len;
		}
		if(offset + part > len) {
			part = len - offset;
		}
		return series.clone(s.slice(offset,offset + part));
	}
	head(series) {
		return series.head();
	}
	head_q(series) {
		if(series.isHead()) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
	index_q(series) {
		return new types_Integer(series.index);
	}
	length_q(series) {
		return new types_Integer(series.values.length - series.index);
	}
	move(origin,target,options) {
		let tail = origin.values.length;
		let part = 1;
		let items = 1;
		if(origin.index == tail) {
			return target;
		}
		let tmp = options.part;
		if(tmp != null) {
			let _g = tmp.length;
			let _hx_tmp;
			if(_g != null) {
				_hx_tmp = _g;
				let length = _hx_tmp;
				part = length.int;
				if(part <= 0) {
					return target;
				}
				let limit = origin.values.length - origin.index;
				if(part > limit) {
					part = limit;
				}
				items = part;
			}
		}
		if(origin.constructor == target.constructor) {
			let src = origin.values;
			let srcIdx = origin.index;
			let tgt = target;
			let dst = tgt.values;
			let dstIdx = tgt.index;
			if(src == dst) {
				return target;
			}
			if(dstIdx > srcIdx && dstIdx != tail && part > tail - srcIdx) {
				return origin;
			}
			if(dstIdx > tail) {
				dstIdx = tail;
			}
			let this1 = src.splice(srcIdx,part);
			dst.splice(dstIdx,0,...this1);
		} else {
			if(((origin) instanceof types_base__$BlockLike) && ((target) instanceof types_base__$String) || ((origin) instanceof types_base__$String) && ((target) instanceof types_base__$BlockLike)) {
				throw haxe_Exception.thrown("bad");
			}
			let _hx_tmp;
			if(((target) instanceof types_base__$BlockLike) == true) {
				let __anon0__tgt = target;
				let tgt = __anon0__tgt;
				let src = origin.values;
				let srcIdx = origin.index;
				let dst = tgt.values;
				let dstIdx = tgt.index;
				if(src == dst) {
					return target;
				}
				if(dstIdx > tail) {
					dstIdx = tail;
				}
				let this1 = src.splice(srcIdx,part);
				dst.splice(dstIdx,0,...this1);
			} else {
				_hx_tmp = ((target) instanceof types_base__$String);
				if(_hx_tmp == true) {
					let __anon0__tgt = target;
					let tgt = __anon0__tgt;
					let src = origin.values;
					let srcIdx = origin.index;
					let dst = tgt.values;
					let dstIdx = tgt.index;
					if(src == dst) {
						return target;
					}
					if(dstIdx > tail) {
						dstIdx = tail;
					}
					let this1 = src.splice(srcIdx,part);
					dst.splice(dstIdx,0,...this1);
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
		}
		return origin;
	}
	next(series) {
		return series.skip(1);
	}
	pick(series,index) {
		let _hx_tmp = ((index) instanceof types_Integer) ? index : null;
		if(_hx_tmp == null) {
			throw new runtime_actions_InvalidAction("Invalid action!");
		} else {
			let _g = _hx_tmp.get_TYPE_KIND();
			let idx = _hx_tmp.int;
			--idx;
			let _hx_tmp1;
			let _hx_tmp2;
			if(((series) instanceof types_base__$BlockLike) == true) {
				let __anon0__b = series;
				let b = __anon0__b;
				let tmp = b.pick(idx);
				if(tmp != null) {
					return tmp;
				} else {
					return types_None.NONE;
				}
			} else {
				_hx_tmp2 = ((series) instanceof types_Binary);
				if(_hx_tmp2 == true) {
					let __anon0__b = series;
					let b = __anon0__b;
					let tmp = b.pick(idx);
					if(tmp != null) {
						return tmp;
					} else {
						return types_None.NONE;
					}
				} else {
					_hx_tmp1 = ((series) instanceof types_base__$String);
					if(_hx_tmp1 == true) {
						let __anon0__s = series;
						let s = __anon0__s;
						let tmp = s.pick(idx);
						if(tmp != null) {
							return tmp;
						} else {
							return types_None.NONE;
						}
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
			}
		}
	}
	poke(series,index,value) {
		let _hx_tmp = ((index) instanceof types_Integer) ? index : null;
		if(_hx_tmp == null) {
			throw new runtime_actions_InvalidAction("Invalid action!");
		} else {
			let _g = _hx_tmp.get_TYPE_KIND();
			let idx = _hx_tmp.int;
			--idx;
			let tmp;
			let _hx_tmp1;
			let _hx_tmp2;
			if(((series) instanceof types_base__$BlockLike) == true) {
				let __anon0__b = series;
				let b = __anon0__b;
				tmp = b.rawPoke(idx,value);
			} else {
				_hx_tmp2 = ((series) instanceof types_Binary);
				if(_hx_tmp2 == true) {
					let __anon0__b = series;
					let b = __anon0__b;
					if(((value) instanceof types_base__$Integer) == true) {
						let __anon0__i = value;
						let i = __anon0__i;
						tmp = b.rawPoke(idx,i.int);
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				} else {
					_hx_tmp1 = ((series) instanceof types_base__$String);
					if(_hx_tmp1 == true) {
						let __anon0__s = series;
						let s = __anon0__s;
						if(((value) instanceof types_Char) == true) {
							let __anon0__c = value;
							let c = __anon0__c;
							tmp = s.rawPoke(idx,c.int);
						} else {
							throw new runtime_actions_InvalidAction("Invalid action!");
						}
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
			}
			if(tmp == null) {
				throw haxe_Exception.thrown("out of range");
			}
		}
		return value;
	}
	skip(series,offset) {
		let i;
		let _hx_tmp;
		if(((offset) instanceof types_Integer) == true) {
			let __anon0__int = offset;
			let int = __anon0__int;
			i = int.int;
		} else {
			_hx_tmp = ((offset) instanceof types_Pair);
			if(_hx_tmp == true) {
				let __anon0__pair = offset;
				let pair = __anon0__pair;
				i = pair.x;
			} else {
				throw haxe_Exception.thrown("bad");
			}
		}
		return series.skip(i);
	}
	remove(series,options) {
		let part = 1;
		let items = 1;
		let tmp = options.part;
		if(tmp != null) {
			let _g = tmp.length;
			let _hx_tmp;
			if(_g != null) {
				_hx_tmp = _g;
				let len = _hx_tmp;
				let _hx_tmp1;
				if(((len) instanceof types_Integer) == true) {
					let __anon0__i = len;
					let i = __anon0__i;
					part = i.int;
				} else {
					_hx_tmp1 = ((len) instanceof types_base__$SeriesOf);
					if(_hx_tmp1 == true) {
						let __anon0__series2 = len;
						let series2 = __anon0__series2;
						if(!(series2.constructor == series.constructor && series2.values == series.values)) {
							throw haxe_Exception.thrown("bad");
						}
						part = series2.index - series.index;
					} else {
						throw haxe_Exception.thrown("bad");
					}
				}
				if(part <= 0) {
					return series;
				}
				items = part;
			}
		}
		let tmp1 = options.key;
		if(tmp1 != null) {
			let _g = tmp1.keyArg;
			let _hx_tmp;
			if(_g != null) {
				_hx_tmp = _g;
				let key = _hx_tmp;
				let ser = this.find(series,key,{...runtime_actions_Find.defaultOptions, _case: true});
				if(ser == types_None.NONE) {
					return ser;
				}
				++items;
				++part;
				series = ser;
			}
		}
		series.values.splice(series.index,items);
		return series;
	}
	reverse(series,options) {
		if(series.index == 0 && options.part == null && options.skip == null) {
			series.values.reverse();
			return series;
		}
		let part = 0;
		let tmp = options.part;
		let _g = tmp != null ? tmp.length : null;
		let _hx_tmp;
		if(_g != null) {
			_hx_tmp = _g;
			let len = _hx_tmp;
			let _hx_tmp1;
			if(((len) instanceof types_Integer) == true) {
				let __anon0__i = len;
				let i = __anon0__i;
				part = i.int;
			} else {
				_hx_tmp1 = ((len) instanceof types_base__$SeriesOf);
				if(_hx_tmp1 == true) {
					let __anon0__series2 = len;
					let series2 = __anon0__series2;
					if(!(series2.constructor == series.constructor && series2.values == series.values)) {
						throw haxe_Exception.thrown("bad");
					}
					part = series2.index - series.index;
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
			if(part <= 0) {
				return series;
			}
		}
		let s = series.values;
		let last = series.values.length - 1;
		let minIndex = series.index;
		let maxIndex = part == 0 ? last : Math.min((part - 1), last);
		if(minIndex > maxIndex) {
			return series;
		}
		let length = maxIndex - minIndex;
		let half = Math.max(Math.floor(length / 2), 1);
		let tmp1 = options.skip;
		let _g1 = tmp1 != null ? tmp1.size : null;
		let _hx_tmp1;
		if(_g1 == null) {
			let _g = 0;
			let _g1 = half;
			while(_g < _g1) {
				let i = _g++;
				let idx1 = minIndex + i;
				let idx2 = maxIndex - i;
				[s[idx1], s[idx2]] = [s[idx2], s[idx1]];
			}
		} else {
			_hx_tmp1 = _g1;
			let size = _hx_tmp1;
			let skip = size.int;
			if(skip == series.values.length - series.index) {
				return series;
			}
			if(skip <= 0) {
				throw haxe_Exception.thrown("bad");
			}
			if(skip > maxIndex || (maxIndex - 1) % skip != 0) {
				throw haxe_Exception.thrown("bad");
			}
			let _g = 0;
			let _g2 = half;
			while(_g < _g2) {
				let i = _g++;
				let _g1 = 0;
				let _g2 = skip;
				while(_g1 < _g2) {
					let j = _g1++;
					let idx1 = minIndex + i + j;
					let idx2 = maxIndex - i - skip + j + 1;
					[s[idx1], s[idx2]] = [s[idx2], s[idx1]];
				}
			}
		}
		return series;
	}
	swap(series1,series2) {
		if(series1.values.length - series1.index == 0) {
			return series1;
		}
		if(((series2) instanceof types_base__$String) == true) {
			let __anon0__s2 = series2;
			let s2 = __anon0__s2;
			if(s2.values.length - s2.index == 0) {
				return series1;
			}
			let s1 = series1;
			[s1.values[s1.index], s2.values[s2.index]] = [s2.values[s2.index], s1.values[s1.index]];
			return series1;
		} else {
			throw haxe_Exception.thrown("bad");
		}
	}
	tail(series) {
		return series.tail();
	}
	tail_q(series) {
		if(series.isTail()) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
	take(series,options) {
		let size = series.values.length - series.index;
		if(size <= 0) {
			return types_None.NONE;
		}
		let part = 1;
		let part2 = 1;
		let ser2 = null;
		let hasPart;
		let tmp = options.part;
		let _g = tmp != null ? tmp.length : null;
		let _hx_tmp;
		if(_g == null) {
			hasPart = false;
		} else {
			_hx_tmp = _g;
			let p = _hx_tmp;
			let _hx_tmp1;
			if(((p) instanceof types_Integer) == true) {
				let __anon0__i = p;
				let i = __anon0__i;
				part = i.int;
			} else {
				_hx_tmp1 = ((p) instanceof types_base__$SeriesOf);
				if(_hx_tmp1 == true) {
					let __anon0__s = p;
					let s = __anon0__s;
					if(series.values != s.values) {
						throw haxe_Exception.thrown("bad");
					}
					ser2 = s;
					part = ser2.index < series.index ? 0 : options.last ? size - (ser2.index - series.index) : ser2.index - series.index;
				} else {
					throw new runtime_actions_InvalidAction("Invalid action!");
				}
			}
			part2 = part;
			if(part < 0) {
				size = series.index;
				part = options.last ? 1 : -part;
			}
			hasPart = true;
		}
		if(!hasPart) {
			if(options.last) {
				return series.wrap(series.values.pop());
			} else if(series.index == 0) {
				return series.wrap(series.values.shift());
			} else {
				return series.wrap(series.values.splice(series.index,1)[0]);
			}
		}
		let offset = series.index;
		if(part2 > 0) {
			if(options.last) {
				offset = series.values.length - series.index - part;
			}
		} else {
			if(options.last || part > series.values.length) {
				return series.clone([]);
			}
			offset -= part;
		}
		return series.clone(series.values.splice(offset,part));
	}
}
runtime_actions_datatypes_SeriesActions.__name__ = true;
runtime_actions_datatypes_SeriesActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_SeriesActions.prototype, {
	__class__: runtime_actions_datatypes_SeriesActions
});
class runtime_actions_datatypes__$BlockLikeActions extends runtime_actions_datatypes_SeriesActions {
	constructor() {
		super();
	}
	compare(value1,value2,op) {
		if(((value2) instanceof types_base__$BlockLike) == true) {
			let __anon0__blk = value2;
			let blk = __anon0__blk;
			if(value1.constructor != blk.constructor) {
				if(!(op == 10 && (((value1) instanceof types_Path) && ((blk) instanceof types_LitPath) || ((value1) instanceof types_LitPath) && ((blk) instanceof types_Path)))) {
					return -2;
				}
			}
			return runtime_actions_datatypes__$BlockLikeActions_compareEach(value1,blk,op);
		} else {
			return -2;
		}
	}
	append(series,value,options) {
		return runtime_actions_datatypes__$BlockLikeActions._insert(series,value,options,true);
	}
	find(series,value,options) {
		let s = series.values;
		let beg = series.index;
		if(series.values.length == 0 || !options.reverse && beg >= series.values.length) {
			return types_None.NONE;
		}
		let step = 1;
		let isPart = false;
		let part = null;
		let tmp = options.skip;
		let _g = tmp != null ? tmp.size : null;
		let _hx_tmp;
		if(_g != null) {
			_hx_tmp = _g;
			let skip = _hx_tmp;
			step = skip.int;
			if(step <= 0) {
				throw haxe_Exception.thrown("error");
			}
		}
		let tmp1 = options.part;
		let _g1 = tmp1 != null ? tmp1.length : null;
		let _hx_tmp1;
		if(_g1 != null) {
			_hx_tmp1 = _g1;
			let length = _hx_tmp1;
			let _hx_tmp;
			if(((length) instanceof types_Integer) == true) {
				let __anon0__i = length;
				let i = __anon0__i;
				if(i.int <= 0) {
					return types_None.NONE;
				}
				part = beg + i.int - 1;
			} else {
				_hx_tmp = ((length) instanceof types_base__$BlockLike);
				if(_hx_tmp == true) {
					let __anon0__b = length;
					let b = __anon0__b;
					if(!(b.constructor == series.constructor && b.values == series.values)) {
						throw haxe_Exception.thrown("bad");
					}
					part = b.index;
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
			if(part >= series.values.length) {
				part = series.values.length - 1;
			}
			isPart = true;
		}
		let isDt = !options.only && ((value) instanceof types_Datatype);
		let isTs = !options.only && ((value) instanceof types_Typeset);
		let isAnyBlk = ((value) instanceof types_base__$BlockLike);
		let op = options._case ? 2 : 11;
		if(options.same) {
			op = 9;
			if(options.only) {
				isAnyBlk = false;
			}
		}
		if(options.match || isAnyBlk || !((series) instanceof types_Hash)) {
			let valuesOffset = null;
			let values = null;
			let valuesCount;
			if(options.only) {
				valuesCount = 0;
			} else if(isAnyBlk) {
				let b = value;
				valuesOffset = b.index;
				values = b;
				valuesCount = b.values.length - b.index;
			} else {
				valuesCount = 0;
			}
			if(valuesCount < 0) {
				valuesCount = 0;
			}
			let slot;
			let end;
			if(options.last) {
				step = -step;
				let tmp = part;
				slot = tmp != null ? tmp : valuesCount > 0 ? series.values.length - valuesCount : series.values.length - 1;
				end = 0;
			} else if(options.reverse) {
				step = -step;
				let tmp = part;
				slot = tmp != null ? tmp : valuesCount > 0 ? beg - valuesCount : beg - 1;
				end = 0;
				if(slot < end) {
					return types_None.NONE;
				}
			} else {
				slot = beg;
				end = isPart ? part + 1 : series.values.length;
			}
			let isReverse = options.reverse || options.last;
			let type = isDt ? value.kind : -1;
			let wasFound = false;
			do {
				if(valuesCount == 0) {
					let stype = s[slot].get_TYPE_KIND();
					wasFound = isDt ? stype == type : isTs ? value.types.has(types_Datatype.TYPES.get(stype)) : runtime_Actions.compare(s[slot],value,op).cond;
				} else {
					let n = 0;
					let slot2 = slot;
					do {
						wasFound = runtime_Actions.compare(s[slot2],values.values[valuesOffset],op).cond;
						++slot2;
						++n;
					} while(!(!wasFound || n == valuesOffset || isReverse && slot2 <= end || !isReverse && slot2 >= end));
					if(n <= valuesOffset && slot2 >= end) {
						wasFound = false;
					}
				}
				slot += step;
			} while(!(options.match || !options.match && wasFound || isReverse && slot < end || !isReverse && slot >= end));
			if(options.tail) {
				if(valuesOffset > 0) {
					slot -= step + valuesOffset;
				} else if(isReverse) {
					slot -= step + 1;
				}
			} else {
				slot -= step;
			}
			if(wasFound) {
				return series.at(slot - series.index + +((!options.reverse)));
			} else {
				return types_None.NONE;
			}
		} else {
			throw haxe_Exception.thrown("NYI");
		}
	}
	insert(series,value,options) {
		return runtime_actions_datatypes__$BlockLikeActions._insert(series,value,options,false);
	}
	select(series,value,options) {
		let result = this.find(series,value,{...options, match: false, tail: false});
		if(result != types_None.NONE) {
			let offset;
			if(options.only) {
				offset = 1;
			} else if(((value) instanceof types_base__$BlockLike) == true) {
				let __anon0__b = value;
				if(!((value) instanceof types_Hash)) {
					let b = __anon0__b;
					offset = b.index;
				} else {
					offset = 1;
				}
			} else {
				offset = 1;
			}
			let blk = result;
			let s = blk.values;
			let p = blk.index + offset;
			if(p < blk.values.length) {
				result = s[p];
			} else {
				result = types_None.NONE;
			}
		}
		return result;
	}
	sort(series,options) {
		let step = 1;
		let flags = 0;
		let s = series.values;
		let head = series.index;
		if(head == series.values.length) {
			return series;
		}
		let len = series.values.length - series.index;
		let tmp = options.part;
		let _g = tmp != null ? tmp.length : null;
		let _hx_tmp;
		if(_g != null) {
			_hx_tmp = _g;
			let part = _hx_tmp;
			let len2;
			let _hx_tmp1;
			if(((part) instanceof types_Integer) == true) {
				let __anon0__i = part;
				let i = __anon0__i;
				len2 = i.int;
			} else {
				_hx_tmp1 = ((part) instanceof types_base__$BlockLike);
				if(_hx_tmp1 == true) {
					let __anon0__b = part;
					let b = __anon0__b;
					if(!(series.constructor == b.constructor && series.values == b.values)) {
						throw haxe_Exception.thrown("bad");
					}
					len2 = b.index - series.index;
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
			if(len2 < len) {
				len = len2;
				if(len2 < 0) {
					len2 = -len2;
					series.index -= len2;
					if(series.index < 0) {
						series.index = 0;
						len = 0;
					} else {
						len = len2;
					}
					head -= len;
				}
			}
		}
		if(len == 0) {
			return series;
		}
		let tmp1 = options.skip;
		let _g1 = tmp1 != null ? tmp1.size : null;
		let _hx_tmp1;
		if(_g1 == null) {
			if(options.all) {
				throw haxe_Exception.thrown("bad");
			}
		} else {
			_hx_tmp1 = _g1;
			let skip = _hx_tmp1;
			step = skip.int;
			if(step <= 0 || len % step != 0 || step > len) {
				throw haxe_Exception.thrown("bad");
			}
			if(step > 1) {
				len /= step;
			}
		}
		if(options.reverse) {
			flags |= 1;
		}
		let op = options._case ? 8 : 7;
		let cmp = runtime_Actions.compareValue;
		let tmp2 = options.compare;
		let _g2 = tmp2 != null ? tmp2.comparator : null;
		let _hx_tmp2;
		if(_g2 == null) {
			if(options.all) {
				flags |= 2;
			}
		} else {
			_hx_tmp2 = _g2;
			let comparator = _hx_tmp2;
			let _hx_tmp;
			if(((comparator) instanceof types_Function) == true) {
				let __anon0__f = comparator;
				let f = __anon0__f;
				if(options.all && options.skip != null) {
					flags |= 2;
					flags |= step << 2;
				}
				cmp = runtime_actions_datatypes__$BlockLikeActions.compareCall;
				op = f;
			} else {
				_hx_tmp = ((comparator) instanceof types_Integer);
				if(_hx_tmp == true) {
					let __anon0__i = comparator;
					let i = __anon0__i;
					if(options.all || options.skip == null) {
						throw haxe_Exception.thrown("bad");
					}
					let offset = i.int;
					if(offset < 1 || offset > step) {
						throw haxe_Exception.thrown("bad");
					}
					flags |= offset - 1 << 2;
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
		}
		if(options.stable) {
			runtime_Sort.mergeSort(series.values,head,len,step,op,flags,cmp);
		} else {
			runtime_Sort.quickSort(series.values,head,len,step,op,flags,cmp);
		}
		return series;
	}
	swap(series1,series2) {
		if(series1.values.length - series1.index == 0) {
			return series1;
		}
		if(((series2) instanceof types_base__$BlockLike) == true) {
			let __anon0__s2 = series2;
			let s2 = __anon0__s2;
			if(s2.values.length - s2.index == 0) {
				return series1;
			}
			let value1 = series1.values[series1.index];
			let value2 = s2.values[s2.index];
			series1.values[series1.index] = value2;
			s2.values[s2.index] = value1;
			return series1;
		} else {
			throw haxe_Exception.thrown("bad");
		}
	}
	put(series,key,value,options) {
		let blk = this.find(series,key,{...runtime_actions_Find.defaultOptions, _case: options._case});
		if(blk == types_None.NONE) {
			series.values.push(key);
			series.values.push(value);
		} else {
			blk.values[blk.index + 1] = value;
		}
		return value;
	}
	static _insert(series,value,options,isAppend) {
		let cnt = 1;
		let part = -1;
		let isHash = ((series) instanceof types_Hash);
		let shouldRehash = false;
		let isHash1 = isHash;
		let isValues = !options.only && ((value) instanceof types_base__$BlockLike);
		let tmp = options.part;
		if(tmp != null) {
			let _g = tmp.length;
			let _hx_tmp;
			if(((_g) instanceof types_Integer) == true) {
				let __anon0__i = _g;
				let i = __anon0__i;
				part = i.int;
			} else {
				_hx_tmp = ((_g) instanceof types_base__$BlockLike);
				if(_hx_tmp == true) {
					let __anon0__b = _g;
					let b = __anon0__b;
					if(series.values == b.values) {
						part = b.index - series.index;
					} else {
						throw haxe_Exception.thrown("bad");
					}
				}
			}
		}
		let tmp1 = options.dup;
		if(tmp1 != null) {
			let _g = tmp1.count;
			let _hx_tmp;
			if(_g != null) {
				_hx_tmp = _g;
				let c = _hx_tmp;
				cnt = c.int;
				if(cnt < 0) {
					return series;
				}
			}
		}
		let src = value;
		let size = isValues ? src.values.length - src.index : 1;
		if(part < 0 || part > size) {
			part = size;
		}
		let isTail = series.isTail() || isAppend;
		let slots = part * cnt;
		let index = isAppend ? series.values.length - 1 : series.index;
		let s = series.values;
		let blk = src.values;
		let head = series.index;
		while(cnt != 0) {
			if(isValues) {
				let cell = src.index;
				let limit = cell + part;
				if(isTail) {
					while(cell < limit) {
						s.push(blk[cell]);
						++cell;
					}
				} else {
					while(cell < limit) {
						s.splice(head,0,blk[cell]);
						++head;
						++cell;
					}
				}
			} else if(isTail) {
				s.push(value);
			} else {
				s.splice(head,0,value);
				++head;
			}
			--cnt;
		}
		if(isAppend) {
			return series.head();
		} else {
			let idx = series.index + slots;
			if(idx >= series.values.length) {
				return series.tail();
			} else {
				return series.fastSkipHead(idx);
			}
		}
	}
	static compareCall(value1,value2,fun,flags) {
		let v1;
		let v2;
		if((flags & 1) == 0) {
			v1 = value2;
			v2 = value1;
		} else {
			v1 = value1;
			v2 = value2;
		}
		let isAll = (flags & 2) != 0;
		let num = flags >>> 2;
		let tmp = isAll && num > 0;
		let res = runtime_Eval.callFunction(fun,[v1,v2],new Map());
		let res2;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((res) instanceof types_Logic) == true) {
			let __anon0__l = res;
			let l = __anon0__l;
			res2 = +(l.cond);
		} else {
			_hx_tmp2 = ((res) instanceof types_Integer);
			if(_hx_tmp2 == true) {
				let __anon0__i = res;
				let i = __anon0__i;
				res2 = i.int;
			} else {
				_hx_tmp1 = ((res) instanceof types_Float);
				if(_hx_tmp1 == true) {
					let __anon0__f = res;
					let f = __anon0__f;
					res2 = f.float | 0;
				} else {
					_hx_tmp = ((res) instanceof types_None);
					res2 = _hx_tmp == true ? -1 : 1;
				}
			}
		}
		return (flags & 1) != 0 ? -res2 : res2;
	}
}
runtime_actions_datatypes__$BlockLikeActions.__name__ = true;
runtime_actions_datatypes__$BlockLikeActions.__super__ = runtime_actions_datatypes_SeriesActions;
Object.assign(runtime_actions_datatypes__$BlockLikeActions.prototype, {
	__class__: runtime_actions_datatypes__$BlockLikeActions
});
class runtime_actions_datatypes_BlockActions extends runtime_actions_datatypes__$BlockLikeActions {
	constructor() {
		super();
	}
	makeThis(values,index,newlines) {
		return new types_Block(values,index,newlines);
	}
	make(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		if(((spec) instanceof types_Integer) == true) {
			return this.makeThis([]);
		} else {
			_hx_tmp3 = ((spec) instanceof types_Float);
			if(_hx_tmp3 == true) {
				return this.makeThis([]);
			} else {
				_hx_tmp2 = ((spec) instanceof types_base__$BlockLike);
				if(_hx_tmp2 == true) {
					let __anon0__b = spec;
					let b = __anon0__b;
					let tmp = b.cloneValues();
					let tmp1;
					let _hx_tmp = ((b) instanceof types_base__$Block) ? b : null;
					if(_hx_tmp == null) {
						tmp1 = null;
					} else {
						let _g = _hx_tmp.get_TYPE_KIND();
						let _g1 = _hx_tmp.index;
						let _g2 = _hx_tmp.values;
						let _g3 = _hx_tmp.values.length - _hx_tmp.index;
						let _g4 = _hx_tmp.values.length;
						let nl = _hx_tmp.newlines;
						tmp1 = nl != null ? new Set(nl) : null;
					}
					return this.makeThis(tmp,0,tmp1);
				} else {
					_hx_tmp1 = ((spec) instanceof types_Object);
					if(_hx_tmp1 == true) {
						let __anon0__o = spec;
						let o = __anon0__o;
						return runtime_actions_datatypes_ObjectActions._reflect(o,runtime_Words.BODY);
					} else {
						_hx_tmp = ((spec) instanceof types_Map);
						if(_hx_tmp == true) {
							let __anon0__m = spec;
							let m = __anon0__m;
							return this.makeThis(m.values.slice());
						} else {
							throw new runtime_actions_InvalidAction("Invalid action!");
						}
					}
				}
			}
		}
	}
	to(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		if(((spec) instanceof types_Object) == true) {
			let __anon0__o = spec;
			let o = __anon0__o;
			return runtime_actions_datatypes_ObjectActions._reflect(o,runtime_Words.BODY);
		} else {
			_hx_tmp3 = ((spec) instanceof types_Map);
			if(_hx_tmp3 == true) {
				let __anon0__m = spec;
				let m = __anon0__m;
				return this.makeThis(m.values.slice());
			} else {
				_hx_tmp2 = ((spec) instanceof types_String);
				if(_hx_tmp2 == true) {
					let __anon0__s = spec;
					let s = __anon0__s;
					return this.makeThis(Tokenizer.parse(s.toJs()));
				} else {
					_hx_tmp1 = ((spec) instanceof types_Typeset);
					if(_hx_tmp1 == true) {
						let __anon0__t = spec;
						let t = __anon0__t;
						let _g = [];
						let jsIterator = t.types.values();
						let _g_jsIterator = jsIterator;
						let _g_lastStep = jsIterator.next();
						while(!_g_lastStep.done) {
							let v = _g_lastStep.value;
							_g_lastStep = _g_jsIterator.next();
							let value = v;
							_g.push(value);
						}
						return this.makeThis(_g);
					} else {
						_hx_tmp = ((spec) instanceof types_base__$BlockLike);
						if(_hx_tmp == true) {
							let __anon0__b = spec;
							let b = __anon0__b;
							let tmp = b.cloneValues();
							let tmp1;
							let _hx_tmp = ((b) instanceof types_base__$Block) ? b : null;
							if(_hx_tmp == null) {
								tmp1 = null;
							} else {
								let _g = _hx_tmp.get_TYPE_KIND();
								let _g1 = _hx_tmp.index;
								let _g2 = _hx_tmp.values;
								let _g3 = _hx_tmp.values.length - _hx_tmp.index;
								let _g4 = _hx_tmp.values.length;
								let nl = _hx_tmp.newlines;
								tmp1 = nl != null ? new Set(nl) : null;
							}
							return this.makeThis(tmp,0,tmp1);
						} else {
							return this.makeThis([spec]);
						}
					}
				}
			}
		}
	}
	form(value,buffer,arg,part) {
		let cycle;
		/*;
		cycle = */ //;
		[part, cycle] = Cycles.detect(value,buffer,part,false);
		if(cycle) {
			return part;
		}
		let c = 0;
		Cycles.push(value.values);
		let _g = value.index;
		let _g1 = value.values.length;
		while(_g < _g1) {
			let i = _g++;
			if(arg != null && part <= 0) {
				Cycles.pop();
				return part;
			}
			let value1 = value.values[i];
			let value2 = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
			if(value2 == null) {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			part = value2.form(value1,buffer,arg,part);
			if(i + 1 == value.values.length) {
				c = buffer.values.length - buffer.index == 0 ? 0 : buffer.values.at(-1);
			}
			if(!(c == 10 || c == 13 || c == 9)) {
				buffer.values.push(32);
				--part;
			}
		}
		Cycles.pop();
		return part;
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		let cycle;
		/*;
		cycle = */ //;
		[part, cycle] = Cycles.detect(value,buffer,part,true);
		if(cycle) {
			return part;
		}
		if(!isOnly) {
			buffer.values.push(91);
			--part;
		}
		part = runtime_actions_datatypes_BlockActions.moldEach(value,buffer,isOnly,isAll,isFlat,arg,part,indent);
		if(!isOnly) {
			buffer.values.push(93);
			--part;
		}
		return part;
	}
	evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		if(((element) instanceof types_Integer) == true) {
			let __anon0__i = element;
			let i = __anon0__i;
			let _hx_tmp;
			if(value == null) {
				return this.pick(parent,i);
			} else {
				_hx_tmp = value;
				let value1 = _hx_tmp;
				return this.poke(parent,i,value1);
			}
		} else {
			let _hx_tmp;
			if(value == null) {
				return this.select(parent,element,{...runtime_actions_Select.defaultOptions, only: true});
			} else {
				_hx_tmp = value;
				let value1 = _hx_tmp;
				return this.put(parent,element,value1,runtime_actions_Put.defaultOptions);
			}
		}
	}
	copy(series,options) {
		let node = series.values;
		let res = super.copy(series,options);
		if(options.deep) {
			if(Cycles.find(node)) {
				throw haxe_Exception.thrown("bad");
			}
			Cycles.push(node);
			let _g = 0;
			let _g1 = res.values.length;
			while(_g < _g1) {
				let i = _g++;
				let _g1 = res.values[i];
				if(((_g1) instanceof types_base__$SeriesOf) == true) {
					let __anon0__slot = _g1;
					let slot = __anon0__slot;
					res.values[i] = runtime_actions_Copy.call(res.values[i],{ deep : true});
				}
			}
			Cycles.pop();
		}
		return res;
	}
	take(series,options) {
		let _g = super.take(series,options);
		if(((_g) instanceof types_base__$BlockLike) == true) {
			let __anon0__blk = _g;
			let blk = __anon0__blk;
			let s = blk.values;
			if(options.deep) {
				let _g = 0;
				let _g1 = blk.values.length;
				while(_g < _g1) {
					let i = _g++;
					let _g1 = s[i];
					if(((_g1) instanceof types_base__$SeriesOf) == true) {
						let __anon0__slot = _g1;
						let slot = __anon0__slot;
						s[i] = runtime_actions_Copy.call(slot,{ deep : true});
					}
				}
			}
			if(options.part == null) {
				return blk.copy();
			} else {
				return blk;
			}
		} else {
			let res = _g;
			return res;
		}
	}
	trim(series,options) {
		let _g = 0;
		let _g1 = series.values.length - series.index;
		while(_g < _g1) {
			let i = _g++;
			if(series.values[series.index + i] == types_None.NONE) {
				series.removeAt(i);
			}
		}
		return series;
	}
	static moldEach(blk,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		let head = blk.index;
		let value = head;
		let tail = blk.values.length;
		let lf = false;
		Cycles.push(blk.values);
		while(value < tail) {
			if(arg != null && part <= 0) {
				Cycles.pop();
				return part;
			}
			if(!isFlat && blk.hasNewline(value)) {
				if(!isOnly && value == head) {
					lf = true;
					++indent;
				}
				if(!isOnly || value != head) {
					buffer.values.push(10);
					--part;
				}
				let _g = 0;
				let _g1 = indent;
				while(_g < _g1) {
					++_g;
					buffer.appendLiteral("    ");
				}
				part -= indent * 4;
			}
			let value1 = blk.values[value];
			if(value1 == null) {
				value1 = types_Tag.fromString("null");
			}
			let value2 = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
			if(value2 == null) {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			part = value2.mold(value1,buffer,false,isAll,isFlat,arg,part,indent);
			buffer.values.push(32);
			--part;
			++value;
		}
		Cycles.pop();
		if(value != head) {
			buffer.values.pop();
			++part;
		}
		if(lf) {
			--indent;
			buffer.values.push(10);
			let _g = 0;
			let _g1 = indent;
			while(_g < _g1) {
				++_g;
				buffer.appendLiteral("    ");
			}
			part -= indent * 4 + 1;
		}
		return part;
	}
}
runtime_actions_datatypes_BlockActions.__name__ = true;
runtime_actions_datatypes_BlockActions.__super__ = runtime_actions_datatypes__$BlockLikeActions;
Object.assign(runtime_actions_datatypes_BlockActions.prototype, {
	__class__: runtime_actions_datatypes_BlockActions
});
class runtime_actions_datatypes_ParenActions extends runtime_actions_datatypes_BlockActions {
	constructor() {
		super();
	}
	makeThis(values,index,newlines) {
		return new types_Paren(values,index,newlines);
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		buffer.values.push(40);
		--part;
		part = runtime_actions_datatypes_BlockActions.moldEach(value,buffer,isOnly,isAll,isFlat,arg,part,indent);
		buffer.values.push(41);
		return part - 1;
	}
}
runtime_actions_datatypes_ParenActions.__name__ = true;
runtime_actions_datatypes_ParenActions.__super__ = runtime_actions_datatypes_BlockActions;
Object.assign(runtime_actions_datatypes_ParenActions.prototype, {
	__class__: runtime_actions_datatypes_ParenActions
});
class runtime_actions_datatypes_StringActions extends runtime_actions_datatypes_SeriesActions {
	constructor() {
		super();
	}
	form(value,buffer,arg,part) {
		buffer.append(value,arg);
		return part - (value.values.length - value.index);
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		let head = value.index;
		let p = head;
		let tail = (arg != null ? arg : 0) == 0 ? value.values.length : part < 0 ? head : Math.min((head + part), value.values.length);
		let cBeg = 0;
		let conti = true;
		/*;
		let quote = ;
		let nl = ;
		*/ //;
		let [quote, nl] = runtime_actions_datatypes_StringActions.sniffChars(value,head,tail);
		let open;
		let close;
		if(nl >= 3 || quote > 0 || 50 <= value.values.length - value.index) {
			open = 123;
			close = 125;
		} else {
			close = 34;
			open = 34;
		}
		buffer.values.push(open);
		while(p < tail) {
			let cp = value.values[p];
			if(open == 123) {
				switch(cp) {
				case 34:
					buffer.values.push(cp);
					break;
				case 94:
					buffer.appendLiteral("^^");
					break;
				case 123:
					if(conti && !runtime_actions_datatypes_StringActions.findRightBrace(value,p,tail)) {
						conti = false;
					}
					if(conti) {
						++cBeg;
					} else {
						buffer.values.push(94);
					}
					buffer.values.push(cp);
					break;
				case 125:
					if(cBeg > 0) {
						--cBeg;
					} else {
						buffer.values.push(cp);
					}
					break;
				default:
					buffer.appendEscapedChar(cp,true,isAll);
				}
			} else {
				buffer.appendEscapedChar(cp,true,isAll);
			}
			++p;
		}
		buffer.values.push(close);
		return part - (tail - head) - 2;
	}
	evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		let _hx_tmp;
		if(((element) instanceof types_Integer) == true) {
			let __anon0__i = element;
			let i = __anon0__i;
			let _hx_tmp;
			if(value == null) {
				return this.pick(parent,i);
			} else {
				_hx_tmp = value;
				let value1 = _hx_tmp;
				return this.poke(parent,i,value1);
			}
		} else {
			_hx_tmp = ((element) instanceof types_Word);
			if(_hx_tmp == true) {
				throw haxe_Exception.thrown("invalid path");
			} else {
				throw haxe_Exception.thrown("todo");
			}
		}
	}
	compare(value1,value2,op) {
		if(value1.constructor != value2.constructor && (!((value2) instanceof types_base__$String) || op != 0 && op != 1)) {
			return -2;
		}
		let str1 = value1;
		let str2 = value2;
		let isSame = str1 == str2 || str1.constructor == str2.constructor && str1.values == str2.values && str1.index == str2.index;
		if(op == 9) {
			if(isSame) {
				return 0;
			} else {
				return -1;
			}
		}
		if(isSame) {
			switch(op) {
			case 0:case 1:case 2:case 11:
				return 0;
			default:
			}
		}
		let size1 = str1.values.length - str1.index;
		let size2 = str2.values.length - str2.index;
		if(size1 != size2) {
			switch(op) {
			case 0:case 1:case 2:case 10:case 11:
				return 1;
			default:
			}
		}
		if(size1 == 0) {
			return 0;
		}
		let len = Math.min(size1, size2);
		let c1 = null;
		let c2 = null;
		let isCase = op == 2 || op == 8;
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			c1 = str1.wrap(str1.values[str1.index + i]);
			c2 = str2.wrap(str2.values[str2.index + i]);
			if(!isCase) {
				c1 = c1.toUpperCase();
				c2 = c2.toUpperCase();
			}
			if(c1 != c2) {
				break;
			}
		}
		if(c1 == c2) {
			return Math.sign((size1 - size2));
		} else {
			return Math.sign((c1.int - c2.int));
		}
	}
	append(string,value,options) {
		return runtime_actions_datatypes_StringActions._insert(string,value,options,true);
	}
	find(series,value,options) {
		let s = series.values;
		let head = series.index;
		let end = series.values.length;
		let len = series.values.length - series.index;
		if(head == end || !options.reverse && head >= end) {
			return types_None.NONE;
		}
		let step = 1;
		let isPart = false;
		if(options.any || options.with != null) {
			throw haxe_Exception.thrown("NYI");
		}
		let tmp = options.skip;
		let _g = tmp != null ? tmp.size : null;
		let _hx_tmp;
		if(_g != null) {
			_hx_tmp = _g;
			let skip = _hx_tmp;
			step = skip.int;
			if(step < 1) {
				throw haxe_Exception.thrown("bad");
			}
		}
		let sz = 0;
		let limit = 0;
		let tmp1 = options.part;
		let _g1 = tmp1 != null ? tmp1.length : null;
		let _hx_tmp1;
		if(_g1 != null) {
			_hx_tmp1 = _g1;
			let part = _hx_tmp1;
			let _hx_tmp;
			if(((part) instanceof types_Integer) == true) {
				let __anon0__i = part;
				let i = __anon0__i;
				sz = i.int;
			} else {
				_hx_tmp = ((part) instanceof types_base__$String);
				if(_hx_tmp == true) {
					let __anon0__str = part;
					let str = __anon0__str;
					if(!(str.constructor == series.constructor && str.values == series.values)) {
						throw haxe_Exception.thrown("bad");
					}
					sz = str.index - series.index;
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
			if(sz <= 0) {
				return types_None.NONE;
			}
			if(sz > len) {
				sz = len;
			}
			isPart = true;
			limit = sz;
		}
		if(options.last) {
			step = -step;
			end = head;
			if(isPart) {
				head += limit;
			} else {
				head = series.values.length;
			}
			--head;
		} else if(options.reverse) {
			step = -step;
			head = end + (head - 1);
			if(isPart) {
				end = head - limit + 1;
			}
			if(head < end || options.match) {
				return types_None.NONE;
			}
		} else if(isPart) {
			end = head + limit;
		}
		let isCase = !((series) instanceof types_Binary) && !options._case;
		if(options.same) {
			isCase = false;
		}
		let isReverse = options.reverse || options.last;
		let pattern = null;
		let end2 = null;
		let isBs = false;
		let isFloat = ((value) instanceof types_Float);
		let sz2 = 0;
		let s2 = null;
		let c2 = 0;
		let bs = null;
		let str2 = null;
		let head2 = 0;
		let cf2 = 0.0;
		let _hx_tmp2;
		let _hx_tmp3;
		let _hx_tmp4;
		if(((value) instanceof types_Char) == true) {
			let __anon0__c = value;
			let c = __anon0__c;
			c2 = c.int;
			if(isCase) {
				c2 = Util.toUpperCase(c2);
			}
		} else {
			_hx_tmp4 = ((value) instanceof types_Bitset);
			if(_hx_tmp4 == true) {
				let __anon0__b = value;
				let b = __anon0__b;
				bs = b;
				isBs = true;
				isCase = false;
			} else {
				_hx_tmp3 = ((value) instanceof types_base__$String);
				if(_hx_tmp3 == true) {
					let __anon0__str = value;
					let str = __anon0__str;
					if(((str) instanceof types_Binary) && !((series) instanceof types_Binary)) {
						throw haxe_Exception.thrown("bad");
					}
					str2 = str;
					head2 = str.index;
					s2 = str2.values;
					pattern = str2.index + head2;
					end2 = str2.values.length;
					sz2 = end2 - pattern;
				} else {
					_hx_tmp2 = ((value) instanceof types_Word);
					if(_hx_tmp2 == true) {
						let __anon0__w = value;
						let w = __anon0__w;
						str2 = types_String.fromString(w.symbol.name);
						head2 = 0;
						s2 = str2.values;
						pattern = str2.index + head2;
						end2 = str2.values.length;
						sz2 = end2 - pattern;
					} else if(((series) instanceof types_Binary) && (((value) instanceof types_Integer) || isFloat)) {
						if(isFloat) {
							cf2 = value.float;
						} else {
							c2 = value.int;
						}
					} else {
						str2 = runtime_actions_Form.call(value,runtime_actions_Form.defaultOptions);
						head2 = 0;
						s2 = str2.values;
						pattern = str2.index + head2;
						end2 = str2.values.length;
						sz2 = end2 - pattern;
					}
				}
			}
		}
		let wasFound = false;
		do {
			if(pattern == null) {
				let c1 = s[head];
				if(isCase && !isFloat) {
					c1 = Util.toUpperCase(c1);
				}
				if(isBs) {
					wasFound = bs.testBit(c1);
				} else {
					wasFound = c1 == c2;
				}
				if(wasFound && options.tail && !isReverse) {
					head += step;
				}
			} else {
				let p1 = head;
				let end1 = end;
				if(isReverse) {
					sz = p1 - end + 1;
					if(sz < sz2) {
						wasFound = false;
						break;
					}
					p1 -= sz2 - 1;
					end1 = head + 1;
				}
				let p2 = pattern;
				do {
					let c1 = s[p1];
					let c2 = s2[p2];
					if(isCase) {
						c1 = Util.toUpperCase(c1);
						c2 = Util.toUpperCase(c2);
					}
					wasFound = c1 == c2;
					++p1;
					++p2;
				} while(!(!wasFound || p2 >= end2 || p1 >= end1));
				if(wasFound && p2 < end2 && p1 >= end1) {
					wasFound = false;
				}
				if(wasFound) {
					if(isReverse) {
						head = end1 - sz2;
					}
					if(options.tail) {
						head = p1;
					}
				}
			}
			head += step;
		} while(!(options.match || !options.match && wasFound || isReverse && head < end || !isReverse && head >= end));
		head -= step;
		if(options.tail && isReverse && pattern == null) {
			head -= step;
		}
		if(wasFound) {
			return series.clone(series.values,head - series.index);
		} else {
			return types_None.NONE;
		}
	}
	insert(string,value,options) {
		return runtime_actions_datatypes_StringActions._insert(string,value,options,false);
	}
	select(series,value,options) {
		let result = this.find(series,value,{...options, tail: false, match: false});
		if(result != types_None.NONE) {
			let offset;
			if(((value) instanceof types_base__$String) == true) {
				let __anon0__s = value;
				let s = __anon0__s;
				offset = s.values.length - s.index;
			} else {
				offset = 1;
			}
			let str = result;
			let s = str.values;
			let p = str.index + offset;
			if(p < str.values.length) {
				let char = s[p];
				if(((str) instanceof types_Binary) == true) {
					return new types_Integer(char);
				} else {
					return types_Char.fromCode(char);
				}
			} else {
				return types_None.NONE;
			}
		}
		return result;
	}
	sort(series,options) {
		let step = 1;
		let s = series.values;
		let head = series.index;
		let end = series.values.length;
		let len = series.values.length - series.index;
		let tmp = options.part;
		let _g = tmp != null ? tmp.length : null;
		let _hx_tmp;
		if(_g != null) {
			_hx_tmp = _g;
			let part = _hx_tmp;
			let len2;
			let _hx_tmp1;
			if(((part) instanceof types_Integer) == true) {
				let __anon0__i = part;
				let i = __anon0__i;
				len2 = i.int;
			} else {
				_hx_tmp1 = ((part) instanceof types_base__$String);
				if(_hx_tmp1 == true) {
					let __anon0__str = part;
					let str = __anon0__str;
					if(!(str.constructor == series.constructor && str.values == series.values)) {
						throw haxe_Exception.thrown("bad");
					}
					len2 = str.index - series.index;
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
			if(len2 < len) {
				len = len2;
				if(len2 < 0) {
					len2 = -len2;
					series.index -= len2;
					if(series.index < 0) {
						series.index = 0;
						len = 0;
					} else {
						len = len2;
					}
					head -= len;
				}
			}
		}
		if(len == 0) {
			return series;
		}
		let tmp1 = options.skip;
		let _g1 = tmp1 != null ? tmp1.size : null;
		let _hx_tmp1;
		if(_g1 == null) {
			if(options.all) {
				throw haxe_Exception.thrown("bad");
			}
		} else {
			_hx_tmp1 = _g1;
			let skip = _hx_tmp1;
			step = skip.int;
			if(step <= 0 || len % step != 0 || step > len) {
				throw haxe_Exception.thrown("bad");
			}
			if(step > 1) {
				len /= step;
			}
		}
		let cmp = runtime_actions_datatypes_StringActions.compareChar;
		let op = options._case ? 2 : 0;
		let flags = options.reverse ? 1 : 0;
		let tmp2 = options.compare;
		let _g2 = tmp2 != null ? tmp2.comparator : null;
		let _hx_tmp2;
		if(_g2 == null) {
			if(options.all && options.skip != null) {
				flags |= 2;
				flags |= step << 2;
			}
		} else {
			_hx_tmp2 = _g2;
			let comparator = _hx_tmp2;
			let _hx_tmp;
			if(((comparator) instanceof types_Function) == true) {
				let __anon0__f = comparator;
				let f = __anon0__f;
				if(options.all && options.skip != null) {
					flags |= 2;
					flags |= step << 2;
				}
				cmp = runtime_actions_datatypes_StringActions.compareCharCall;
				op = f;
			} else {
				_hx_tmp = ((comparator) instanceof types_Integer);
				if(_hx_tmp == true) {
					let __anon0__i = comparator;
					let i = __anon0__i;
					if(options.all || options.skip == null) {
						throw haxe_Exception.thrown("bad");
					}
					flags |= i.int - 1 << 2;
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
		}
		runtime_Sort.quickSort(s,head,len,step,op,flags,cmp);
		return series;
	}
	trim(series,options) {
		if(options.all || options.with != null) {
			runtime_actions_datatypes_StringActions.trimWith(series,options.with.str);
		} else if(options.auto) {
			throw haxe_Exception.thrown("NYI");
		} else if(options.lines) {
			runtime_actions_datatypes_StringActions.trimLines(series);
		} else {
			runtime_actions_datatypes_StringActions.trimHeadTail(series,options.head,options.tail);
		}
		return series;
	}
	static sniffChars(str,p,len) {
		let quote = 0;
		let nl = 0;
		let _g = p;
		while(_g < len) switch(str.values[_g++]) {
		case 10:
			++nl;
			break;
		case 34:
			++quote;
			break;
		default:
		}
		return [quote,nl];
	}
	static findRightBrace(str,p,len) {
		let cnt = 0;
		let _g = 0;
		while(_g < len) switch(str.values[_g++]) {
		case 10:
			if(--cnt == 0) {
				return true;
			}
			break;
		case 123:
			++cnt;
			break;
		default:
		}
		return false;
	}
	static encodeUrlChar(isUri,pcode,ch) {
		if((ch > 127 ? 0 : (isUri ? runtime_actions_datatypes_StringActions.URI_ENCODE_TBL : runtime_actions_datatypes_StringActions.URL_ENCODE_TBL)[ch]) == 255) {
			pcode[0] = ch;
			return 1;
		} else {
			let str = ch.toString(16).toUpperCase().padStart(2, "0");
			pcode[0] = 37;
			pcode[1] = str.charCodeAt(0);
			pcode[2] = str.charCodeAt(1);
			return 3;
		}
	}
	static _insert(string,value,options,isAppend) {
		let part;
		let _g = options.part;
		if(_g == null) {
			part = -1;
		} else {
			let p = _g.length;
			let _hx_tmp;
			let _hx_tmp1;
			if(((p) instanceof types_Integer) == true) {
				let __anon0__i = p;
				let i = __anon0__i;
				part = i.int;
			} else {
				_hx_tmp1 = ((p) instanceof types_base__$String);
				if(_hx_tmp1 == true) {
					let __anon0__s = p;
					let s = __anon0__s;
					part = s.values.length - s.index;
				} else {
					_hx_tmp = ((p) instanceof types_base__$BlockLike);
					if(_hx_tmp == true) {
						let __anon0__b = p;
						let b = __anon0__b;
						part = b.values.length - b.index;
					} else {
						throw haxe_Exception.thrown("bad");
					}
				}
			}
		}
		let str = runtime_actions_Form.call(value,{ part : { limit : new types_Integer(part)}});
		let dupN = 1;
		let cnt = 1;
		let _g1 = options.dup;
		let _hx_tmp;
		if(_g1 != null) {
			_hx_tmp = _g1;
			let d = _hx_tmp;
			cnt = d.count.int;
			if(cnt < 0) {
				return string;
			}
			dupN = cnt;
		}
		let s = string.values;
		let length = string.values.length - string.index;
		let isTail = length == 0 || isAppend;
		let index = isAppend ? length : string.index;
		let added = 0;
		while(cnt != 0) {
			let cell;
			let limit;
			let src;
			let s2;
			if(((value) instanceof types_base__$Block) == true) {
				let __anon0__b = value;
				let b = __anon0__b;
				src = b;
				s2 = src.values;
				cell = src.index;
				limit = src.values.length;
			} else {
				src = null;
				s2 = null;
				cell = -1;
				limit = 0;
			}
			let rest = 0;
			added = 0;
			let formBuf;
			while(cell < limit && added != part) {
				let v = cell == -1 ? value : s2[cell];
				if(((v) instanceof types_Char) == true) {
					let __anon0__c = v;
					let c = __anon0__c;
					if(isTail) {
						s.push(c.int);
					} else {
						s.splice(index,0,c.int);
					}
					++added;
				} else {
					if(((v) instanceof types_base__$String) && !(((v) instanceof types_Tag) || ((v) instanceof types_Binary))) {
						formBuf = v.copy();
					} else {
						formBuf = new types_String([]);
						let value = runtime_Actions.ACTIONS.get(v.get_TYPE_KIND());
						let tmp;
						if(value != null) {
							tmp = value;
						} else {
							throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
						}
						tmp.form(v,formBuf,null,0);
					}
					let len = formBuf.values.length - formBuf.index;
					let rest = len;
					if(part > 0) {
						rest = part - added;
						if(rest > len) {
							rest = len;
						}
					}
					if(isTail) {
						string.append(formBuf,rest);
					} else {
						string.insert(formBuf,index + added,rest);
					}
					added += rest;
				}
				++cell;
			}
			--cnt;
		}
		if(isAppend) {
			return string;
		} else {
			return string.skip(added * dupN);
		}
	}
	static changeRange(str,cell,cellIdx,allAdded,limit,hasPart) {
		let added = 0;
		while(cellIdx < limit) {
			if(((cell) instanceof types_Char) == true) {
				let __anon0__c = cell;
				let c = __anon0__c;
				if(hasPart) {
					str.values.splice(str.index,0,c.int);
				} else {
					str.values[str.index] = c.int;
				}
			} else {
				let formBuf;
				if(((cell) instanceof types_base__$String) == true) {
					let __anon0__s = cell;
					if(!((cell) instanceof types_Tag)) {
						let s = __anon0__s;
						formBuf = s.copy();
					} else {
						let buf = new types_String([]);
						let value = runtime_Actions.ACTIONS.get(cell.get_TYPE_KIND());
						let formBuf1;
						if(value != null) {
							formBuf1 = value;
						} else {
							throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
						}
						formBuf1.form(cell,buf,null,0);
						formBuf = buf;
					}
				} else {
					let buf = new types_String([]);
					let value = runtime_Actions.ACTIONS.get(cell.get_TYPE_KIND());
					let formBuf1;
					if(value != null) {
						formBuf1 = value;
					} else {
						throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
					}
					formBuf1.form(cell,buf,null,0);
					formBuf = buf;
				}
				let len = allAdded.ref = formBuf.values.length;
				if(hasPart) {
					str.insert(formBuf,added,null);
				} else {
					str.overwrite(formBuf,added,null);
				}
				added += len;
			}
			++cellIdx;
		}
		return added;
	}
	static trimWith(str,$with) {
		let withChars;
		let _hx_tmp;
		let _hx_tmp1;
		if((($with) instanceof types_base__$Integer) == true) {
			let __anon0__i = $with;
			let i = __anon0__i;
			withChars = new Set([i.int]);
		} else {
			_hx_tmp1 = (($with) instanceof types_String);
			if(_hx_tmp1 == true) {
				let __anon0__str2 = $with;
				let str2 = __anon0__str2;
				let s = str2.values;
				if(str2.values.length - str2.index == 0) {
					return;
				}
				withChars = str2.index == 0 ? new Set(s) : new Set(s.slice(str2.index));
			} else {
				_hx_tmp = (($with) instanceof types_Binary);
				if(_hx_tmp == true) {
					let __anon0__str2 = $with;
					let str2 = __anon0__str2;
					let s = str2.values;
					if(str2.values.length - str2.index == 0) {
						return;
					}
					withChars = str2.index == 0 ? new Set(s) : new Set(s.slice(str2.index));
				} else {
					withChars = new Set([9,10,13,32]);
				}
			}
		}
		let s = str.values;
		let c = 0;
		let _g = str.index;
		let _g1 = str.values.length - str.index;
		while(_g < _g1) {
			let i = _g++;
			if(!withChars.has(s[i])) {
				if(i > 0) {
					str.removeAt(0,c);
				}
				break;
			} else {
				++c;
			}
		}
		let i = str.values.length - str.index - 1;
		while(i >= 0) {
			if(!withChars.has(s[i])) {
				if(i > 0) {
					str.removeAt(i + 1,c);
				}
				break;
			} else {
				++c;
			}
			--i;
		}
	}
	static trimLines(str) {
		let pad = 0;
		let s = str.values;
		let tail = str.values.length;
		let _g = str.index;
		while(_g < tail) {
			let cur = _g++;
			if(runtime_actions_datatypes_StringActions.WHITE_CHAR.has(s[cur])) {
				if(pad == 1) {
					s[cur] = 32;
					pad = 2;
				}
			} else {
				pad = 1;
			}
		}
	}
	static trimHeadTail(str,isHead,isTail) {
		let appendLF = false;
		let s = str.values;
		let head = str.index;
		let tail = str.values.length - str.index;
		let cur = head;
		if(isHead || !isTail) {
			let char;
			while(true) {
				char = s[head];
				if(!(head < tail && runtime_actions_datatypes_StringActions.WHITE_CHAR.has(char))) {
					break;
				}
				if(char == 10) {
					appendLF = true;
				}
				++head;
			}
		}
		if(isTail || !isHead) {
			let char;
			while(true) {
				char = s[tail - 1];
				if(!(head < tail && runtime_actions_datatypes_StringActions.WHITE_CHAR.has(char))) {
					break;
				}
				if(char == 10) {
					appendLF = true;
				}
				--tail;
			}
		}
		if(!isHead && !isTail) {
			let outside = false;
			let left = 0;
			while(head < tail) {
				let skip = false;
				let char = s[head];
				if(runtime_actions_datatypes_StringActions.SPACE_CHAR.has(char)) {
					if(outside) {
						skip = true;
					} else if(left == 0) {
						left = cur;
					}
				} else if(char == 10) {
					outside = true;
					if(left != 0) {
						cur = left;
						left = 0;
					}
				} else {
					outside = false;
					left = 0;
				}
				if(!skip) {
					s[cur] = char;
					++cur;
				}
				++head;
			}
		} else {
			str.removeAt(0,head);
			str.removeAt(tail,str.values.length - str.index);
			cur += tail - head;
		}
		if(appendLF && !isTail) {
			s[cur] = 10;
		}
		s.length = cur;
	}
	static compareChar(c1,c2,op,flags) {
		let res;
		switch(op) {
		case 2:case 8:case 9:
			res = c1 - c2;
			break;
		default:
			res = Util.toUpperCase(c1) - Util.toUpperCase(c2);
		}
		return (flags & 1) != 0 ? -res : res;
	}
	static compareCharCall(value1,value2,fun,flags) {
		let v1;
		let v2;
		if((flags & 1) == 0) {
			v1 = types_Char.fromCode(value2);
			v2 = types_Char.fromCode(value1);
		} else {
			v1 = types_Char.fromCode(value1);
			v2 = types_Char.fromCode(value2);
		}
		let isAll = (flags & 2) != 0;
		let num = flags >>> 2;
		let tmp = isAll && num > 0;
		let res = runtime_Eval.callFunction(fun,[v1,v2],new Map());
		let res2;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((res) instanceof types_Logic) == true) {
			let __anon0__l = res;
			let l = __anon0__l;
			res2 = +(l.cond);
		} else {
			_hx_tmp2 = ((res) instanceof types_Integer);
			if(_hx_tmp2 == true) {
				let __anon0__i = res;
				let i = __anon0__i;
				res2 = i.int;
			} else {
				_hx_tmp1 = ((res) instanceof types_Float);
				if(_hx_tmp1 == true) {
					let __anon0__f = res;
					let f = __anon0__f;
					res2 = f.float | 0;
				} else {
					_hx_tmp = ((res) instanceof types_None);
					res2 = _hx_tmp == true ? -1 : 1;
				}
			}
		}
		return (flags & 1) != 0 ? -res2 : res2;
	}
}
runtime_actions_datatypes_StringActions.__name__ = true;
runtime_actions_datatypes_StringActions.__super__ = runtime_actions_datatypes_SeriesActions;
Object.assign(runtime_actions_datatypes_StringActions.prototype, {
	__class__: runtime_actions_datatypes_StringActions
});
class runtime_actions_datatypes_FileActions extends runtime_actions_datatypes_StringActions {
	constructor() {
		super();
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		let head = value.index;
		let p = head;
		let isEmpty = head == value.values.length;
		let tail = (arg != null ? arg : 0) == 0 ? value.values.length : part < 0 ? head : Math.min((head + part), value.values.length);
		buffer.values.push(37);
		if(isEmpty) {
			buffer.appendLiteral("\"\"");
		} else {
			while(p < tail) {
				let cp = value.values[p];
				if(cp < runtime_actions_datatypes_StringActions.URL_ENCODE_TBL.length && runtime_actions_datatypes_StringActions.URL_ENCODE_TBL[cp] == 0) {
					break;
				}
				++p;
			}
			let isEsc = p < tail;
			p = head;
			if(isEsc) {
				buffer.values.push(34);
			}
			while(p < tail) {
				buffer.values.push(value.values[p]);
				++p;
			}
			if(isEsc) {
				buffer.values.push(34);
			}
		}
		return part - (tail - head) - 1;
	}
}
runtime_actions_datatypes_FileActions.__name__ = true;
runtime_actions_datatypes_FileActions.__super__ = runtime_actions_datatypes_StringActions;
Object.assign(runtime_actions_datatypes_FileActions.prototype, {
	__class__: runtime_actions_datatypes_FileActions
});
class runtime_actions_datatypes_UrlActions extends runtime_actions_datatypes_StringActions {
	constructor() {
		super();
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		let hasLimit = arg != null;
		let num = 0;
		let p = new Uint8ClampedArray(3);
		let _g = value.index;
		let _g1 = value.values.length;
		while(_g < _g1) {
			let size = runtime_actions_datatypes_StringActions.encodeUrlChar(false,p,value.values[_g++]);
			let _g1 = 0;
			while(_g1 < size) {
				buffer.values.push(p[_g1++]);
				++num;
				if(hasLimit && num >= part) {
					return part - num;
				}
			}
		}
		return part - num;
	}
}
runtime_actions_datatypes_UrlActions.__name__ = true;
runtime_actions_datatypes_UrlActions.__super__ = runtime_actions_datatypes_StringActions;
Object.assign(runtime_actions_datatypes_UrlActions.prototype, {
	__class__: runtime_actions_datatypes_UrlActions
});
class runtime_actions_datatypes_IntegerActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	makeThis(i) {
		return new types_Integer(i);
	}
	make(proto,spec) {
		if(((spec) instanceof types_Logic) == true) {
			let __anon0__l = spec;
			let l = __anon0__l;
			return this.makeThis(+(l.cond));
		} else {
			return this.to(proto,spec);
		}
	}
	to(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		if(((spec) instanceof types_Integer) == true) {
			return spec;
		} else {
			_hx_tmp3 = ((spec) instanceof types_Char);
			if(_hx_tmp3 == true) {
				let __anon0__c = spec;
				let c = __anon0__c;
				return this.makeThis(c.int);
			} else {
				_hx_tmp2 = ((spec) instanceof types_Time);
				if(_hx_tmp2 == true) {
					let __anon0__t = spec;
					let t = __anon0__t;
					return this.makeThis(t.float + 0.5 | 0);
				} else {
					_hx_tmp1 = ((spec) instanceof types_base__$Float);
					if(_hx_tmp1 == true) {
						let __anon0__f = spec;
						let f = __anon0__f;
						return this.makeThis(f.float | 0);
					} else {
						_hx_tmp = ((spec) instanceof types_base__$String);
						if(_hx_tmp == true) {
							let __anon0__s = spec;
							let s = __anon0__s;
							let _g = Tokenizer.parse(s.toJs());
							if(_g.length == 1) {
								let _g1 = _g[0];
								if(((_g1) instanceof types_Integer) == true) {
									let __anon0__i = _g1;
									let i = __anon0__i;
									return i;
								} else {
									throw haxe_Exception.thrown("Can't parse integer! from \"" + s.toJs() + "\"");
								}
							} else {
								throw haxe_Exception.thrown("Can't parse integer! from \"" + s.toJs() + "\"");
							}
						} else {
							throw new runtime_actions_InvalidAction("Invalid action!");
						}
					}
				}
			}
		}
	}
	form(value,buffer,arg,part) {
		let formed = value.int.toString();
		buffer.appendLiteral(formed);
		return part - formed.length;
	}
	mold(value,buffer,_,_1,_2,arg,part,_3) {
		return this.form(value,buffer,arg,part);
	}
	compare(value1,value2,op) {
		if((op == 11 || op == 2) && value2.constructor != value1.constructor) {
			return 1;
		}
		let other;
		let _hx_tmp;
		let _hx_tmp1;
		if(((value2) instanceof types_base__$Integer) == true) {
			let __anon0__i = value2;
			let i = __anon0__i;
			other = i.int;
		} else {
			_hx_tmp1 = ((value2) instanceof types_Money);
			if(_hx_tmp1 == true) {
				let __anon0__m = value2;
				let m = __anon0__m;
				let value = runtime_Actions.ACTIONS.get(42);
				let other;
				if(value != null) {
					other = value;
				} else {
					throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
				}
				return other.compare(runtime_actions_datatypes_MoneyActions.fromInteger(value1),m,op);
			} else {
				_hx_tmp = ((value2) instanceof types_base__$Float);
				if(_hx_tmp == true) {
					let __anon0__f = value2;
					let f = __anon0__f;
					other = f.float;
				} else {
					return -2;
				}
			}
		}
		return Math.sign((value1.int - other));
	}
	doMath(left,right,op) {
		if(((left) instanceof types_base__$Integer) == true) {
			let __anon0__l = left;
			let l = __anon0__l;
			let _hx_tmp;
			let _hx_tmp1;
			let _hx_tmp2;
			let _hx_tmp3;
			if(((right) instanceof types_base__$Integer) == true) {
				let __anon0__r = right;
				let r = __anon0__r;
				let res = runtime_actions_datatypes_IntegerActions.doMathOp(l.int,r.int,op,false);
				if(res % 1.0 != 0.0) {
					return new types_Float(res);
				} else {
					return this.makeThis(res);
				}
			} else {
				_hx_tmp3 = ((right) instanceof types_Money);
				if(_hx_tmp3 == true) {
					let __anon0__m = right;
					let m = __anon0__m;
					let value = runtime_Actions.ACTIONS.get(42);
					let tmp;
					if(value != null) {
						tmp = value;
					} else {
						throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
					}
					return tmp.doMath(runtime_actions_datatypes_MoneyActions.fromInteger(left),m,op);
				} else {
					_hx_tmp2 = ((right) instanceof types_base__$Float);
					if(_hx_tmp2 == true) {
						let __anon0__r = right;
						let r = __anon0__r;
						let value = runtime_Actions.ACTIONS.get(11);
						let tmp;
						if(value != null) {
							tmp = value;
						} else {
							throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
						}
						return tmp.doMath(l,r,op);
					} else {
						_hx_tmp1 = ((right) instanceof types_Pair);
						if(_hx_tmp1 == true) {
							let __anon0__r = right;
							let r = __anon0__r;
							let value = runtime_Actions.ACTIONS.get(33);
							let pairActions;
							if(value != null) {
								pairActions = value;
							} else {
								throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
							}
							if(op == 3) {
								throw haxe_Exception.thrown("not related");
							}
							if(op == 1) {
								r = pairActions.negate(r);
								op = 0;
							}
							return pairActions.doMath(r,l,op);
						} else {
							_hx_tmp = ((right) instanceof types_Tuple);
							if(_hx_tmp == true) {
								let __anon0__r = right;
								let r = __anon0__r;
								if(op == 1 || op == 3) {
									throw haxe_Exception.thrown("not related");
								}
								let value = runtime_Actions.ACTIONS.get(35);
								let tmp;
								if(value != null) {
									tmp = value;
								} else {
									throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
								}
								return tmp.doMath(r,l,op);
							} else {
								throw new runtime_actions_InvalidAction("Invalid action!");
							}
						}
					}
				}
			}
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
	}
	absolute(value) {
		return this.makeThis(Math.abs(value.int));
	}
	negate(value) {
		return this.makeThis(-value.int);
	}
	add(value1,value2) {
		return this.doMath(value1,value2,0);
	}
	subtract(value1,value2) {
		return this.doMath(value1,value2,1);
	}
	multiply(value1,value2) {
		return this.doMath(value1,value2,2);
	}
	divide(value1,value2) {
		return this.doMath(value1,value2,3);
	}
	remainder(value1,value2) {
		return this.doMath(value1,value2,4);
	}
	power(number,exponent) {
		let base = number.int;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2 = ((exponent) instanceof types_Integer) ? exponent : null;
		if(_hx_tmp2 == null) {
			_hx_tmp1 = ((exponent) instanceof types_Integer);
			if(_hx_tmp1 == true) {
				let __anon0__exp = exponent;
				let exp = __anon0__exp;
				return new types_Float(Math.pow(base,exp.asFloat()));
			} else {
				_hx_tmp = ((exponent) instanceof types_Float);
				if(_hx_tmp == true) {
					let __anon0__exp = exponent;
					let exp = __anon0__exp;
					return new types_Float(Math.pow(base,exp.asFloat()));
				} else {
					throw new runtime_actions_InvalidAction("Invalid action!");
				}
			}
		} else {
			let _g = _hx_tmp2.get_TYPE_KIND();
			let exp = _hx_tmp2.int;
			if(exp >= 0) {
				let res = 1;
				while(exp != 0) {
					if(exp & 1) {
						res *= base;
					}
					exp >>= 1;
					base *= base;
				}
				return new types_Integer(res);
			} else {
				_hx_tmp1 = ((exponent) instanceof types_Integer);
				if(_hx_tmp1 == true) {
					let __anon0__exp = exponent;
					let exp = __anon0__exp;
					return new types_Float(Math.pow(base,exp.asFloat()));
				} else {
					_hx_tmp = ((exponent) instanceof types_Float);
					if(_hx_tmp == true) {
						let __anon0__exp = exponent;
						let exp = __anon0__exp;
						return new types_Float(Math.pow(base,exp.asFloat()));
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
			}
		}
	}
	even_q(value) {
		if((value.int & 1) == 0) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
	odd_q(value) {
		if((value.int & 1) != 0) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
	round(value,options) {
		let tmp = options.to;
		let scale = tmp != null ? tmp.scale : null;
		let num = value.int;
		if(num == -2147483648) {
			return value;
		}
		let sc = 1;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(scale != null) {
			_hx_tmp2 = ((scale) instanceof types_Money);
			if(_hx_tmp2 == true) {
				let __anon0__m = scale;
				let m = __anon0__m;
				throw haxe_Exception.thrown("not related");
			} else {
				_hx_tmp1 = ((scale) instanceof types_base__$Float);
				if(_hx_tmp1 == true) {
					let __anon0__f = scale;
					let f = __anon0__f;
					throw haxe_Exception.thrown("TODO");
				} else {
					_hx_tmp = ((scale) instanceof types_Integer);
					if(_hx_tmp == true) {
						let __anon0__i = scale;
						let i = __anon0__i;
						sc = Math.abs(i.int);
					} else {
						throw haxe_Exception.thrown("bad");
					}
				}
			}
		}
		if(sc == 0) {
			return value;
		}
		let n = Math.abs(num);
		let r = n % sc;
		if(r == 0) {
			return value;
		}
		let s = sc - r;
		let m = n + s;
		let tmp1;
		if(options.down) {
			tmp1 = num > 0 ? n - r : r - n;
		} else if(options.floor) {
			if(m < 0) {
				throw haxe_Exception.thrown("math overflow");
			} else {
				tmp1 = num > 0 ? n - r : 0 - m;
			}
		} else if(options.ceiling) {
			if(m < 0) {
				throw haxe_Exception.thrown("math overflow");
			} else {
				tmp1 = num < 0 ? r - n : m;
			}
		} else if(r < s) {
			tmp1 = num > 0 ? n - r : r - n;
		} else if(r > s) {
			if(m < 0) {
				throw haxe_Exception.thrown("math overflow");
			} else {
				tmp1 = num > 0 ? m : 0 - m;
			}
		} else if(options.even) {
			if((Math.floor(n / sc) & 1) == 0) {
				tmp1 = num > 0 ? n - r : r - n;
			} else if(m < 0) {
				throw haxe_Exception.thrown("math overflow");
			} else {
				tmp1 = num > 0 ? m : 0 - m;
			}
		} else if(options.halfDown) {
			tmp1 = num > 0 ? n - r : r - n;
		} else if(options.halfCeiling) {
			if(m < 0) {
				throw haxe_Exception.thrown("math overflow");
			} else {
				tmp1 = num < 0 ? r - n : m;
			}
		} else if(m < 0) {
			throw haxe_Exception.thrown("math overflow");
		} else {
			tmp1 = num > 0 ? m : 0 - m;
		}
		return new types_Integer(tmp1);
	}
	complement(value) {
		return this.makeThis(~value.int);
	}
	and(value1,value2) {
		return this.doMath(value1,value2,6);
	}
	or(value1,value2) {
		return this.doMath(value1,value2,5);
	}
	xor(value1,value2) {
		return this.doMath(value1,value2,7);
	}
	static doMathOp(left,right,op,forceIntDiv) {
		switch(op) {
		case 0:
			return left + right;
		case 1:
			return left - right;
		case 2:
			return left * right;
		case 3:
			if(forceIntDiv || left % right == 0) {
				return left / right | 0;
			} else {
				return left / right;
			}
			break;
		case 4:
			return left % right;
		case 5:
			return left | right;
		case 6:
			return left & right;
		case 7:
			return left ^ right;
		default:
			throw haxe_Exception.thrown("bad");
		}
	}
}
runtime_actions_datatypes_IntegerActions.__name__ = true;
runtime_actions_datatypes_IntegerActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_IntegerActions.prototype, {
	__class__: runtime_actions_datatypes_IntegerActions
});
class runtime_actions_datatypes_CharActions extends runtime_actions_datatypes_IntegerActions {
	constructor() {
		super();
	}
	makeThis(i) {
		return types_Char.fromCode(i);
	}
	make(proto,spec) {
		return this.to(proto,spec);
	}
	to(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		if(((spec) instanceof types_Char) == true) {
			let __anon0__c = spec;
			let c = __anon0__c;
			return c;
		} else {
			_hx_tmp3 = ((spec) instanceof types_Integer);
			if(_hx_tmp3 == true) {
				let __anon0__i = spec;
				let i = __anon0__i;
				if(i.int > 1114111 || i.int < 0) {
					throw haxe_Exception.thrown("out of range");
				}
				return types_Char.fromCode(i.int);
			} else {
				_hx_tmp2 = ((spec) instanceof types_Float);
				if(_hx_tmp2 == true) {
					let __anon0__f = spec;
					let f = __anon0__f;
					let i = f.float | 0;
					if(i > 1114111 || i < 0) {
						throw haxe_Exception.thrown("out of range");
					}
					return types_Char.fromCode(i);
				} else {
					_hx_tmp1 = ((spec) instanceof types_Percent);
					if(_hx_tmp1 == true) {
						let __anon0__f = spec;
						let f = __anon0__f;
						let i = f.float | 0;
						if(i > 1114111 || i < 0) {
							throw haxe_Exception.thrown("out of range");
						}
						return types_Char.fromCode(i);
					} else {
						_hx_tmp = ((spec) instanceof types_base__$String);
						if(_hx_tmp == true) {
							let __anon0__s = spec;
							let s = __anon0__s;
							if(s.values.length - s.index == 0) {
								throw haxe_Exception.thrown("bad");
							}
							return types_Char.fromCode(s.values[s.index]);
						} else {
							throw new runtime_actions_InvalidAction("Invalid action!");
						}
					}
				}
			}
		}
	}
	form(value,buffer,arg,part) {
		buffer.values.push(value.int);
		return part - 1;
	}
	mold(value,buffer,_,isAll,_1,arg,part,_2) {
		buffer.appendLiteral("#\"");
		buffer.appendEscapedChar(value.int,true,isAll);
		buffer.values.push(34);
		return part - 4;
	}
	compare(value1,value2,op) {
		if((op == 11 || op == 2) && value2.constructor != value1.constructor) {
			return 1;
		}
		let other;
		if(((value2) instanceof types_base__$Integer) == true) {
			let __anon0__i = value2;
			let i = __anon0__i;
			other = i.int;
		} else {
			return -2;
		}
		return Math.sign((value1.int - other));
	}
	doMath(left,right,op) {
		if(((left) instanceof types_Char) == true) {
			let __anon0__l = left;
			let l = __anon0__l;
			let rv;
			let _hx_tmp;
			if(((right) instanceof types_base__$Integer) == true) {
				let __anon0__r = right;
				let r = __anon0__r;
				rv = r.int;
			} else {
				_hx_tmp = ((right) instanceof types_Float);
				if(_hx_tmp == true) {
					let __anon0__r = right;
					let r = __anon0__r;
					rv = r.float | 0;
				} else {
					throw new runtime_actions_InvalidAction("Invalid action!");
				}
			}
			let res = types_Char.fromCode(runtime_actions_datatypes_IntegerActions.doMathOp(l.int,rv,op,true));
			if(res.int > 1114111 || res.int <= 0) {
				throw haxe_Exception.thrown("math overflow");
			}
			return res;
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
	}
	negate(value) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	power(number,exponent) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	round(value,options) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
	complement(value) {
		throw new runtime_actions_InvalidAction("Invalid action!");
	}
}
runtime_actions_datatypes_CharActions.__name__ = true;
runtime_actions_datatypes_CharActions.__super__ = runtime_actions_datatypes_IntegerActions;
Object.assign(runtime_actions_datatypes_CharActions.prototype, {
	__class__: runtime_actions_datatypes_CharActions
});
class runtime_actions_datatypes_FloatActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	makeThis(f) {
		return new types_Float(f);
	}
	make(proto,spec) {
		return this.to(proto,spec);
	}
	to(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((spec) instanceof types_base__$Integer) == true) {
			let __anon0__i = spec;
			let i = __anon0__i;
			return this.makeThis(i.int);
		} else {
			_hx_tmp2 = ((spec) instanceof types_base__$Float);
			if(_hx_tmp2 == true) {
				let __anon0__f = spec;
				let f = __anon0__f;
				return this.makeThis(f.float);
			} else {
				_hx_tmp1 = ((spec) instanceof types_base__$String);
				if(_hx_tmp1 == true) {
					let __anon0__s = spec;
					let s = __anon0__s;
					let _g = Tokenizer.parse(s.toJs());
					if(_g.length == 1) {
						let _g1 = _g[0];
						let _hx_tmp;
						if(((_g1) instanceof types_Float) == true) {
							let __anon0__f = _g1;
							let f = __anon0__f;
							return f;
						} else {
							_hx_tmp = ((_g1) instanceof types_Percent);
							if(_hx_tmp == true) {
								let __anon0__f = _g1;
								let f = __anon0__f;
								return f;
							} else {
								throw haxe_Exception.thrown("Can't parse float! from \"" + s.toJs() + "\"");
							}
						}
					} else {
						throw haxe_Exception.thrown("Can't parse float! from \"" + s.toJs() + "\"");
					}
				} else {
					_hx_tmp = ((spec) instanceof types_base__$Block);
					if(_hx_tmp == true) {
						let __anon0__b = spec;
						let b = __anon0__b;
						if(b.values.length - b.index != 2) {
							throw new runtime_actions_InvalidAction("Invalid action!");
						}
						let _g = b.wrap(b.values[b.index]);
						let _hx_tmp;
						if(((_g) instanceof types_Float) == true) {
							let __anon0__n = _g;
							let n = __anon0__n;
							let _g1 = b.wrap(b.values[b.index + 1]);
							if(((_g1) instanceof types_Integer) == true) {
								let __anon0__i = _g1;
								let i = __anon0__i;
								return this.makeThis(n.asFloat() * Math.pow(10,i.int));
							} else {
								throw new runtime_actions_InvalidAction("Invalid action!");
							}
						} else {
							_hx_tmp = ((_g) instanceof types_Integer);
							if(_hx_tmp == true) {
								let __anon0__n = _g;
								let n = __anon0__n;
								let _g1 = b.wrap(b.values[b.index + 1]);
								if(((_g1) instanceof types_Integer) == true) {
									let __anon0__i = _g1;
									let i = __anon0__i;
									return this.makeThis(n.asFloat() * Math.pow(10,i.int));
								} else {
									throw new runtime_actions_InvalidAction("Invalid action!");
								}
							} else {
								throw new runtime_actions_InvalidAction("Invalid action!");
							}
						}
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
			}
		}
	}
	form(value,buffer,_,part) {
		let formed = runtime_actions_datatypes_FloatActions.formFloat(value);
		buffer.appendLiteral(formed);
		return part - formed.length;
	}
	mold(value,buffer,_,_1,_2,_3,part,_4) {
		let str;
		let _g = value.float;
		let _hx_tmp;
		let _hx_tmp1;
		if(_g == NaN == true) {
			str = "1.#NaN";
		} else {
			_hx_tmp1 = _g == Infinity;
			if(_hx_tmp1 == true) {
				str = "1.#Inf";
			} else {
				_hx_tmp = _g == -Infinity;
				if(_hx_tmp == true) {
					str = "-1.#Inf";
				} else {
					let s = _g.toString();
					str = s.includes(".") ? s : s + ".0";
				}
			}
		}
		buffer.appendLiteral(str);
		return part - str.length;
	}
	compare(value1,value2,op) {
		if((op == 11 || op == 2) && value2.constructor != value1.constructor) {
			return 1;
		}
		let other;
		let _hx_tmp;
		let _hx_tmp1;
		if(((value2) instanceof types_base__$Integer) == true) {
			let __anon0__i = value2;
			let i = __anon0__i;
			other = i.int;
		} else {
			_hx_tmp1 = ((value2) instanceof types_Money);
			if(_hx_tmp1 == true) {
				let __anon0__m = value2;
				let m = __anon0__m;
				let value = runtime_Actions.ACTIONS.get(42);
				let other;
				if(value != null) {
					other = value;
				} else {
					throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
				}
				return other.compare(runtime_actions_datatypes_MoneyActions.fromFloat(value1),m,op);
			} else {
				_hx_tmp = ((value2) instanceof types_base__$Float);
				if(_hx_tmp == true) {
					let __anon0__f = value2;
					let f = __anon0__f;
					other = f.float;
				} else {
					return -2;
				}
			}
		}
		let f = value1.float;
		switch(op) {
		case 0:case 1:
			if(isNaN(f) || isNaN(other)) {
				return 1;
			} else if(f < other) {
				return -1;
			} else if(f > other) {
				return 1;
			} else {
				return 0;
			}
			break;
		case 2:
			if(f == other) {
				return 0;
			} else {
				return 1;
			}
			break;
		case 9:
			if(isNaN(f) && isNaN(other) || f == other) {
				return 0;
			} else {
				return 1;
			}
			break;
		default:
			if(f < other) {
				return -1;
			} else if(f > other) {
				return 1;
			} else {
				return 0;
			}
		}
	}
	doMath(left,right,op) {
		if(!((left) instanceof types_base__$Number)) {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
		let _hx_tmp;
		let _hx_tmp1;
		if(((right) instanceof types_Tuple) == true) {
			let value = runtime_Actions.ACTIONS.get(35);
			let tmp;
			if(value != null) {
				tmp = value;
			} else {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			return tmp.doMath(left,right,op);
		} else {
			_hx_tmp1 = ((right) instanceof types_Money);
			if(_hx_tmp1 == true) {
				let __anon0__m = right;
				let m = __anon0__m;
				let value = runtime_Actions.ACTIONS.get(42);
				let tmp;
				if(value != null) {
					tmp = value;
				} else {
					throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
				}
				return tmp.doMath(runtime_actions_datatypes_MoneyActions.fromFloat(left),m,op);
			} else {
				_hx_tmp = ((right) instanceof types_Pair);
				if(_hx_tmp == true) {
					if(!((left) instanceof types_Time)) {
						if(op == 1 || op == 3) {
							throw haxe_Exception.thrown("not related");
						}
						let value = runtime_Actions.ACTIONS.get(33);
						let tmp;
						if(value != null) {
							tmp = value;
						} else {
							throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
						}
						return tmp.doMath(right,left,op);
					}
				}
			}
		}
		if(!((right) instanceof types_base__$Number) || (((left) instanceof types_Time) || ((left) instanceof types_Percent)) && ((right) instanceof types_Char)) {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
		let isPct = ((left) instanceof types_Percent) && !((right) instanceof types_Percent);
		let op1 = left.asFloat();
		let op2 = right.asFloat();
		let isT1 = ((left) instanceof types_Time) && !((right) instanceof types_Time);
		let isT2 = !((left) instanceof types_Time) && ((right) instanceof types_Time);
		let res = runtime_actions_datatypes_FloatActions.doMathOp(op1,op2,op);
		if(isT1 || isT2) {
			return new types_Time(res);
		} else if(isPct && !isT2) {
			return new types_Percent(res);
		} else {
			return this.makeThis(res);
		}
	}
	absolute(value) {
		return this.makeThis(Math.abs(value.float));
	}
	negate(value) {
		return this.makeThis(-value.float);
	}
	add(value1,value2) {
		return this.doMath(value1,value2,0);
	}
	subtract(value1,value2) {
		return this.doMath(value1,value2,1);
	}
	multiply(value1,value2) {
		return this.doMath(value1,value2,2);
	}
	divide(value1,value2) {
		return this.doMath(value1,value2,3);
	}
	remainder(value1,value2) {
		return this.doMath(value1,value2,4);
	}
	power(number,exponent) {
		let exp;
		let _hx_tmp;
		if(((exponent) instanceof types_Integer) == true) {
			let __anon0__i = exponent;
			let i = __anon0__i;
			exp = i.int;
		} else {
			_hx_tmp = ((exponent) instanceof types_Float);
			if(_hx_tmp == true) {
				let __anon0__f = exponent;
				let f = __anon0__f;
				exp = f.float;
			} else {
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
		}
		return this.makeThis(Math.pow(number.float,exp));
	}
	even_q(value) {
		if(((value.float | 0) & 1) == 0) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
	odd_q(value) {
		if(((value.float | 0) & 1) != 0) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
	round(value,options) {
		let tmp = options.to;
		let scale = tmp != null ? tmp.scale : null;
		let e = 0;
		let dec = value.float;
		let sc = ((value) instanceof types_Percent) ? 0.01 : 1.0;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(scale != null) {
			_hx_tmp2 = ((scale) instanceof types_Money);
			if(_hx_tmp2 == true) {
				throw haxe_Exception.thrown("not related");
			} else {
				_hx_tmp1 = ((scale) instanceof types_Integer);
				if(_hx_tmp1 == true) {
					let __anon0__i = scale;
					let i = __anon0__i;
					sc = Math.abs(i.int);
					if(((value) instanceof types_Percent)) {
						sc /= 100;
					}
				} else {
					_hx_tmp = ((scale) instanceof types_base__$Float);
					if(_hx_tmp == true) {
						let __anon0__f = scale;
						let f = __anon0__f;
						sc = Math.abs(f.float);
						if(((value) instanceof types_Percent)) {
							sc /= 100;
						}
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
			}
		}
		if(sc < util_MathTools._ldexp(Math.abs(dec),-53)) {
			return value;
		}
		let v = sc >= 1.0;
		if(v) {
			dec /= sc;
		} else {
			let r;
			/*;
			r = */ //;
			[r, e] = util_MathTools._frexp(sc);
			if(e <= -1022) {
				sc = r;
				dec = util_MathTools._ldexp(dec,e);
			} else {
				e = 0;
			}
			sc = 1.0 / sc;
			dec *= sc;
		}
		let d = Math.abs(dec);
		let r = 0.5 + Math.floor(d);
		dec = options.down ? Math.trunc(dec) : options.floor ? Math.floor(dec) : options.ceiling ? Math.ceil(dec) : r < d ? util_MathTools._away(dec) : r > d ? Math.trunc(dec) : options.even ? d % 2.0 < 1.0 ? Math.trunc(dec) : util_MathTools._away(dec) : options.halfDown ? Math.trunc(dec) : options.halfCeiling ? Math.ceil(dec) : util_MathTools._away(dec);
		let f;
		if(v) {
			dec *= sc;
			f = dec;
		} else {
			f = util_MathTools._ldexp(dec / sc,e);
		}
		let _hx_tmp3;
		if(scale == null) {
			return this.makeThis(f);
		} else {
			_hx_tmp3 = ((scale) instanceof types_Integer);
			if(_hx_tmp3 == true) {
				return new types_Integer(dec | 0);
			} else {
				return scale.make(dec);
			}
		}
	}
	static formFloat(f) {
		let d = f.float;
		if(d == NaN) {
			return "1.#NaN";
		} else if(d == -Infinity) {
			return "-1.#Inf";
		} else if(d == Infinity) {
			return "1.#Inf";
		}
		let isPercent = ((f) instanceof types_Percent);
		if(isPercent) {
			d *= 100;
		}
		let s = d.toString();
		if(isPercent) {
			s += "%";
		} else if(!s.includes(".")) {
			s += ".0";
		}
		return s;
	}
	static doMathOp(left,right,op) {
		switch(op) {
		case 0:
			return left + right;
		case 1:
			return left - right;
		case 2:
			return left * right;
		case 3:
			return left / right;
		case 4:
			return left % right;
		default:
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
	}
}
runtime_actions_datatypes_FloatActions.__name__ = true;
runtime_actions_datatypes_FloatActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_FloatActions.prototype, {
	__class__: runtime_actions_datatypes_FloatActions
});
class types_base__$Word extends Value {
	constructor(symbol,context,index) {
		super();
		this.symbol = symbol;
		if(context == null) {
			this.context = types_base_Context.GLOBAL;
			this.index = types_base_Context.GLOBAL.addWord(this);
		} else {
			this.context = context;
			this.index = index != null ? index : context.addSymbol(symbol);
		}
	}
	get(optional) {
		if(optional == null) {
			optional = false;
		}
		let value = this.context.getWord(this);
		if(value == types_Unset.UNSET && !optional) {
			throw haxe_Exception.thrown("Word `" + this.symbol.name + "` doesn't exist!");
		} else {
			return value;
		}
	}
	set(value) {
		this.context.addOrSetWord(this,value,true);
	}
	equalsString(str,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		return this.symbol.equalsString(str,ignoreCase);
	}
	equalsSymbol(sym,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		return this.symbol.equalsSymbol(sym,ignoreCase);
	}
}
types_base__$Word.__name__ = true;
types_base__$Word.__super__ = Value;
Object.assign(types_base__$Word.prototype, {
	__class__: types_base__$Word
});
class types_base__$AnyWord extends types_base__$Word {
	constructor(symbol,context,index) {
		super(symbol,context,index);
	}
}
types_base__$AnyWord.__name__ = true;
types_base__$AnyWord.__super__ = types_base__$Word;
Object.assign(types_base__$AnyWord.prototype, {
	__class__: types_base__$AnyWord
});
class types_Word extends types_base__$AnyWord {
	constructor(symbol,context,index) {
		super(symbol,context,index);
	}
	copyIn(context,index) {
		return new types_Word(this.symbol,context,index);
	}
	copyFrom(word) {
		return new types_Word(word.symbol,word.context,word.index);
	}
	get_TYPE_KIND() {
		return 12;
	}
}
types_Word.__name__ = true;
types_Word.__super__ = types_base__$AnyWord;
Object.assign(types_Word.prototype, {
	__class__: types_Word
});
class runtime_actions_datatypes_WordActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	make(proto,spec) {
		return this.to(proto,spec);
	}
	to(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		let _hx_tmp4;
		if(((spec) instanceof types_base__$AnyWord) == true) {
			let __anon0__w = spec;
			let w = __anon0__w;
			return new this.constructor.thisType(w.symbol,w.context,w.index);
		} else {
			_hx_tmp4 = ((spec) instanceof types_Refinement);
			if(_hx_tmp4 == true) {
				let __anon0__w = spec;
				let w = __anon0__w;
				throw haxe_Exception.thrown("NYI");
			} else {
				_hx_tmp3 = ((spec) instanceof types_Issue);
				if(_hx_tmp3 == true) {
					let __anon0__w = spec;
					let w = __anon0__w;
					throw haxe_Exception.thrown("NYI");
				} else {
					_hx_tmp2 = ((spec) instanceof types_base__$String);
					if(_hx_tmp2 == true) {
						let __anon0__s = spec;
						let s = __anon0__s;
						let _g = Tokenizer.parse(s.toJs());
						if(_g.length == 1) {
							let _g1 = _g[0];
							if(((_g1) instanceof types_base__$Word) == true) {
								let __anon0__w = _g1;
								let w = __anon0__w;
								if(w.constructor == runtime_actions_datatypes_WordActions.thisType) {
									return w;
								} else {
									return new this.constructor.thisType(w.symbol,w.context,w.index);
								}
							} else {
								throw haxe_Exception.thrown("Can't parse time! from \"" + s.toJs() + "\"");
							}
						} else {
							throw haxe_Exception.thrown("Can't parse time! from \"" + s.toJs() + "\"");
						}
					} else {
						_hx_tmp1 = ((spec) instanceof types_Datatype);
						if(_hx_tmp1 == true) {
							let __anon0__d = spec;
							let d = __anon0__d;
							let word = types_base_Context.GLOBAL.getSymbol(d.name);
							if(((word) instanceof this.constructor.thisType)) {
								return word;
							} else {
								return new this.constructor.thisType(word.symbol,word.context,word.index);
							}
						} else {
							_hx_tmp = ((spec) instanceof types_Logic);
							if(_hx_tmp == true) {
								let __anon0__l = spec;
								let l = __anon0__l;
								let word = types_base_Context.GLOBAL.getSymbol(l.cond ? "true" : "false");
								if(((word) instanceof this.constructor.thisType)) {
									return word;
								} else {
									return new this.constructor.thisType(word.symbol,word.context,word.index);
								}
							} else {
								throw haxe_Exception.thrown("bad");
							}
						}
					}
				}
			}
		}
	}
	form(value,buffer,arg,part) {
		let name = value.symbol.name;
		buffer.appendLiteral(name);
		return part - name.length;
	}
	mold(value,buffer,_,_1,_2,arg,part,_3) {
		return this.form(value,buffer,arg,part);
	}
	compare(value1,value2,op) {
		if(((value2) instanceof types_Issue) && !((value1) instanceof types_Issue) || !((value2) instanceof types_base__$Word)) {
			return -2;
		}
		let other = value2;
		switch(op) {
		case 2:
			return +((value1.constructor != other.constructor || value1.symbol != other.symbol));
		case 9:
			return +((value1.symbol != other.symbol || value1.context != other.context || value1.constructor != other.constructor));
		case 10:
			if(((value1) instanceof types_Word) && ((other) instanceof types_LitWord) || ((value1) instanceof types_LitWord) && ((other) instanceof types_Word)) {
				return +((value1.symbol != other.symbol));
			} else {
				return +((value1.constructor != other.constructor || value1.symbol != other.symbol));
			}
			break;
		case 0:case 1:case 11:
			return +((!value1.symbol.equalsSymbol(other.symbol)));
		default:
			let str1 = value1.symbol.name.toUpperCase();
			let str2 = other.symbol.name.toUpperCase();
			if(str1 == str2) {
				return 0;
			} else if(str1 < str2) {
				return -1;
			} else {
				return 1;
			}
		}
	}
	index_q(word) {
		if(word.index == -1) {
			return types_None.NONE;
		} else {
			return new types_Integer(word.index + 1);
		}
	}
}
runtime_actions_datatypes_WordActions.__name__ = true;
runtime_actions_datatypes_WordActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_WordActions.prototype, {
	__class__: runtime_actions_datatypes_WordActions
});
class types_SetWord extends types_base__$AnyWord {
	constructor(symbol,context,index) {
		super(symbol,context,index);
	}
	copyIn(context,index) {
		return new types_SetWord(this.symbol,context,index);
	}
	copyFrom(word) {
		return new types_SetWord(word.symbol,word.context,word.index);
	}
	get_TYPE_KIND() {
		return 13;
	}
}
types_SetWord.__name__ = true;
types_SetWord.__super__ = types_base__$AnyWord;
Object.assign(types_SetWord.prototype, {
	__class__: types_SetWord
});
class runtime_actions_datatypes_SetWordActions extends runtime_actions_datatypes_WordActions {
	constructor() {
		super();
	}
	mold(value,buffer,_,_1,_2,arg,part,_3) {
		part = this.form(value,buffer,arg,part);
		buffer.values.push(58);
		return part - 1;
	}
}
runtime_actions_datatypes_SetWordActions.__name__ = true;
runtime_actions_datatypes_SetWordActions.__super__ = runtime_actions_datatypes_WordActions;
Object.assign(runtime_actions_datatypes_SetWordActions.prototype, {
	__class__: runtime_actions_datatypes_SetWordActions
});
class types_LitWord extends types_base__$AnyWord {
	constructor(symbol,context,index) {
		super(symbol,context,index);
	}
	copyIn(context,index) {
		return new types_LitWord(this.symbol,context,index);
	}
	copyFrom(word) {
		return new types_LitWord(word.symbol,word.context,word.index);
	}
	get_TYPE_KIND() {
		return 14;
	}
}
types_LitWord.__name__ = true;
types_LitWord.__super__ = types_base__$AnyWord;
Object.assign(types_LitWord.prototype, {
	__class__: types_LitWord
});
class runtime_actions_datatypes_LitWordActions extends runtime_actions_datatypes_WordActions {
	constructor() {
		super();
	}
	mold(value,buffer,_,_1,_2,arg,part,_3) {
		buffer.values.push(39);
		return this.form(value,buffer,arg,part - 1);
	}
}
runtime_actions_datatypes_LitWordActions.__name__ = true;
runtime_actions_datatypes_LitWordActions.__super__ = runtime_actions_datatypes_WordActions;
Object.assign(runtime_actions_datatypes_LitWordActions.prototype, {
	__class__: runtime_actions_datatypes_LitWordActions
});
class types_GetWord extends types_base__$AnyWord {
	constructor(symbol,context,index) {
		super(symbol,context,index);
	}
	copyIn(context,index) {
		return new types_GetWord(this.symbol,context,index);
	}
	copyFrom(word) {
		return new types_GetWord(word.symbol,word.context,word.index);
	}
	get_TYPE_KIND() {
		return 15;
	}
}
types_GetWord.__name__ = true;
types_GetWord.__super__ = types_base__$AnyWord;
Object.assign(types_GetWord.prototype, {
	__class__: types_GetWord
});
class runtime_actions_datatypes_GetWordActions extends runtime_actions_datatypes_WordActions {
	constructor() {
		super();
	}
	mold(value,buffer,_,_1,_2,arg,part,_3) {
		buffer.values.push(58);
		return this.form(value,buffer,arg,part - 1);
	}
}
runtime_actions_datatypes_GetWordActions.__name__ = true;
runtime_actions_datatypes_GetWordActions.__super__ = runtime_actions_datatypes_WordActions;
Object.assign(runtime_actions_datatypes_GetWordActions.prototype, {
	__class__: runtime_actions_datatypes_GetWordActions
});
class runtime_actions_datatypes_RefinementActions extends runtime_actions_datatypes_WordActions {
	constructor() {
		super();
	}
	mold(value,buffer,_,_1,_2,arg,part,_3) {
		buffer.values.push(47);
		return this.form(value,buffer,arg,part - 1);
	}
}
runtime_actions_datatypes_RefinementActions.__name__ = true;
runtime_actions_datatypes_RefinementActions.__super__ = runtime_actions_datatypes_WordActions;
Object.assign(runtime_actions_datatypes_RefinementActions.prototype, {
	__class__: runtime_actions_datatypes_RefinementActions
});
class types_Issue extends types_base__$Word {
	constructor(symbol,_,_1) {
		super(symbol,types_base_Context.GLOBAL,-1);
	}
	copyIn(context,index) {
		return this;
	}
	copyFrom(word) {
		return new types_Issue(word.symbol);
	}
	get_TYPE_KIND() {
		return 17;
	}
}
types_Issue.__name__ = true;
types_Issue.__super__ = types_base__$Word;
Object.assign(types_Issue.prototype, {
	__class__: types_Issue
});
class runtime_actions_datatypes_IssueActions extends runtime_actions_datatypes_WordActions {
	constructor() {
		super();
	}
	to(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		if(((spec) instanceof types_base__$Word) == true) {
			let __anon0__w = spec;
			let w = __anon0__w;
			return new this.constructor.thisType(w.symbol,w.context,w.index);
		} else {
			_hx_tmp1 = ((spec) instanceof types_String);
			if(_hx_tmp1 == true) {
				let __anon0__s = spec;
				let s = __anon0__s;
				let sym = types_base_Symbol.make(s.toJs());
				return new this.constructor.thisType(sym,types_base_Context.GLOBAL,-1);
			} else {
				_hx_tmp = ((spec) instanceof types_Char);
				if(_hx_tmp == true) {
					let __anon0__c = spec;
					let c = __anon0__c;
					let code = c.int;
					let sym = types_base_Symbol.make(String.fromCodePoint(code));
					return new this.constructor.thisType(sym,types_base_Context.GLOBAL,-1);
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
		}
	}
	mold(value,buffer,_,_1,_2,arg,part,_3) {
		buffer.values.push(35);
		return this.form(value,buffer,arg,part - 1);
	}
	compare(value1,value2,op) {
		if(!((value2) instanceof types_Issue)) {
			return -2;
		}
		return super.compare(value1,value2,op);
	}
}
runtime_actions_datatypes_IssueActions.__name__ = true;
runtime_actions_datatypes_IssueActions.__super__ = runtime_actions_datatypes_WordActions;
Object.assign(runtime_actions_datatypes_IssueActions.prototype, {
	__class__: runtime_actions_datatypes_IssueActions
});
class runtime_actions_datatypes__$IFunctionActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	reflect(value,field) {
		let _g = field.symbol;
		let _hx_tmp;
		let _hx_tmp1;
		if(_g == runtime_Words.SPEC == true) {
			return value.get_origSpec();
		} else {
			_hx_tmp1 = _g == runtime_Words.BODY;
			if(_hx_tmp1 == true) {
				if(((value) instanceof types_Op)) {
					value = value.fn;
				}
				let _hx_tmp;
				let _hx_tmp1;
				if(((value) instanceof types_Function) == true) {
					let __anon0__f = value;
					let f = __anon0__f;
					return f.body;
				} else {
					_hx_tmp1 = ((value) instanceof types_Native);
					if(_hx_tmp1 == true) {
						let __anon0__n = value;
						let n = __anon0__n;
						return new types_Integer(n.fn[1] + 1);
					} else {
						_hx_tmp = ((value) instanceof types_Action);
						if(_hx_tmp == true) {
							let __anon0__a = value;
							let a = __anon0__a;
							return new types_Integer(a.fn[1] + 1);
						} else {
							throw haxe_Exception.thrown("bad");
						}
					}
				}
			} else {
				_hx_tmp = _g == runtime_Words.WORDS;
				if(_hx_tmp == true) {
					throw haxe_Exception.thrown("NYI");
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
		}
	}
}
runtime_actions_datatypes__$IFunctionActions.__name__ = true;
runtime_actions_datatypes__$IFunctionActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes__$IFunctionActions.prototype, {
	__class__: runtime_actions_datatypes__$IFunctionActions
});
class runtime_actions_datatypes_NativeActions extends runtime_actions_datatypes__$IFunctionActions {
	constructor() {
		super();
	}
	make(_,spec) {
		let _g = (js_Boot.__cast(spec , types_Block)).values;
		if(_g.length == 3) {
			let _g1 = _g[0];
			let _g2 = _g[1];
			let _g3 = _g[2];
			if(((_g1) instanceof types_Block) == true) {
				let _hx_tmp = ((_g2) instanceof types_Issue) ? _g2 : null;
				if(_hx_tmp == null) {
					throw haxe_Exception.thrown("Match error!");
				} else {
					let _g = _hx_tmp.get_TYPE_KIND();
					let _g2 = _hx_tmp.context;
					let _g4 = _hx_tmp.symbol;
					let _g5 = _hx_tmp.index;
					let _g6 = types_base_Symbol.INDEXES.get(_g4.name);
					if(_g4.name == "get-definition") {
						let _hx_tmp = ((_g3) instanceof types_Word) ? _g3 : null;
						if(_hx_tmp == null) {
							throw haxe_Exception.thrown("Match error!");
						} else {
							let _g = _hx_tmp.get_TYPE_KIND();
							let _g2 = _hx_tmp.context;
							let _g3 = _hx_tmp.symbol;
							let _g4 = _hx_tmp.index;
							let _g5 = types_base_Symbol.INDEXES.get(_g3.name);
							let __anon0__s = _g1;
							let name = _g3.name;
							let s = __anon0__s;
							let _g6 = runtime_natives_Func.parseSpec(s);
							let doc = _g6.doc;
							let params = _g6.params;
							let refines = _g6.refines;
							let ret = _g6.ret;
							let tmp;
							if(runtime_actions_datatypes_NativeActions.MAPPINGS.has(name)) {
								tmp = runtime_actions_datatypes_NativeActions.MAPPINGS.get(name);
							} else {
								throw haxe_Exception.thrown("NYI");
							}
							return new types_Native(s,doc,params,refines,ret,tmp);
						}
					} else {
						throw haxe_Exception.thrown("Match error!");
					}
				}
			} else {
				throw haxe_Exception.thrown("Match error!");
			}
		} else {
			throw haxe_Exception.thrown("Match error!");
		}
	}
	form(value,buffer,arg,part) {
		buffer.appendLiteral("?native?");
		return part - 8;
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		buffer.appendLiteral("make native! [");
		let value1 = value.get_origSpec();
		if(value1 == null) {
			value1 = types_Tag.fromString("null");
		}
		let value2 = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
		if(value2 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		part = value2.mold(value1,buffer,isOnly,isAll,isFlat,arg,part - 14,indent);
		buffer.values.push(93);
		return part - 1;
	}
	compare(value1,value2,op) {
		if(((value2) instanceof types_Native) == true) {
			let __anon0__other = value2;
			let other = __anon0__other;
			switch(op) {
			case 0:case 1:case 2:case 7:case 8:case 9:case 11:
				if(value1 == other) {
					return 0;
				} else {
					return -1;
				}
				break;
			default:
				return -2;
			}
		} else {
			return -2;
		}
	}
}
runtime_actions_datatypes_NativeActions.__name__ = true;
runtime_actions_datatypes_NativeActions.__super__ = runtime_actions_datatypes__$IFunctionActions;
Object.assign(runtime_actions_datatypes_NativeActions.prototype, {
	__class__: runtime_actions_datatypes_NativeActions
});
class runtime_actions_datatypes_ActionActions extends runtime_actions_datatypes__$IFunctionActions {
	constructor() {
		super();
	}
	make(_,spec) {
		let _g = (js_Boot.__cast(spec , types_Block)).values;
		if(_g.length == 3) {
			let _g1 = _g[0];
			let _g2 = _g[1];
			let _g3 = _g[2];
			if(((_g1) instanceof types_Block) == true) {
				let _hx_tmp = ((_g2) instanceof types_Issue) ? _g2 : null;
				if(_hx_tmp == null) {
					throw haxe_Exception.thrown("Match error!");
				} else {
					let _g = _hx_tmp.get_TYPE_KIND();
					let _g2 = _hx_tmp.context;
					let _g4 = _hx_tmp.symbol;
					let _g5 = _hx_tmp.index;
					let _g6 = types_base_Symbol.INDEXES.get(_g4.name);
					if(_g4.name == "get-definition") {
						let _hx_tmp = ((_g3) instanceof types_Word) ? _g3 : null;
						if(_hx_tmp == null) {
							throw haxe_Exception.thrown("Match error!");
						} else {
							let _g = _hx_tmp.get_TYPE_KIND();
							let _g2 = _hx_tmp.context;
							let _g3 = _hx_tmp.symbol;
							let _g4 = _hx_tmp.index;
							let _g5 = types_base_Symbol.INDEXES.get(_g3.name);
							let __anon0__s = _g1;
							let name = _g3.name;
							let s = __anon0__s;
							let _g6 = runtime_natives_Func.parseSpec(s);
							let doc = _g6.doc;
							let params = _g6.params;
							let refines = _g6.refines;
							let ret = _g6.ret;
							let tmp;
							if(runtime_actions_datatypes_ActionActions.MAPPINGS.has(name)) {
								tmp = runtime_actions_datatypes_ActionActions.MAPPINGS.get(name);
							} else {
								throw haxe_Exception.thrown("NYI");
							}
							return new types_Action(s,doc,params,refines,ret,tmp);
						}
					} else {
						throw haxe_Exception.thrown("Match error!");
					}
				}
			} else {
				throw haxe_Exception.thrown("Match error!");
			}
		} else {
			throw haxe_Exception.thrown("Match error!");
		}
	}
	form(value,buffer,arg,part) {
		buffer.appendLiteral("?action?");
		return part - 8;
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		buffer.appendLiteral("make action! [");
		let value1 = value.get_origSpec();
		if(value1 == null) {
			value1 = types_Tag.fromString("null");
		}
		let value2 = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
		if(value2 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		part = value2.mold(value1,buffer,isOnly,isAll,isFlat,arg,part - 14,indent);
		buffer.values.push(93);
		return part - 1;
	}
	compare(value1,value2,op) {
		if(((value2) instanceof types_Action) == true) {
			let __anon0__other = value2;
			let other = __anon0__other;
			switch(op) {
			case 0:case 1:case 2:case 7:case 8:case 9:case 11:
				if(value1 == other) {
					return 0;
				} else {
					return -1;
				}
				break;
			default:
				return -2;
			}
		} else {
			return -2;
		}
	}
}
runtime_actions_datatypes_ActionActions.__name__ = true;
runtime_actions_datatypes_ActionActions.__super__ = runtime_actions_datatypes__$IFunctionActions;
Object.assign(runtime_actions_datatypes_ActionActions.prototype, {
	__class__: runtime_actions_datatypes_ActionActions
});
class runtime_actions_datatypes_OpActions extends runtime_actions_datatypes__$IFunctionActions {
	constructor() {
		super();
	}
	make(_,spec) {
		if(((spec) instanceof types_base__$Function) == true) {
			let __anon0__fn = spec;
			let fn = __anon0__fn;
			return new types_Op(fn);
		} else {
			throw haxe_Exception.thrown("bad");
		}
	}
	form(value,buffer,arg,part) {
		buffer.appendLiteral("?op?");
		return part - 4;
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		buffer.appendLiteral("make op! [");
		part -= 9;
		let hasBody = ((value.fn) instanceof types_Function);
		let pre = hasBody ? "func " : "[";
		buffer.appendLiteral(pre);
		part -= pre.length;
		let value1 = value.get_origSpec();
		if(value1 == null) {
			value1 = types_Tag.fromString("null");
		}
		let value2 = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
		if(value2 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		part = value2.mold(value1,buffer,isOnly,isAll,isFlat,arg,part,indent);
		if(hasBody) {
			let value1 = value.fn.body;
			if(value1 == null) {
				value1 = types_Tag.fromString("null");
			}
			let value2 = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
			if(value2 == null) {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			part = value2.mold(value1,buffer,false,isAll,isFlat,arg,part,indent);
		} else {
			buffer.values.push(93);
			--part;
		}
		return part;
	}
	compare(value1,value2,op) {
		if(((value2) instanceof types_Op) == true) {
			let __anon0__other = value2;
			let other = __anon0__other;
			switch(op) {
			case 0:case 1:case 2:case 7:case 8:case 9:case 11:
				if(value1.fn == other.fn) {
					return 0;
				} else {
					return -1;
				}
				break;
			default:
				return -2;
			}
		} else {
			return -2;
		}
	}
}
runtime_actions_datatypes_OpActions.__name__ = true;
runtime_actions_datatypes_OpActions.__super__ = runtime_actions_datatypes__$IFunctionActions;
Object.assign(runtime_actions_datatypes_OpActions.prototype, {
	__class__: runtime_actions_datatypes_OpActions
});
class runtime_actions_datatypes_FunctionActions extends runtime_actions_datatypes__$IFunctionActions {
	constructor() {
		super();
	}
	make(_,spec) {
		if(((spec) instanceof types_Block) == true) {
			let __anon0__block = spec;
			let block = __anon0__block;
			if(block.values.length - block.index < 2) {
				throw haxe_Exception.thrown("invalid spec");
			} else {
				let _g = block.wrap(block.values[block.index]);
				let _g1 = block.wrap(block.values[block.index + 1]);
				if(((_g) instanceof types_Block) == true) {
					if(((_g1) instanceof types_Block) == true) {
						let __anon0__spec2 = _g;
						let __anon1__body = _g1;
						let spec2 = __anon0__spec2;
						let body = __anon1__body;
						return runtime_natives_Func.call(spec2,body);
					} else {
						throw haxe_Exception.thrown("invalid spec");
					}
				} else {
					throw haxe_Exception.thrown("invalid spec");
				}
			}
		} else {
			throw haxe_Exception.thrown("invalid spec");
		}
	}
	reflect(value,field) {
		let _g = field.symbol;
		let _hx_tmp;
		let _hx_tmp1;
		if(_g == runtime_Words.SPEC == true) {
			return value.get_origSpec();
		} else {
			_hx_tmp1 = _g == runtime_Words.BODY;
			if(_hx_tmp1 == true) {
				return value.body;
			} else {
				_hx_tmp = _g == runtime_Words.WORDS;
				if(_hx_tmp == true) {
					let _g = [];
					let _g1 = 0;
					let _g2 = value.ctx.symbols;
					while(_g1 < _g2.length) {
						let sym = _g2[_g1];
						++_g1;
						_g.push(((sym) instanceof types_Word) ? sym : new types_Word(sym.symbol,sym.context,sym.index));
					}
					return new types_Block(_g);
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
		}
	}
	form(value,buffer,arg,part) {
		buffer.appendLiteral("?function?");
		return part - 10;
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		buffer.appendLiteral("func ");
		let value1 = value.get_origSpec();
		if(value1 == null) {
			value1 = types_Tag.fromString("null");
		}
		let value2 = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
		if(value2 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		part = value2.mold(value1,buffer,false,isAll,isFlat,arg,part - 5,indent);
		let value3 = value.body;
		if(value3 == null) {
			value3 = types_Tag.fromString("null");
		}
		let value4 = runtime_Actions.ACTIONS.get(value3.get_TYPE_KIND());
		if(value4 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value4.mold(value3,buffer,false,isAll,isFlat,arg,part,indent);
	}
	compare(value1,value2,op) {
		if(((value2) instanceof types_Function) == true) {
			let __anon0__other = value2;
			let other = __anon0__other;
			switch(op) {
			case 0:case 1:case 2:case 7:case 8:case 9:case 11:
				if(value1 == other) {
					return 0;
				} else {
					return -1;
				}
				break;
			default:
				return -2;
			}
		} else {
			return -2;
		}
	}
}
runtime_actions_datatypes_FunctionActions.__name__ = true;
runtime_actions_datatypes_FunctionActions.__super__ = runtime_actions_datatypes__$IFunctionActions;
Object.assign(runtime_actions_datatypes_FunctionActions.prototype, {
	__class__: runtime_actions_datatypes_FunctionActions
});
class runtime_actions_datatypes_PathActions extends runtime_actions_datatypes__$BlockLikeActions {
	constructor() {
		super();
	}
	makeThis(values,index) {
		return new types_Path(values,index);
	}
	make(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((spec) instanceof types_Integer) == true) {
			return this.makeThis([]);
		} else {
			_hx_tmp2 = typeof(spec) == "number";
			if(_hx_tmp2 == true) {
				return this.makeThis([]);
			} else {
				_hx_tmp1 = ((spec) instanceof types_base__$BlockLike);
				if(_hx_tmp1 == true) {
					let __anon0__b = spec;
					let b = __anon0__b;
					return this.makeThis(b.cloneValues(),0);
				} else {
					_hx_tmp = ((spec) instanceof types_Object);
					if(_hx_tmp == true) {
						let __anon0__o = spec;
						let o = __anon0__o;
						return this.makeThis(runtime_actions_datatypes_ObjectActions._reflect(o,runtime_Words.BODY).values);
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
			}
		}
	}
	to(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((spec) instanceof types_Object) == true) {
			let __anon0__o = spec;
			let o = __anon0__o;
			return this.makeThis(runtime_actions_datatypes_ObjectActions._reflect(o,runtime_Words.BODY).values);
		} else {
			_hx_tmp2 = ((spec) instanceof types_String);
			if(_hx_tmp2 == true) {
				let __anon0__s = spec;
				let s = __anon0__s;
				return this.makeThis(Tokenizer.parse(s.toJs()));
			} else {
				_hx_tmp1 = ((spec) instanceof types_Typeset);
				if(_hx_tmp1 == true) {
					let __anon0__t = spec;
					let t = __anon0__t;
					let _g = [];
					let jsIterator = t.types.values();
					let _g_jsIterator = jsIterator;
					let _g_lastStep = jsIterator.next();
					while(!_g_lastStep.done) {
						let v = _g_lastStep.value;
						_g_lastStep = _g_jsIterator.next();
						let value = v;
						_g.push(value);
					}
					return this.makeThis(_g);
				} else {
					_hx_tmp = ((spec) instanceof types_base__$BlockLike);
					if(_hx_tmp == true) {
						let __anon0__b = spec;
						let b = __anon0__b;
						return this.makeThis(b.cloneValues(),0);
					} else {
						return this.makeThis([spec]);
					}
				}
			}
		}
	}
	form(value,buffer,arg,part) {
		let cycle;
		/*;
		cycle = */ //;
		[part, cycle] = Cycles.detect(value,buffer,part,false);
		if(cycle) {
			return part;
		}
		let values = value.values;
		let value_offset = value.index;
		Cycles.push(values);
		while(value_offset < values.length) {
			let value = values[value_offset];
			let value1 = runtime_Actions.ACTIONS.get(value.get_TYPE_KIND());
			if(value1 == null) {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			part = value1.form(value,buffer,arg,part);
			if(arg != null && part <= 0) {
				Cycles.pop();
				return part;
			}
			++value_offset;
			if(value_offset < values.length) {
				buffer.values.push(47);
				--part;
			}
		}
		Cycles.pop();
		return part;
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		let cycle;
		/*;
		cycle = */ //;
		[part, cycle] = Cycles.detect(value,buffer,part,true);
		if(cycle) {
			return part;
		}
		let values = value.values;
		let value_offset = value.index;
		Cycles.push(values);
		while(value_offset < values.length) {
			let value = values[value_offset];
			if(value == null) {
				value = types_Tag.fromString("null");
			}
			let value1 = runtime_Actions.ACTIONS.get(value.get_TYPE_KIND());
			if(value1 == null) {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			part = value1.mold(value,buffer,isOnly,isAll,isFlat,arg,part,0);
			if(arg != null && part <= 0) {
				Cycles.pop();
				return part;
			}
			++value_offset;
			if(value_offset < values.length) {
				buffer.values.push(47);
				--part;
			}
		}
		Cycles.pop();
		return part;
	}
}
runtime_actions_datatypes_PathActions.__name__ = true;
runtime_actions_datatypes_PathActions.__super__ = runtime_actions_datatypes__$BlockLikeActions;
Object.assign(runtime_actions_datatypes_PathActions.prototype, {
	__class__: runtime_actions_datatypes_PathActions
});
class runtime_actions_datatypes_LitPathActions extends runtime_actions_datatypes_PathActions {
	constructor() {
		super();
	}
	makeThis(values,index) {
		return new types_LitPath(values,index);
	}
	form(value,buffer,arg,part) {
		buffer.values.push(39);
		return super.form(value,buffer,arg,part - 1);
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		buffer.values.push(39);
		return super.mold(value,buffer,isOnly,isAll,isFlat,arg,part - 1,0);
	}
}
runtime_actions_datatypes_LitPathActions.__name__ = true;
runtime_actions_datatypes_LitPathActions.__super__ = runtime_actions_datatypes_PathActions;
Object.assign(runtime_actions_datatypes_LitPathActions.prototype, {
	__class__: runtime_actions_datatypes_LitPathActions
});
class runtime_actions_datatypes_SetPathActions extends runtime_actions_datatypes_PathActions {
	constructor() {
		super();
	}
	makeThis(values,index) {
		return new types_SetPath(values,index);
	}
	form(value,buffer,arg,part) {
		part = super.form(value,buffer,arg,part);
		buffer.values.push(58);
		return part - 1;
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		part = super.mold(value,buffer,isOnly,isAll,isFlat,arg,part,0);
		buffer.values.push(58);
		return part - 1;
	}
}
runtime_actions_datatypes_SetPathActions.__name__ = true;
runtime_actions_datatypes_SetPathActions.__super__ = runtime_actions_datatypes_PathActions;
Object.assign(runtime_actions_datatypes_SetPathActions.prototype, {
	__class__: runtime_actions_datatypes_SetPathActions
});
class runtime_actions_datatypes_GetPathActions extends runtime_actions_datatypes_PathActions {
	constructor() {
		super();
	}
	makeThis(values,index) {
		return new types_GetPath(values,index);
	}
	form(value,buffer,arg,part) {
		buffer.values.push(58);
		return super.form(value,buffer,arg,part - 1);
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		buffer.values.push(58);
		return super.mold(value,buffer,isOnly,isAll,isFlat,arg,part - 1,0);
	}
}
runtime_actions_datatypes_GetPathActions.__name__ = true;
runtime_actions_datatypes_GetPathActions.__super__ = runtime_actions_datatypes_PathActions;
Object.assign(runtime_actions_datatypes_GetPathActions.prototype, {
	__class__: runtime_actions_datatypes_GetPathActions
});
class runtime_actions_datatypes_BitsetActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	make(_,spec) {
		return runtime_actions_datatypes_BitsetActions.construct(spec,0);
	}
	to(_,spec) {
		return runtime_actions_datatypes_BitsetActions.construct(spec,1);
	}
	form(value,buffer,arg,part) {
		let isNot = value.negated;
		buffer.appendLiteral("make bitset! ");
		part -= 13;
		if(isNot) {
			buffer.appendLiteral("[not ");
			part -= 5;
		}
		buffer.appendLiteral("#{");
		part -= 2;
		part = runtime_actions_datatypes_BitsetActions.formBytes(value,buffer,arg != null,part,isNot);
		if(arg != null && part <= 0) {
			return part;
		}
		buffer.values.push(125);
		if(isNot) {
			buffer.values.push(93);
			return part - 7;
		} else {
			return part - 1;
		}
	}
	mold(value,buffer,_,_1,_2,arg,part,_3) {
		return this.form(value,buffer,arg,part);
	}
	evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		if(((element) instanceof types_base__$Integer) == true) {
			let __anon0__i = element;
			let i = __anon0__i;
			let _hx_tmp;
			if(value == null) {
				return runtime_actions_datatypes_BitsetActions._pick(parent,i);
			} else {
				_hx_tmp = value;
				let value1 = _hx_tmp;
				return runtime_actions_datatypes_BitsetActions._poke(parent,i,value1);
			}
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
	}
	compare(value1,value2,op) {
		let bitset2;
		if(((value2) instanceof types_Bitset) == true) {
			let __anon0__bs = value2;
			let bs = __anon0__bs;
			bitset2 = bs;
		} else {
			return -2;
		}
		let bs1 = value1.bytes;
		let bs2 = bitset2.bytes;
		if(op == 9) {
			return +((bs1 != bs2));
		}
		let sz1 = bs1.length;
		let sz2 = bs2.length;
		if(sz1 != sz2) {
			return Math.sign((sz1 - sz2));
		}
		if(sz1 == 0) {
			return 0;
		}
		let not1 = value1.negated;
		let not2 = bitset2.negated;
		if(not1 != not2) {
			return Math.sign((+(not1) - +(not2)));
		}
		let i = sz1 - 1;
		let b1 = 0;
		let b2 = 0;
		while(i >= 0) {
			b1 = bs1.b[i];
			b2 = bs2.b[i];
			if(b1 != b2) {
				break;
			}
		}
		return Math.sign((b1 - b2));
	}
	negate(value) {
		return this.complement(value);
	}
	complement(value) {
		return new types_Bitset(new haxe_io_Bytes(value.bytes.b.bufferValue.slice(0)),!value.negated);
	}
	and(value1,value2) {
		return runtime_actions_datatypes_BitsetActions.doBitwise(value1,value2,6);
	}
	or(value1,value2) {
		return runtime_actions_datatypes_BitsetActions.doBitwise(value1,value2,5);
	}
	xor(value1,value2) {
		return runtime_actions_datatypes_BitsetActions.doBitwise(value1,value2,7);
	}
	clear(bitset) {
		bitset.bytes.b.fill(bitset.negated ? 255 : 0);
		return bitset;
	}
	copy(bitset,options) {
		return new types_Bitset(new haxe_io_Bytes(bitset.bytes.b.bufferValue.slice(0)),bitset.negated);
	}
	find(bitset,value,options) {
		let bool = this.pick(bitset,value);
		if(bool.cond) {
			return bool;
		} else {
			return types_None.NONE;
		}
	}
	insert(bitset,value,options) {
		runtime_actions_datatypes_BitsetActions.process(value,bitset,1,false,2);
		return bitset;
	}
	length_q(bitset) {
		return new types_Integer(bitset.bytes.length << 3);
	}
	pick(bitset,index) {
		if(((index) instanceof types_base__$Integer) == true) {
			let __anon0__i = index;
			let i = __anon0__i;
			return runtime_actions_datatypes_BitsetActions._pick(bitset,i);
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
	}
	poke(bitset,index,value) {
		if(((index) instanceof types_base__$Integer) == true) {
			let __anon0__i = index;
			let i = __anon0__i;
			return runtime_actions_datatypes_BitsetActions._poke(bitset,i,value);
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
	}
	remove(bitset,options) {
		let key;
		let tmp = options != null ? options.key.keyArg : null;
		if(tmp != null) {
			key = tmp;
		} else {
			throw haxe_Exception.thrown("missing arg");
		}
		runtime_actions_datatypes_BitsetActions.process(key,bitset,bitset.negated ? 1 : 3,false,2);
		return bitset;
	}
	static boundCheck(bits,index) {
		let s = bits.bytes;
		if(s.length << 3 <= index) {
			let byte = bits.negated ? 255 : 0;
			let b = new haxe_io_Bytes(new ArrayBuffer((index >> 3) + 1));
			b.b.fill(byte,s.length);
			b.blit(0,s,0,s.length);
			bits.bytes = b;
		}
	}
	static isVirtualBit(bits,index) {
		let p = (index >> 3) + 1;
		if(!(index < 0 || p > bits.bytes.length)) {
			return p < 0;
		} else {
			return true;
		}
	}
	static formBytes(bits,buffer,isPart,part,invert) {
		let _g = 0;
		let _g1 = bits.bytes.b;
		while(_g < _g1.length) {
			let byte = _g1[_g];
			++_g;
			if(invert) {
				byte = 255 - byte;
			}
			let nibble = byte >> 4;
			let c = nibble < 10 ? 48 + nibble : 65 + (nibble - 10);
			buffer.values.push(c);
			nibble = byte & 15;
			c = nibble < 10 ? 48 + nibble : 65 + (nibble - 10);
			buffer.values.push(c);
			part -= 2;
			if(isPart && part < 0) {
				return part;
			}
		}
		return part;
	}
	static processRange(bits,lower,upper,op) {
		let isNot = bits.negated;
		switch(op) {
		case 1:
			if(isNot) {
				if(runtime_actions_datatypes_BitsetActions.isVirtualBit(bits,upper)) {
					return 1;
				}
			} else {
				runtime_actions_datatypes_BitsetActions.boundCheck(bits,upper);
			}
			let _g = lower;
			let _g1 = upper + 1;
			while(_g < _g1) bits.setBit(_g++);
			break;
		case 2:
			if(runtime_actions_datatypes_BitsetActions.isVirtualBit(bits,upper)) {
				return +(isNot);
			}
			let _g2 = lower;
			let _g3 = upper + 1;
			while(_g2 < _g3) if(!bits.testBit(_g2++)) {
				return 0;
			}
			break;
		case 3:
			if(isNot) {
				runtime_actions_datatypes_BitsetActions.boundCheck(bits,upper);
			} else if(runtime_actions_datatypes_BitsetActions.isVirtualBit(bits,upper)) {
				return 0;
			}
			let _g4 = lower;
			let _g5 = upper + 1;
			while(_g4 < _g5) bits.clearBit(_g4++);
			break;
		default:
		}
		return 1;
	}
	static processString(str,bits,op) {
		let isSet = false;
		let max = 0;
		let isTest = op == 2;
		let _gthis = str;
		let _this = str.values.slice(str.index);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _gthis.wrap(_this[i]);
		}
		let _g_current = 0;
		while(_g_current < result.length) {
			let cp = result[_g_current++].int;
			switch(op) {
			case 0:
				break;
			case 1:
				bits.setBit(cp);
				break;
			case 2:
				isSet = bits.testBit(cp);
				break;
			case 3:
				bits.clearBit(cp);
				break;
			}
			if(cp > max) {
				max = cp;
			}
			if(isTest && !isSet) {
				return 0;
			}
		}
		if(isTest && isSet) {
			return 1;
		} else {
			return max;
		}
	}
	static process(spec,bits,op,isSub,cmd) {
		let max = 0;
		let tmp = bits != null ? bits.negated : null;
		let isNot = tmp != null && tmp;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		let _hx_tmp4;
		if(((spec) instanceof types_Char) == true) {
			let __anon0__n = spec;
			let n = __anon0__n;
			max = n.asInt();
			if(max < 0 && op != 2) {
				throw haxe_Exception.thrown("out of range");
			}
			switch(op) {
			case 1:
				if(isNot) {
					if(runtime_actions_datatypes_BitsetActions.isVirtualBit(bits,max)) {
						return 1;
					}
				} else {
					runtime_actions_datatypes_BitsetActions.boundCheck(bits,max);
				}
				bits.setBit(max);
				break;
			case 2:
				if(runtime_actions_datatypes_BitsetActions.isVirtualBit(bits,max)) {
					return +(isNot);
				}
				max = +(bits.testBit(max));
				break;
			case 3:
				if(isNot) {
					runtime_actions_datatypes_BitsetActions.boundCheck(bits,max);
				} else if(runtime_actions_datatypes_BitsetActions.isVirtualBit(bits,max)) {
					return 0;
				}
				bits.clearBit(max);
				break;
			default:
			}
		} else {
			_hx_tmp4 = ((spec) instanceof types_Integer);
			if(_hx_tmp4 == true) {
				let __anon0__n = spec;
				let n = __anon0__n;
				max = n.asInt();
				if(max < 0 && op != 2) {
					throw haxe_Exception.thrown("out of range");
				}
				switch(op) {
				case 1:
					if(isNot) {
						if(runtime_actions_datatypes_BitsetActions.isVirtualBit(bits,max)) {
							return 1;
						}
					} else {
						runtime_actions_datatypes_BitsetActions.boundCheck(bits,max);
					}
					bits.setBit(max);
					break;
				case 2:
					if(runtime_actions_datatypes_BitsetActions.isVirtualBit(bits,max)) {
						return +(isNot);
					}
					max = +(bits.testBit(max));
					break;
				case 3:
					if(isNot) {
						runtime_actions_datatypes_BitsetActions.boundCheck(bits,max);
					} else if(runtime_actions_datatypes_BitsetActions.isVirtualBit(bits,max)) {
						return 0;
					}
					bits.clearBit(max);
					break;
				default:
				}
			} else {
				_hx_tmp3 = ((spec) instanceof types_Float);
				if(_hx_tmp3 == true) {
					let __anon0__n = spec;
					let n = __anon0__n;
					max = n.asInt();
					if(max < 0 && op != 2) {
						throw haxe_Exception.thrown("out of range");
					}
					switch(op) {
					case 1:
						if(isNot) {
							if(runtime_actions_datatypes_BitsetActions.isVirtualBit(bits,max)) {
								return 1;
							}
						} else {
							runtime_actions_datatypes_BitsetActions.boundCheck(bits,max);
						}
						bits.setBit(max);
						break;
					case 2:
						if(runtime_actions_datatypes_BitsetActions.isVirtualBit(bits,max)) {
							return +(isNot);
						}
						max = +(bits.testBit(max));
						break;
					case 3:
						if(isNot) {
							runtime_actions_datatypes_BitsetActions.boundCheck(bits,max);
						} else if(runtime_actions_datatypes_BitsetActions.isVirtualBit(bits,max)) {
							return 0;
						}
						bits.clearBit(max);
						break;
					default:
					}
				} else {
					_hx_tmp2 = ((spec) instanceof types_String);
					if(_hx_tmp2 == true) {
						let __anon0__s = spec;
						let s = __anon0__s;
						switch(op) {
						case 1:
							max = runtime_actions_datatypes_BitsetActions.processString(s,bits,0);
							if(isNot) {
								if(runtime_actions_datatypes_BitsetActions.isVirtualBit(bits,max)) {
									return 1;
								}
							} else {
								runtime_actions_datatypes_BitsetActions.boundCheck(bits,max);
							}
							break;
						case 3:
							max = runtime_actions_datatypes_BitsetActions.processString(s,bits,0);
							if(isNot) {
								runtime_actions_datatypes_BitsetActions.boundCheck(bits,max);
							} else if(runtime_actions_datatypes_BitsetActions.isVirtualBit(bits,max)) {
								return 0;
							}
							break;
						default:
						}
						max = runtime_actions_datatypes_BitsetActions.processString(s,bits,op);
					} else {
						_hx_tmp1 = ((spec) instanceof types_Binary);
						if(_hx_tmp1 == true) {
							let __anon0__b = spec;
							let b = __anon0__b;
							throw haxe_Exception.thrown("NYI");
						} else {
							_hx_tmp = ((spec) instanceof types_Block);
							if(_hx_tmp == true) {
								let __anon0__b = spec;
								let b = __anon0__b;
								let tail = b.values.length - b.index;
								let isTest = op == 2;
								let i = 0;
								while(i < tail) {
									let value = b.wrap(b.values[b.index + i]);
									let size = runtime_actions_datatypes_BitsetActions.process(value,bits,op,true,cmd);
									if(isTest && size == 0) {
										return 0;
									}
									if(((value) instanceof types_base__$Integer) == true) {
										let __anon0__int1 = value;
										if(i + 1 < tail) {
											let int1 = __anon0__int1;
											let _g = b.wrap(b.values[b.index + (i + 1)]);
											if(((_g) instanceof types_Word) == true) {
												let __anon0__w = _g;
												let w = __anon0__w;
												if(w.symbol == runtime_Words.DASH) {
													if(i + 2 == tail) {
														throw haxe_Exception.thrown("past end");
													}
													let _g = b.wrap(b.values[b.index + (i + 2)]);
													if(((_g) instanceof types_base__$Integer) == true) {
														let __anon0__int2 = _g;
														let int2 = __anon0__int2;
														if(int2.constructor != int1.constructor) {
															throw new runtime_actions_InvalidAction("Invalid action!");
														}
														let min = size;
														size = int2.int;
														if(min > size) {
															throw haxe_Exception.thrown("past end");
														}
														switch(op) {
														case 0:
															break;
														case 1:
															runtime_actions_datatypes_BitsetActions.processRange(bits,min,size,op);
															break;
														case 2:
															max = runtime_actions_datatypes_BitsetActions.processRange(bits,min,size,op);
															break;
														case 3:
															runtime_actions_datatypes_BitsetActions.processRange(bits,min,size,op);
															break;
														}
														i += 2;
													} else {
														throw new runtime_actions_InvalidAction("Invalid action!");
													}
												}
											}
										}
									}
									if(size > max) {
										max = size;
									}
									++i;
								}
							} else {
								switch(cmd) {
								case 0:
									throw haxe_Exception.thrown("bad make arg");
								case 1:
									throw haxe_Exception.thrown("bad to arg");
								default:
									throw haxe_Exception.thrown("invalid arg");
								}
							}
						}
					}
				}
			}
		}
		if(!isSub && (op == 1 || op == 0)) {
			max = (max + 8 & -8) >> 3;
			if(max == 0) {
				max = 1;
			}
		}
		return max;
	}
	static construct(spec,cmd) {
		let bits;
		let blk = null;
		let isNot = false;
		if(((spec) instanceof types_Block) == true) {
			let __anon0__b = spec;
			let b = __anon0__b;
			blk = b;
			if(b.values.length - b.index > 0) {
				let _g = b.wrap(b.values[b.index]);
				if(((_g) instanceof types_Word) == true) {
					let __anon0__w = _g;
					let w = __anon0__w;
					isNot = w.symbol == runtime_Words.NOT;
				}
				if(isNot) {
					b.index++;
				}
				if(b.values.length - b.index > 0) {
					let _g = b.wrap(b.values[b.index]);
					if(((_g) instanceof types_Binary) == true) {
						let __anon0__bn = _g;
						let bn = __anon0__bn;
						spec = bn;
					}
				}
			}
		}
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((spec) instanceof types_Bitset) == true) {
			let __anon0__b = spec;
			let b = __anon0__b;
			bits = new types_Bitset(new haxe_io_Bytes(b.bytes.b.bufferValue.slice(0)),b.negated);
		} else {
			_hx_tmp2 = ((spec) instanceof types_Float);
			if(_hx_tmp2 == true) {
				let __anon0__n = spec;
				let n = __anon0__n;
				if(cmd == 1) {
					throw haxe_Exception.thrown("bad to arg");
				}
				let size = n.asInt();
				if(size < 0) {
					throw haxe_Exception.thrown("out of range");
				}
				if((size & 7) == 0) {
					size = size + 8 & -8;
				}
				size >>= 3;
				bits = types_Bitset.alloc(size);
			} else {
				_hx_tmp1 = ((spec) instanceof types_Integer);
				if(_hx_tmp1 == true) {
					let __anon0__n = spec;
					let n = __anon0__n;
					if(cmd == 1) {
						throw haxe_Exception.thrown("bad to arg");
					}
					let size = n.asInt();
					if(size < 0) {
						throw haxe_Exception.thrown("out of range");
					}
					if((size & 7) == 0) {
						size = size + 8 & -8;
					}
					size >>= 3;
					bits = types_Bitset.alloc(size);
				} else {
					_hx_tmp = ((spec) instanceof types_Binary);
					if(_hx_tmp == true) {
						let __anon0__b = spec;
						let b = __anon0__b;
						bits = types_Bitset.fromIntegers(b,isNot);
						if(isNot) {
							let bs = bits.bytes;
							let _g = 0;
							let _g1 = bs.length;
							while(_g < _g1) {
								let i = _g++;
								bs.b[i] = ~bs.b[i];
							}
						}
					} else {
						let op = isNot ? 3 : 1;
						let size = runtime_actions_datatypes_BitsetActions.process(spec,null,0,false,cmd);
						bits = types_Bitset.alloc(size,isNot);
						if(isNot) {
							bits.bytes.b.fill(255);
						}
						runtime_actions_datatypes_BitsetActions.process(spec,bits,op,false,cmd);
						if(isNot) {
							blk.index--;
						}
					}
				}
			}
		}
		return bits;
	}
	static doBitwise(left,right,op) {
		let set1 = left;
		let set2;
		if(((right) instanceof types_Bitset) == true) {
			let __anon0__b = right;
			let b = __anon0__b;
			set2 = b;
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
		let s1 = set1.bytes;
		let s2 = set2.bytes;
		let size1 = s1.length;
		let size2 = s2.length;
		let min = size1;
		let max = size2;
		if(min > max) {
			[min, max] = [max, min];
		}
		let isSame = set1.negated == set2.negated;
		let node = types_Bitset.alloc(max,!isSame);
		let s = node.bytes;
		let p = 0;
		let p1 = 0;
		let p2 = 0;
		let i = 0;
		while(i < min) {
			let v;
			switch(op) {
			case 5:case 9:
				v = s1.b[p1] | s2.b[p2];
				break;
			case 6:case 10:
				v = s1.b[p1] & s2.b[p2];
				break;
			case 7:case 12:
				v = s1.b[p1] ^ s2.b[p2];
				break;
			case 11:
				v = s1.b[p1] & ~s2.b[p2];
				break;
			default:
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
			s.b[i] = v;
			++p;
			++p1;
			++p2;
			++i;
		}
		min = max - i;
		if(min != 0) {
			if(size2 < size1) {
				p2 = p1;
				s2 = s1;
			}
			switch(op) {
			case 5:case 9:
				s.blit(p,s2,p2,min);
				p += min;
				break;
			case 6:
				break;
			case 7:case 12:
				i = 0;
				do {
					s.b[p] = 0 ^ s2.b[p2];
					++p;
					++p2;
					++i;
				} while(i != min);
				break;
			case 10:
				p += min;
				break;
			case 11:
				if(size1 > size2) {
					s.blit(p,s2,p2,min);
				}
				p += min;
				break;
			default:
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
		}
		return node;
	}
	static _pick(bitset,index) {
		if(runtime_actions_datatypes_BitsetActions.process(index,bitset,2,true,2) > 0) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
	static _poke(bitset,index,value) {
		let op;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((value) instanceof types_None) == true) {
			op = true;
		} else {
			_hx_tmp2 = ((value) instanceof types_Logic);
			if(_hx_tmp2 == true) {
				let __anon0__l = value;
				let l = __anon0__l;
				op = l.cond;
			} else {
				_hx_tmp1 = ((value) instanceof types_Integer);
				if(_hx_tmp1 == true) {
					let __anon0__i = value;
					let i = __anon0__i;
					op = i.int == 0;
				} else {
					_hx_tmp = ((value) instanceof types_Float);
					if(_hx_tmp == true) {
						let __anon0__f = value;
						let f = __anon0__f;
						op = f.float == 0;
					} else {
						op = false;
					}
				}
			}
		}
		let op1 = op ? 3 : 1;
		runtime_actions_datatypes_BitsetActions.process(index,bitset,op1,false,2);
		return value;
	}
}
runtime_actions_datatypes_BitsetActions.__name__ = true;
runtime_actions_datatypes_BitsetActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_BitsetActions.prototype, {
	__class__: runtime_actions_datatypes_BitsetActions
});
class runtime_actions_datatypes_Point2DActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	make(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		let _hx_tmp4;
		if(((spec) instanceof types_Integer) == true) {
			let __anon0__i = spec;
			let i = __anon0__i;
			return new types_Point2D(i.int,i.int);
		} else {
			_hx_tmp4 = ((spec) instanceof types_Float);
			if(_hx_tmp4 == true) {
				let __anon0__f = spec;
				let f = __anon0__f;
				return new types_Point2D(f.float,f.float);
			} else {
				_hx_tmp3 = ((spec) instanceof types_Block);
				if(_hx_tmp3 == true) {
					let __anon0__b = spec;
					let b = __anon0__b;
					if(b.values.length - b.index >= 2) {
						let x;
						let _g = b.wrap(b.values[b.index]);
						let _hx_tmp;
						let _hx_tmp1 = ((_g) instanceof types_Integer) ? _g : null;
						if(_hx_tmp1 == null) {
							_hx_tmp = ((_g) instanceof types_Float) ? _g : null;
							if(_hx_tmp == null) {
								throw haxe_Exception.thrown("bad");
							} else {
								let _g = _hx_tmp.get_TYPE_KIND();
								let n = _hx_tmp.float;
								x = n;
							}
						} else {
							let _g = _hx_tmp1.get_TYPE_KIND();
							let n = _hx_tmp1.int;
							x = n;
						}
						let y;
						let _g1 = b.wrap(b.values[b.index + 1]);
						let _hx_tmp2;
						let _hx_tmp3 = ((_g1) instanceof types_Integer) ? _g1 : null;
						if(_hx_tmp3 == null) {
							_hx_tmp2 = ((_g1) instanceof types_Float) ? _g1 : null;
							if(_hx_tmp2 == null) {
								throw haxe_Exception.thrown("bad");
							} else {
								let _g = _hx_tmp2.get_TYPE_KIND();
								let n = _hx_tmp2.float;
								y = n;
							}
						} else {
							let _g = _hx_tmp3.get_TYPE_KIND();
							let n = _hx_tmp3.int;
							y = n;
						}
						return new types_Point2D(x,y);
					} else {
						throw haxe_Exception.thrown("bad");
					}
				} else {
					_hx_tmp2 = ((spec) instanceof types_Pair);
					if(_hx_tmp2 == true) {
						let __anon0__p = spec;
						let p = __anon0__p;
						return new types_Point2D(p.x,p.y);
					} else {
						_hx_tmp1 = ((spec) instanceof types_String);
						if(_hx_tmp1 == true) {
							let __anon0__s = spec;
							let s = __anon0__s;
							let _g = Tokenizer.parse(s.toJs());
							if(_g.length == 1) {
								let _g1 = _g[0];
								if(((_g1) instanceof types_Point2D) == true) {
									let __anon0__p = _g1;
									let p = __anon0__p;
									return p;
								} else {
									throw haxe_Exception.thrown("Can't parse point2D! from \"" + s.toJs() + "\"");
								}
							} else {
								throw haxe_Exception.thrown("Can't parse point2D! from \"" + s.toJs() + "\"");
							}
						} else {
							_hx_tmp = ((spec) instanceof types_Point2D);
							if(_hx_tmp == true) {
								let __anon0__p = spec;
								let p = __anon0__p;
								return p;
							} else {
								throw haxe_Exception.thrown("bad");
							}
						}
					}
				}
			}
		}
	}
	to(proto,spec) {
		return this.make(proto,spec);
	}
	form(value,buffer,arg,part) {
		buffer.values.push(40);
		let formed = value.x.toString();
		buffer.appendLiteral(formed);
		part -= formed.length;
		buffer.appendLiteral(", ");
		formed = value.y.toString();
		buffer.appendLiteral(formed);
		buffer.values.push(41);
		return part - 4 - formed.length;
	}
	mold(value,buffer,_,_1,_2,arg,part,_3) {
		return this.form(value,buffer,arg,part);
	}
	evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		let axis;
		let _hx_tmp;
		if(((element) instanceof types_Integer) == true) {
			let __anon0__i = element;
			let i = __anon0__i;
			if(i.int != 1 && i.int != 2) {
				throw haxe_Exception.thrown("invalid path");
			}
			axis = i.int;
		} else {
			_hx_tmp = ((element) instanceof types_Word);
			if(_hx_tmp == true) {
				let __anon0__w = element;
				let w = __anon0__w;
				axis = runtime_actions_datatypes_Point2DActions.getNamedIndex(w,path);
			} else {
				throw haxe_Exception.thrown("invalid path");
			}
		}
		let _hx_tmp1;
		if(((value) instanceof types_Integer) == true) {
			let __anon0__i = value;
			let i = __anon0__i;
			if(axis == 1) {
				return new types_Point2D(i.int,parent.y);
			} else {
				return new types_Point2D(parent.x,i.int);
			}
		} else {
			_hx_tmp1 = ((value) instanceof types_Float);
			if(_hx_tmp1 == true) {
				let __anon0__f = value;
				let f = __anon0__f;
				if(axis == 1) {
					return new types_Point2D(f.float,parent.y);
				} else {
					return new types_Point2D(parent.x,f.float);
				}
			} else if(value == null) {
				return new types_Float(axis == 1 ? parent.x : parent.y);
			} else {
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
		}
	}
	compare(value1,value2,op) {
		let point2;
		if(((value2) instanceof types_Point2D) == true) {
			let __anon0__p = value2;
			let p = __anon0__p;
			point2 = p;
		} else {
			return -2;
		}
		let diff = value1.x - point2.x;
		if(diff == 0) {
			diff = value1.y - point2.y;
		}
		return Math.sign(diff);
	}
	doMath(left,right,op) {
		if(((left) instanceof types_Point2D) == true) {
			let __anon0__l = left;
			let l = __anon0__l;
			let x;
			let y;
			let _hx_tmp;
			let _hx_tmp1;
			let _hx_tmp2;
			if(((right) instanceof types_Point2D) == true) {
				let __anon0__p = right;
				let p = __anon0__p;
				x = p.x;
				y = p.y;
			} else {
				_hx_tmp2 = ((right) instanceof types_Pair);
				if(_hx_tmp2 == true) {
					let __anon0__p = right;
					let p = __anon0__p;
					x = p.x;
					y = p.y;
				} else {
					_hx_tmp1 = ((right) instanceof types_Integer);
					if(_hx_tmp1 == true) {
						let __anon0__i = right;
						let i = __anon0__i;
						y = i.int;
						x = y;
					} else {
						_hx_tmp = ((right) instanceof types_base__$Float) ? right : null;
						if(_hx_tmp == null) {
							throw new runtime_actions_InvalidAction("Invalid action!");
						} else {
							let _g = _hx_tmp.get_TYPE_KIND();
							let f = _hx_tmp.float;
							switch(op) {
							case 2:
								return new types_Point2D(l.x * f,l.y / f);
							case 3:
								return new types_Point2D(l.x * f,l.y / f);
							default:
								y = f;
								x = y;
							}
						}
					}
				}
			}
			return new types_Point2D(runtime_actions_datatypes_FloatActions.doMathOp(l.x,x,op),runtime_actions_datatypes_FloatActions.doMathOp(l.y,y,op));
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
	}
	absolute(value) {
		return new types_Point2D(Math.abs(value.x),Math.abs(value.y));
	}
	negate(value) {
		return new types_Point2D(-value.x,-value.y);
	}
	add(value1,value2) {
		return this.doMath(value1,value2,0);
	}
	subtract(value1,value2) {
		return this.doMath(value1,value2,1);
	}
	multiply(value1,value2) {
		return this.doMath(value1,value2,2);
	}
	divide(value1,value2) {
		return this.doMath(value1,value2,3);
	}
	remainder(value1,value2) {
		return this.doMath(value1,value2,4);
	}
	round(value,options) {
		let tmp = options.to;
		let scale = tmp != null ? tmp.scale : null;
		if(((scale) instanceof types_Money)) {
			throw haxe_Exception.thrown("not related");
		}
		let y = 0;
		let scalexy;
		if(((scale) instanceof types_Pair) == true) {
			let __anon0__p = scale;
			let p = __anon0__p;
			y = p.y;
			options.to.scale = new types_Integer(p.x);
			scalexy = true;
		} else {
			scalexy = false;
		}
		let value1 = runtime_Actions.ACTIONS.get(11);
		let floatActions;
		if(value1 != null) {
			floatActions = value1;
		} else {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		let tmp1 = floatActions.round(new types_Float(value.x),options).float;
		if(scalexy) {
			options.to.scale.int = y;
		}
		return new types_Point2D(tmp1,floatActions.round(new types_Float(value.y),options).float);
	}
	pick(value,index) {
		let idx;
		let _hx_tmp;
		if(((index) instanceof types_Integer) == true) {
			let __anon0__i = index;
			let i = __anon0__i;
			idx = i.int;
		} else {
			_hx_tmp = ((index) instanceof types_Word);
			if(_hx_tmp == true) {
				let __anon0__w = index;
				let w = __anon0__w;
				idx = runtime_actions_datatypes_Point2DActions.getNamedIndex(w,value);
			} else {
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
		}
		if(idx != 1 && idx != 2) {
			throw haxe_Exception.thrown("out of range");
		}
		return new types_Float(idx == 1 ? value.x : value.y);
	}
	reverse(value,options) {
		return new types_Point2D(value.y,value.x);
	}
	static getNamedIndex(w,ref) {
		let axis = w.symbol;
		if(axis != runtime_Words.X && axis != runtime_Words.Y) {
			if(((ref) instanceof types_Pair)) {
				throw haxe_Exception.thrown("cannot use");
			} else {
				throw haxe_Exception.thrown("invalid path");
			}
		}
		if(axis == runtime_Words.X) {
			return 1;
		} else {
			return 2;
		}
	}
}
runtime_actions_datatypes_Point2DActions.__name__ = true;
runtime_actions_datatypes_Point2DActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_Point2DActions.prototype, {
	__class__: runtime_actions_datatypes_Point2DActions
});
class runtime_actions_datatypes_Point3DActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	make(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		let _hx_tmp4;
		let _hx_tmp5;
		if(((spec) instanceof types_Integer) == true) {
			let __anon0__i = spec;
			let i = __anon0__i;
			return new types_Point3D(i.int,i.int,i.int);
		} else {
			_hx_tmp5 = ((spec) instanceof types_Float);
			if(_hx_tmp5 == true) {
				let __anon0__f = spec;
				let f = __anon0__f;
				return new types_Point3D(f.float,f.float,f.float);
			} else {
				_hx_tmp4 = ((spec) instanceof types_Block);
				if(_hx_tmp4 == true) {
					let __anon0__b = spec;
					let b = __anon0__b;
					if(b.values.length - b.index >= 3) {
						let x;
						let _g = b.wrap(b.values[b.index]);
						let _hx_tmp;
						let _hx_tmp1 = ((_g) instanceof types_Integer) ? _g : null;
						if(_hx_tmp1 == null) {
							_hx_tmp = ((_g) instanceof types_Float) ? _g : null;
							if(_hx_tmp == null) {
								throw haxe_Exception.thrown("bad");
							} else {
								let _g = _hx_tmp.get_TYPE_KIND();
								let n = _hx_tmp.float;
								x = n;
							}
						} else {
							let _g = _hx_tmp1.get_TYPE_KIND();
							let n = _hx_tmp1.int;
							x = n;
						}
						let y;
						let _g1 = b.wrap(b.values[b.index + 1]);
						let _hx_tmp2;
						let _hx_tmp3 = ((_g1) instanceof types_Integer) ? _g1 : null;
						if(_hx_tmp3 == null) {
							_hx_tmp2 = ((_g1) instanceof types_Float) ? _g1 : null;
							if(_hx_tmp2 == null) {
								throw haxe_Exception.thrown("bad");
							} else {
								let _g = _hx_tmp2.get_TYPE_KIND();
								let n = _hx_tmp2.float;
								y = n;
							}
						} else {
							let _g = _hx_tmp3.get_TYPE_KIND();
							let n = _hx_tmp3.int;
							y = n;
						}
						let z;
						let _g2 = b.wrap(b.values[b.index + 2]);
						let _hx_tmp4;
						let _hx_tmp5 = ((_g2) instanceof types_Integer) ? _g2 : null;
						if(_hx_tmp5 == null) {
							_hx_tmp4 = ((_g2) instanceof types_Float) ? _g2 : null;
							if(_hx_tmp4 == null) {
								throw haxe_Exception.thrown("bad");
							} else {
								let _g = _hx_tmp4.get_TYPE_KIND();
								let n = _hx_tmp4.float;
								z = n;
							}
						} else {
							let _g = _hx_tmp5.get_TYPE_KIND();
							let n = _hx_tmp5.int;
							z = n;
						}
						return new types_Point3D(x,y,z);
					} else {
						throw haxe_Exception.thrown("bad");
					}
				} else {
					_hx_tmp3 = ((spec) instanceof types_Pair);
					if(_hx_tmp3 == true) {
						let __anon0__p = spec;
						let p = __anon0__p;
						return new types_Point3D(p.x,p.y,0.0);
					} else {
						_hx_tmp2 = ((spec) instanceof types_Point2D);
						if(_hx_tmp2 == true) {
							let __anon0__p = spec;
							let p = __anon0__p;
							return new types_Point3D(p.x,p.y,0.0);
						} else {
							_hx_tmp1 = ((spec) instanceof types_String);
							if(_hx_tmp1 == true) {
								let __anon0__s = spec;
								let s = __anon0__s;
								let _g = Tokenizer.parse(s.toJs());
								if(_g.length == 1) {
									let _g1 = _g[0];
									if(((_g1) instanceof types_Point3D) == true) {
										let __anon0__p = _g1;
										let p = __anon0__p;
										return p;
									} else {
										throw haxe_Exception.thrown("Can't parse point3D! from \"" + s.toJs() + "\"");
									}
								} else {
									throw haxe_Exception.thrown("Can't parse point3D! from \"" + s.toJs() + "\"");
								}
							} else {
								_hx_tmp = ((spec) instanceof types_Point3D);
								if(_hx_tmp == true) {
									let __anon0__p = spec;
									let p = __anon0__p;
									return p;
								} else {
									throw haxe_Exception.thrown("bad");
								}
							}
						}
					}
				}
			}
		}
	}
	to(proto,spec) {
		return this.make(proto,spec);
	}
	form(value,buffer,arg,part) {
		buffer.values.push(40);
		let formed = value.x.toString();
		buffer.appendLiteral(formed);
		part -= formed.length;
		buffer.appendLiteral(", ");
		formed = value.y.toString();
		buffer.appendLiteral(formed);
		buffer.appendLiteral(", ");
		formed = value.z.toString();
		buffer.appendLiteral(formed);
		buffer.values.push(41);
		return part - 6 - formed.length;
	}
	mold(value,buffer,_,_1,_2,arg,part,_3) {
		return this.form(value,buffer,arg,part);
	}
	evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		let axis;
		let _hx_tmp;
		if(((element) instanceof types_Integer) == true) {
			let __anon0__i = element;
			let i = __anon0__i;
			if(i.int != 1 && i.int != 2 && i.int != 3) {
				throw haxe_Exception.thrown("invalid path");
			}
			axis = i.int;
		} else {
			_hx_tmp = ((element) instanceof types_Word);
			if(_hx_tmp == true) {
				let __anon0__w = element;
				let w = __anon0__w;
				axis = runtime_actions_datatypes_Point3DActions.getNamedIndex(w,path);
			} else {
				throw haxe_Exception.thrown("invalid path");
			}
		}
		let _hx_tmp1;
		if(((value) instanceof types_Integer) == true) {
			let __anon0__i = value;
			let i = __anon0__i;
			if(axis == 1) {
				return new types_Point3D(i.int,parent.y,parent.z);
			} else if(axis == 2) {
				return new types_Point3D(parent.x,i.int,parent.z);
			} else {
				return new types_Point3D(parent.x,parent.y,i.int);
			}
		} else {
			_hx_tmp1 = ((value) instanceof types_Float);
			if(_hx_tmp1 == true) {
				let __anon0__f = value;
				let f = __anon0__f;
				if(axis == 1) {
					return new types_Point3D(f.float,parent.y,parent.z);
				} else if(axis == 2) {
					return new types_Point3D(parent.x,f.float,parent.z);
				} else {
					return new types_Point3D(parent.x,parent.y,f.float);
				}
			} else if(value == null) {
				return new types_Float(axis == 1 ? parent.x : axis == 2 ? parent.y : parent.z);
			} else {
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
		}
	}
	compare(value1,value2,op) {
		let point2;
		if(((value2) instanceof types_Point3D) == true) {
			let __anon0__p = value2;
			let p = __anon0__p;
			point2 = p;
		} else {
			return -2;
		}
		let diff = value1.x - point2.x;
		if(diff == 0) {
			diff = value1.y - point2.y;
			if(diff == 0) {
				diff = value1.z - point2.z;
			}
		}
		return Math.sign(diff);
	}
	doMath(left,right,op) {
		if(((left) instanceof types_Point3D) == true) {
			let __anon0__l = left;
			let l = __anon0__l;
			let x;
			let y;
			let z;
			let _hx_tmp;
			let _hx_tmp1;
			if(((right) instanceof types_Point3D) == true) {
				let __anon0__p = right;
				let p = __anon0__p;
				x = p.x;
				y = p.y;
				z = p.z;
			} else {
				_hx_tmp1 = ((right) instanceof types_Integer);
				if(_hx_tmp1 == true) {
					let __anon0__i = right;
					let i = __anon0__i;
					z = i.int;
					y = z;
					x = y;
				} else {
					_hx_tmp = ((right) instanceof types_base__$Float) ? right : null;
					if(_hx_tmp == null) {
						throw new runtime_actions_InvalidAction("Invalid action!");
					} else {
						let _g = _hx_tmp.get_TYPE_KIND();
						let f = _hx_tmp.float;
						switch(op) {
						case 2:
							return new types_Point3D(l.x * f,l.y / f,l.z * f);
						case 3:
							return new types_Point3D(l.x * f,l.y / f,l.z / f);
						default:
							z = f;
							y = z;
							x = y;
						}
					}
				}
			}
			return new types_Point3D(runtime_actions_datatypes_FloatActions.doMathOp(l.x,x,op),runtime_actions_datatypes_FloatActions.doMathOp(l.y,y,op),runtime_actions_datatypes_FloatActions.doMathOp(l.z,z,op));
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
	}
	absolute(value) {
		return new types_Point3D(Math.abs(value.x),Math.abs(value.y),Math.abs(value.z));
	}
	negate(value) {
		return new types_Point3D(-value.x,-value.y,-value.z);
	}
	add(value1,value2) {
		return this.doMath(value1,value2,0);
	}
	subtract(value1,value2) {
		return this.doMath(value1,value2,1);
	}
	multiply(value1,value2) {
		return this.doMath(value1,value2,2);
	}
	divide(value1,value2) {
		return this.doMath(value1,value2,3);
	}
	remainder(value1,value2) {
		return this.doMath(value1,value2,4);
	}
	round(value,options) {
		let tmp = options.to;
		let scale = tmp != null ? tmp.scale : null;
		if(((scale) instanceof types_Money)) {
			throw haxe_Exception.thrown("not related");
		}
		let y = 0.0;
		let z = 0.0;
		let scalexy;
		if(((scale) instanceof types_Point3D) == true) {
			let __anon0__p = scale;
			let p = __anon0__p;
			y = p.y;
			z = p.z;
			options.to.scale = new types_Float(p.x);
			scalexy = true;
		} else {
			scalexy = false;
		}
		let value1 = runtime_Actions.ACTIONS.get(11);
		let floatActions;
		if(value1 != null) {
			floatActions = value1;
		} else {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		let rx = floatActions.round(new types_Float(value.x),options).float;
		if(scalexy) {
			options.to.scale = new types_Float(y);
		}
		let ry = floatActions.round(new types_Float(value.y),options).float;
		if(scalexy) {
			options.to.scale = new types_Float(z);
		}
		let rz = floatActions.round(new types_Float(value.z),options).float;
		return new types_Point3D(rx,ry,rz);
	}
	pick(value,index) {
		let idx;
		let _hx_tmp;
		if(((index) instanceof types_Integer) == true) {
			let __anon0__i = index;
			let i = __anon0__i;
			idx = i.int;
		} else {
			_hx_tmp = ((index) instanceof types_Word);
			if(_hx_tmp == true) {
				let __anon0__w = index;
				let w = __anon0__w;
				idx = runtime_actions_datatypes_Point3DActions.getNamedIndex(w,value);
			} else {
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
		}
		if(idx != 1 && idx != 2 && idx != 3) {
			throw haxe_Exception.thrown("out of range");
		}
		return new types_Float(idx == 1 ? value.x : idx == 2 ? value.y : value.z);
	}
	reverse(value,options) {
		return new types_Point3D(value.z,value.y,value.x);
	}
	static getNamedIndex(w,ref) {
		let axis = w.symbol;
		if(axis != runtime_Words.X && axis != runtime_Words.Y && axis != runtime_Words.Z) {
			if(((ref) instanceof types_Pair)) {
				throw haxe_Exception.thrown("cannot use");
			} else {
				throw haxe_Exception.thrown("invalid path");
			}
		}
		if(axis == runtime_Words.X) {
			return 1;
		} else if(axis == runtime_Words.Y) {
			return 2;
		} else {
			return 3;
		}
	}
}
runtime_actions_datatypes_Point3DActions.__name__ = true;
runtime_actions_datatypes_Point3DActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_Point3DActions.prototype, {
	__class__: runtime_actions_datatypes_Point3DActions
});
class runtime_actions_datatypes_ObjectActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	make(proto,spec) {
		let hasProto = proto != null;
		let obj = hasProto ? this.copy(proto,{ deep : true}) : new types_Object(null,0);
		let _hx_tmp;
		if(((spec) instanceof types_Object) == true) {
			let __anon0__obj2 = spec;
			let obj2 = __anon0__obj2;
			let changed = proto == null || runtime_actions_datatypes_ObjectActions.extend(obj.ctx,proto.ctx,obj);
			obj.classID = changed ? ++types_Object.maxID : proto.classID;
			runtime_actions_datatypes_ObjectActions.extend(obj.ctx,obj2.ctx,obj);
		} else {
			_hx_tmp = ((spec) instanceof types_Block);
			if(_hx_tmp == true) {
				let __anon0__block = spec;
				let block = __anon0__block;
				let isNew = obj.ctx.collectSetWords(block);
				obj.ctx.bind(block,true);
				if(hasProto) {
					runtime_actions_datatypes_ObjectActions.duplicate(proto.ctx,obj.ctx,false);
				}
				runtime_natives_Do.evalValues(new util__$Series__$Series(block.values,block.index));
				if(isNew || !hasProto) {
					obj.classID = ++types_Object.maxID;
				}
			} else {
				throw haxe_Exception.thrown("error!");
			}
		}
		return obj;
	}
	reflect(value,field) {
		return runtime_actions_datatypes_ObjectActions._reflect(value,field.symbol);
	}
	form(value,buffer,arg,part) {
		let cycle;
		/*;
		cycle = */ //;
		[part, cycle] = Cycles.detect(value,buffer,part,false);
		if(cycle) {
			return part;
		}
		return runtime_actions_datatypes_ObjectActions.serialize(value,buffer,false,false,false,arg,part,false,0,false);
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		let cycle;
		/*;
		cycle = */ //;
		[part, cycle] = Cycles.detect(value,buffer,part,false);
		if(cycle) {
			return part;
		}
		buffer.appendLiteral("make object! [");
		part = runtime_actions_datatypes_ObjectActions.serialize(value,buffer,false,isAll,isFlat,arg,part - 14,true,indent + 1,true);
		if(!isFlat && indent > 0) {
			part = runtime_actions_datatypes_ObjectActions.doIndent(buffer,indent,part);
		}
		buffer.values.push(93);
		return part - 1;
	}
	evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		if(value == null) {
			let opt = parent.getPath(element,isCase);
			switch(opt[1]) {
			case 0:
				return opt[2];
			case 1:
				return types_None.NONE;
			}
		} else if(parent.setPath(element,value,!isCase)) {
			return value;
		} else {
			throw haxe_Exception.thrown("invalid path");
		}
	}
	compare(value1,value2,op) {
		let obj1 = value1;
		let obj2;
		if(((value2) instanceof types_Object) == true) {
			let __anon0__o = value2;
			let o = __anon0__o;
			obj2 = o;
		} else {
			return -2;
		}
		if(obj1.ctx == obj2.ctx) {
			return 0;
		} else if(op == 9) {
			return -1;
		}
		if(Cycles.find(obj1.ctx)) {
			return Cycles.find(obj2.ctx) ? 0 : -1;
		}
		let ctx1 = obj1.ctx;
		let ctx2 = obj2.ctx;
		let sym1 = ctx1.symbols;
		let sym2 = ctx2.symbols;
		let diff = Math.sign((sym1.length - sym2.length));
		if(diff != 0) {
			return diff;
		}
		if(sym1.length == 0) {
			return 0;
		}
		let value11 = ctx1.values;
		let value21 = ctx2.values;
		Cycles.push(obj1.ctx);
		Cycles.push(obj2.ctx);
		let res = 0;
		let _g = 0;
		let _g1 = sym1.length;
		while(_g < _g1) {
			let i = _g++;
			let s1 = sym1[i].symbol;
			let s2 = sym2[i].symbol;
			if(!s1.equalsSymbol(s2)) {
				Cycles.popN(2);
				return Math.sign((types_base_Symbol.INDEXES.get(s1.name) - types_base_Symbol.INDEXES.get(s2.name)));
			}
			let v1 = value11[i];
			let v2 = value21[i];
			if(v1.constructor == v2.constructor || ((v1) instanceof types_base__$AnyWord) && ((v2) instanceof types_base__$AnyWord) || ((v1) instanceof types_base__$Number) && ((v2) instanceof types_base__$Number)) {
				res = runtime_Actions.compareValue(v1,v2,op);
			} else {
				Cycles.popN(2);
				return Math.sign((v1.get_TYPE_KIND() - v2.get_TYPE_KIND()));
			}
			if(res != 0) {
				break;
			}
		}
		Cycles.popN(2);
		return res;
	}
	copy(value,options) {
		if(options.types != null) {
			throw haxe_Exception.thrown("NYI!");
		}
		if(options.part != null) {
			throw haxe_Exception.thrown("bad");
		}
		let ctx = value.ctx;
		let src = ctx.symbols;
		let size = src.length;
		let newCtx = new types_base_Context(src,ctx.values);
		let newObj = new types_Object(newCtx,value.classID,true);
		if(size == 0) {
			return newObj;
		}
		let newValues = newCtx.values;
		if(options.deep) {
			let _g = 0;
			let _g1 = size;
			while(_g < _g1) {
				let i = _g++;
				let value = newValues[i];
				let _hx_tmp;
				if((((value) instanceof types_Block) || ((value) instanceof types_Paren) || ((value) instanceof types_base__$Path) || ((value) instanceof types_base__$String)) == true) {
					newValues[i] = runtime_actions_Copy.call(value,{ deep : true});
				} else {
					_hx_tmp = ((value) instanceof types_Function);
					if(_hx_tmp == true) {
						let __anon0__fn = value;
						let fn = __anon0__fn;
						newValues[i] = runtime_actions_datatypes_ObjectActions.rebind(fn,newCtx,newObj);
					}
				}
			}
		} else {
			let _g = 0;
			let _g1 = size;
			while(_g < _g1) {
				let i = _g++;
				let _g1 = newValues[i];
				if(((_g1) instanceof types_Function) == true) {
					let __anon0__fn = _g1;
					let fn = __anon0__fn;
					newValues[i] = runtime_actions_datatypes_ObjectActions.rebind(fn,newCtx,newObj);
				}
			}
		}
		return newObj;
	}
	static duplicate(src,dst,copy) {
		let from = src.values;
		let to = dst.values;
		let _g_current = 0;
		let _g_array = from;
		while(_g_current < _g_array.length) {
			let _g_value = _g_array[_g_current];
			let _g_key = _g_current++;
			let i = _g_key;
			let value = _g_value;
			if(js_Boot.__implements(value,types_base_ISeriesOf)) {
				let newValue = runtime_actions_Copy.call(value,{ deep : true});
				to[i] = newValue;
				if(((newValue) instanceof types_base__$Block) == true) {
					let __anon0__blk = newValue;
					let blk = __anon0__blk;
					dst.bind(blk,true);
				}
			} else if(copy) {
				to[i] = value;
			}
		}
	}
	static extend(ctx,spec,obj) {
		let syms = spec.symbols;
		let vals = spec.values;
		let numSyms = syms.length;
		let baseSyms = ctx.symbols;
		let numBaseSyms = baseSyms.length;
		let baseVals = ctx.values;
		let _g_current = 0;
		let _g_array = syms;
		while(_g_current < _g_array.length) {
			let _g_value = _g_array[_g_current];
			let _g_key = _g_current++;
			let i = _g_key;
			let sym = _g_value;
			ctx.addOrSetWord(sym,vals[i]);
		}
		let _g = 0;
		let _g1 = numSyms;
		while(_g < _g1) {
			let i = _g++;
			let value = baseVals[i];
			let _hx_tmp;
			if(((value) instanceof types_base__$SeriesOf) == true) {
				baseVals[i] = runtime_actions_Copy.call(value,{ deep : true});
			} else {
				_hx_tmp = ((value) instanceof types_Function);
				if(_hx_tmp == true) {
					let __anon0__fn = value;
					let fn = __anon0__fn;
					baseVals[i] = runtime_actions_datatypes_ObjectActions.rebind(fn,ctx,obj);
				}
			}
		}
		return baseSyms.length > numBaseSyms;
	}
	static rebind(fn,ctx,obj) {
		let newCtx = new types_base_Context(fn.ctx.symbols,fn.ctx.values);
		let blk = runtime_actions_Copy.block(fn.body,true,true);
		ctx.bind(blk,true);
		newCtx.bind(blk,false);
		return new types_Function(newCtx,fn.get_origSpec(),fn.get_doc(),fn.get_params(),fn.get_refines(),fn.get_retSpec(),blk);
	}
	static doIndent(buffer,tabs,part) {
		let _g = 0;
		while(_g < tabs) {
			++_g;
			buffer.appendLiteral("    ");
		}
		return part - 4 * tabs;
	}
	static serialize(obj,buffer,isOnly,isAll,isFlat,arg,part,isIndent,tabs,isMold) {
		let ctx = obj.ctx;
		let syms = ctx.symbols;
		let values = ctx.values;
		if(syms.length == 0) {
			return part;
		}
		let blank;
		if(isFlat) {
			isIndent = false;
			blank = 32;
		} else {
			if(isMold) {
				buffer.values.push(10);
				--part;
			}
			blank = 10;
		}
		Cycles.push(ctx);
		let _g_current = 0;
		while(_g_current < syms.length) {
			let _g_value = syms[_g_current];
			let _g_key = _g_current++;
			let value = values[_g_key];
			if(part <= 0) {
				Cycles.pop();
				return part;
			}
			if(isIndent) {
				part = runtime_actions_datatypes_ObjectActions.doIndent(buffer,tabs,part);
			}
			let value1 = runtime_Actions.ACTIONS.get(_g_value.get_TYPE_KIND());
			if(value1 == null) {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			part = value1.form(_g_value,buffer,arg,part);
			buffer.appendLiteral(": ");
			part -= 2;
			if(value == null) {
				value = values[_g_key] = types_Unset.UNSET;
			} else if(((value) instanceof types_Word)) {
				buffer.values.push(39);
				--part;
			}
			let value2 = value;
			if(value2 == null) {
				value2 = types_Tag.fromString("null");
			}
			let value3 = runtime_Actions.ACTIONS.get(value2.get_TYPE_KIND());
			if(value3 == null) {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			part = value3.mold(value2,buffer,isOnly,isAll,isFlat,arg,part,tabs);
			if(isIndent || _g_key + 1 < syms.length) {
				buffer.values.push(blank);
				--part;
			}
		}
		Cycles.pop();
		return part;
	}
	static _reflect(value,field) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		let _hx_tmp4;
		if(field == runtime_Words.CHANGED == true) {
			throw haxe_Exception.thrown("NYI");
		} else {
			_hx_tmp4 = field == runtime_Words.CLASS;
			if(_hx_tmp4 == true) {
				return new types_Integer(value.classID);
			} else {
				_hx_tmp3 = field == runtime_Words.WORDS;
				if(_hx_tmp3 == true) {
					let _g = [];
					let _g1 = 0;
					let _g2 = value.ctx.symbols;
					while(_g1 < _g2.length) {
						let sym = _g2[_g1];
						++_g1;
						_g.push(((sym) instanceof types_Word) ? sym : new types_Word(sym.symbol,sym.context,sym.index));
					}
					return new types_Block(_g);
				} else {
					_hx_tmp2 = field == runtime_Words.VALUES;
					if(_hx_tmp2 == true) {
						return new types_Block(value.ctx.values.slice());
					} else {
						_hx_tmp1 = field == runtime_Words.BODY;
						if(_hx_tmp1 == true) {
							let ctx = value.ctx;
							let blk = new types_Block([]);
							let syms = ctx.symbols;
							let vals = ctx.values;
							let _g_current = 0;
							let _g_array = syms;
							while(_g_current < _g_array.length) {
								let _g_value = _g_array[_g_current];
								let _g_key = _g_current++;
								let i = _g_key;
								let sym = _g_value;
								let val = vals[i];
								blk.values.push(((sym) instanceof types_SetWord) ? sym : new types_SetWord(sym.symbol,sym.context,sym.index));
								blk.addNewline(i * 2);
								let blk1 = blk.values;
								let _hx_tmp;
								let tmp;
								if(((val) instanceof types_Word) == true) {
									let __anon0__w = val;
									let w = __anon0__w;
									tmp = new types_LitWord(w.symbol,w.context,w.index);
								} else {
									_hx_tmp = ((val) instanceof types_Path);
									if(_hx_tmp == true) {
										let __anon0__p = val;
										let p = __anon0__p;
										tmp = new types_LitPath(p.values,p.index);
									} else {
										tmp = val;
									}
								}
								blk1.push(tmp);
							}
							return blk;
						} else {
							_hx_tmp = field == runtime_Words.OWNER;
							if(_hx_tmp == true) {
								throw haxe_Exception.thrown("NYI");
							} else {
								throw haxe_Exception.thrown("bad");
							}
						}
					}
				}
			}
		}
	}
}
runtime_actions_datatypes_ObjectActions.__name__ = true;
runtime_actions_datatypes_ObjectActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_ObjectActions.prototype, {
	__class__: runtime_actions_datatypes_ObjectActions
});
class runtime_actions_datatypes_ErrorActions extends runtime_actions_datatypes_ObjectActions {
	constructor() {
		super();
	}
}
runtime_actions_datatypes_ErrorActions.__name__ = true;
runtime_actions_datatypes_ErrorActions.__super__ = runtime_actions_datatypes_ObjectActions;
Object.assign(runtime_actions_datatypes_ErrorActions.prototype, {
	__class__: runtime_actions_datatypes_ErrorActions
});
class runtime_actions_datatypes_TypesetActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	make(proto,spec) {
		return this.to(proto,spec);
	}
	to(proto,spec) {
		let _hx_tmp;
		if(((spec) instanceof types_Typeset) == true) {
			let __anon0__ts = spec;
			let ts = __anon0__ts;
			return ts;
		} else {
			_hx_tmp = ((spec) instanceof types_Block);
			if(_hx_tmp == true) {
				let __anon0__b = spec;
				let b = __anon0__b;
				let _g = [];
				let _gthis = b;
				let _this = b.values.slice(b.index);
				let result = new Array(_this.length);
				let _g1 = 0;
				let _g2 = _this.length;
				while(_g1 < _g2) {
					let i = _g1++;
					result[i] = _gthis.wrap(_this[i]);
				}
				let _g_current = 0;
				let _g_array = result;
				while(_g_current < _g_array.length) {
					let value = _g_array[_g_current++];
					let _g1;
					if(((value) instanceof types_Word) == true) {
						let __anon0__w = value;
						let w = __anon0__w;
						_g1 = w.get();
					} else {
						_g1 = value;
					}
					let tmp;
					if(js_Boot.__implements(_g1,types_base_IDatatype) == true) {
						let __anon0__dt = _g1;
						let dt = __anon0__dt;
						tmp = dt;
					} else {
						tmp = runtime_natives_Type_$q.of(value);
					}
					_g.push(tmp);
				}
				return types_Typeset.ofAny(_g);
			} else {
				throw haxe_Exception.thrown("bad");
			}
		}
	}
	form(value,buffer,arg,part) {
		let hasPart = arg != null;
		let types = value.types;
		let cnt = 0;
		buffer.appendLiteral("make typeset! [");
		part -= 15;
		let jsIterator = types.values();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			if(hasPart && part < 0) {
				return part;
			}
			let name = v.name;
			buffer.appendLiteral(name);
			buffer.values.push(32);
			part -= name.length - 1;
			++cnt;
		}
		if(cnt == 0) {
			buffer.values.push(93);
		} else {
			buffer.values[buffer.values.length - 1] = 93;
		}
		return part;
	}
	mold(value,buffer,_,_1,_2,arg,part,_3) {
		return this.form(value,buffer,arg,part);
	}
	compare(value1,value2,op) {
		if(((value2) instanceof types_Typeset) == true) {
			let __anon0__other = value2;
			let other = __anon0__other;
			switch(op) {
			case 0:case 1:case 2:case 9:case 11:
				let types1 = value1.types;
				let types2 = other.types;
				if(types1.size != types2.size) {
					return 1;
				}
				let jsIterator = types1.values();
				let _g_jsIterator = jsIterator;
				let _g_lastStep = jsIterator.next();
				while(!_g_lastStep.done) {
					let v = _g_lastStep.value;
					_g_lastStep = _g_jsIterator.next();
					let type = v;
					if(!types2.has(type)) {
						return 1;
					}
				}
				return 0;
			case 7:case 8:
				return Math.sign((value1.types.size - other.types.size));
			default:
				return -2;
			}
		} else {
			return -2;
		}
	}
	complement(value) {
		let _g = [];
		let _g1 = 0;
		let _g2 = Runtime.DATATYPES;
		while(_g1 < _g2.length) {
			let p = _g2[_g1];
			++_g1;
			if(!value.types.has(p[1])) {
				_g.push(p[1]);
			}
		}
		return new types_Typeset(new Set(_g));
	}
	and(value1,value2) {
		return runtime_actions_datatypes_TypesetActions.doBitwise(value1,value2,6);
	}
	or(value1,value2) {
		return runtime_actions_datatypes_TypesetActions.doBitwise(value1,value2,5);
	}
	xor(value1,value2) {
		return runtime_actions_datatypes_TypesetActions.doBitwise(value1,value2,7);
	}
	find(typeset,value,options) {
		if(((value) instanceof types_Datatype) == true) {
			let __anon0__type = value;
			let type = __anon0__type;
			if(typeset.types.has(type)) {
				return types_Logic.TRUE;
			} else {
				return types_Logic.FALSE;
			}
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
	}
	static doBitwise(left,right,op) {
		let set1 = left.types;
		let set2;
		let _hx_tmp;
		if(((right) instanceof types_Typeset) == true) {
			let __anon0__t = right;
			let t = __anon0__t;
			set2 = t.types;
		} else {
			_hx_tmp = ((right) instanceof types_Datatype);
			if(_hx_tmp == true) {
				let __anon0__d = right;
				let d = __anon0__d;
				set2 = new Set([d]);
			} else {
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
		}
		let tmp;
		switch(op) {
		case 5:case 9:
			tmp = new Set([...set1, ...set2]);
			break;
		case 6:case 10:
			tmp = util__$Set__$Set.filter(set1,function(d) {
				return set2.has(d);
			});
			break;
		case 7:case 12:
			let res = new Set(set1);
			let jsIterator = set2.values();
			let _g_jsIterator = jsIterator;
			let _g_lastStep = jsIterator.next();
			while(!_g_lastStep.done) {
				let v = _g_lastStep.value;
				_g_lastStep = _g_jsIterator.next();
				let d = v;
				if(res.has(d)) {
					res.delete(d);
				} else {
					res.add(d);
				}
			}
			tmp = res;
			break;
		case 11:
			tmp = util__$Set__$Set.filter(set1,function(d) {
				return !set2.has(d);
			});
			break;
		default:
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
		return new types_Typeset(tmp);
	}
}
runtime_actions_datatypes_TypesetActions.__name__ = true;
runtime_actions_datatypes_TypesetActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_TypesetActions.prototype, {
	__class__: runtime_actions_datatypes_TypesetActions
});
class runtime_actions_datatypes_HashActions extends runtime_actions_datatypes_BlockActions {
	constructor() {
		super();
	}
	makeThis(values,index,newlines) {
		return new types_Hash(values,index,newlines);
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		buffer.appendLiteral("make hash! ");
		return super.mold(value,buffer,isOnly,isAll,isFlat,arg,part - 11,indent);
	}
}
runtime_actions_datatypes_HashActions.__name__ = true;
runtime_actions_datatypes_HashActions.__super__ = runtime_actions_datatypes_BlockActions;
Object.assign(runtime_actions_datatypes_HashActions.prototype, {
	__class__: runtime_actions_datatypes_HashActions
});
class runtime_actions_datatypes_PairActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	make(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		if(((spec) instanceof types_Integer) == true) {
			let __anon0__i = spec;
			let i = __anon0__i;
			return new types_Pair(i.int,i.int);
		} else {
			_hx_tmp3 = ((spec) instanceof types_Float);
			if(_hx_tmp3 == true) {
				let __anon0__f = spec;
				let f = __anon0__f;
				let x = f.float | 0;
				return new types_Pair(x,x);
			} else {
				_hx_tmp2 = ((spec) instanceof types_Block);
				if(_hx_tmp2 == true) {
					let __anon0__b = spec;
					let b = __anon0__b;
					if(b.values.length - b.index != 2) {
						throw haxe_Exception.thrown("syntax malconstruct");
					}
					let _g = b.wrap(b.values[b.index]);
					let _g1 = b.wrap(b.values[b.index + 1]);
					let _hx_tmp;
					if(((_g1) instanceof types_Integer) == true) {
						_hx_tmp = ((_g1) instanceof types_Float);
						if(_hx_tmp == true) {
							let _hx_tmp;
							if(((_g) instanceof types_Integer) == true) {
								let __anon1__y = _g1;
								let __anon0__x = _g;
								let x = __anon0__x;
								let y = __anon1__y;
								return new types_Pair(x.asInt(),y.asInt());
							} else {
								_hx_tmp = ((_g) instanceof types_Float);
								if(_hx_tmp == true) {
									let __anon1__y = _g1;
									let __anon0__x = _g;
									let x = __anon0__x;
									let y = __anon1__y;
									return new types_Pair(x.asInt(),y.asInt());
								} else {
									throw haxe_Exception.thrown("syntax malconstruct");
								}
							}
						} else {
							let _hx_tmp;
							if(((_g) instanceof types_Integer) == true) {
								let __anon1__y = _g1;
								let __anon0__x = _g;
								let x = __anon0__x;
								let y = __anon1__y;
								return new types_Pair(x.asInt(),y.asInt());
							} else {
								_hx_tmp = ((_g) instanceof types_Float);
								if(_hx_tmp == true) {
									let __anon1__y = _g1;
									let __anon0__x = _g;
									let x = __anon0__x;
									let y = __anon1__y;
									return new types_Pair(x.asInt(),y.asInt());
								} else {
									throw haxe_Exception.thrown("syntax malconstruct");
								}
							}
						}
					} else {
						_hx_tmp = ((_g1) instanceof types_Float);
						if(_hx_tmp == true) {
							let _hx_tmp;
							if(((_g) instanceof types_Integer) == true) {
								let __anon1__y = _g1;
								let __anon0__x = _g;
								let x = __anon0__x;
								let y = __anon1__y;
								return new types_Pair(x.asInt(),y.asInt());
							} else {
								_hx_tmp = ((_g) instanceof types_Float);
								if(_hx_tmp == true) {
									let __anon1__y = _g1;
									let __anon0__x = _g;
									let x = __anon0__x;
									let y = __anon1__y;
									return new types_Pair(x.asInt(),y.asInt());
								} else {
									throw haxe_Exception.thrown("syntax malconstruct");
								}
							}
						} else {
							throw haxe_Exception.thrown("syntax malconstruct");
						}
					}
				} else {
					_hx_tmp1 = ((spec) instanceof types_base__$String);
					if(_hx_tmp1 == true) {
						let __anon0__s = spec;
						let s = __anon0__s;
						let _g = Tokenizer.parse(s.toJs());
						if(_g.length == 1) {
							let _g1 = _g[0];
							if(((_g1) instanceof types_Pair) == true) {
								let __anon0__p = _g1;
								let p = __anon0__p;
								return p;
							} else {
								throw haxe_Exception.thrown("Can't parse pair! from \"" + s.toJs() + "\"");
							}
						} else {
							throw haxe_Exception.thrown("Can't parse pair! from \"" + s.toJs() + "\"");
						}
					} else {
						_hx_tmp = ((spec) instanceof types_Pair);
						if(_hx_tmp == true) {
							let __anon0__p = spec;
							let p = __anon0__p;
							return p;
						} else {
							throw new runtime_actions_InvalidAction("Invalid action!");
						}
					}
				}
			}
		}
	}
	to(proto,spec) {
		return this.make(proto,spec);
	}
	form(value,buffer,arg,part) {
		let formed = value.x.toString();
		buffer.appendLiteral(formed);
		part -= formed.length;
		buffer.values.push(120);
		formed = value.y.toString();
		buffer.appendLiteral(formed);
		return part - 1 - formed.length;
	}
	mold(value,buffer,_,_1,_2,arg,part,_3) {
		return this.form(value,buffer,arg,part);
	}
	evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		let axis;
		let _hx_tmp;
		if(((element) instanceof types_Integer) == true) {
			let __anon0__i = element;
			let i = __anon0__i;
			if(i.int != 1 && i.int != 2) {
				throw haxe_Exception.thrown("invalid path");
			}
			axis = i.int;
		} else {
			_hx_tmp = ((element) instanceof types_Word);
			if(_hx_tmp == true) {
				let __anon0__w = element;
				let w = __anon0__w;
				axis = runtime_actions_datatypes_PairActions.getNamedIndex(w,path);
			} else {
				throw haxe_Exception.thrown("invalid path");
			}
		}
		if(((value) instanceof types_Integer) == true) {
			let __anon0__i = value;
			let i = __anon0__i;
			if(axis == 1) {
				return new types_Pair(i.int,parent.y);
			} else {
				return new types_Pair(parent.x,i.int);
			}
		} else if(value == null) {
			return new types_Integer(axis == 1 ? parent.x : parent.y);
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
	}
	compare(value1,value2,op) {
		let pair2;
		if(((value2) instanceof types_Pair) == true) {
			let __anon0__p = value2;
			let p = __anon0__p;
			pair2 = p;
		} else {
			return -2;
		}
		let diff = value1.x - pair2.x;
		if(diff == 0) {
			diff = value1.y - pair2.y;
		}
		return Math.sign(diff);
	}
	doMath(left,right,op) {
		let l;
		let tmp = ((left) instanceof types_Pair) ? left : null;
		if(tmp != null) {
			l = tmp;
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
		let x = 0;
		let y = 0;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((right) instanceof types_Pair) == true) {
			let __anon0__r = right;
			let r = __anon0__r;
			x = r.x;
			y = r.y;
		} else {
			_hx_tmp2 = ((right) instanceof types_Integer);
			if(_hx_tmp2 == true) {
				let __anon0__r = right;
				let r = __anon0__r;
				y = r.int;
				x = y;
			} else {
				_hx_tmp1 = ((right) instanceof types_Float);
				if(_hx_tmp1 == true) {
					let __anon0__r = right;
					let r = __anon0__r;
					let f = r.float;
					if(!isFinite(f)) {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
					switch(op) {
					case 2:
						return new types_Pair(l.x * f | 0,l.y * f | 0);
					case 3:
						return new types_Pair(l.x / f | 0,l.y / f | 0);
					default:
						y = f | 0;
						x = y;
					}
				} else {
					_hx_tmp = ((right) instanceof types_Percent);
					if(_hx_tmp == true) {
						let __anon0__r = right;
						let r = __anon0__r;
						let f = r.float;
						if(!isFinite(f)) {
							throw new runtime_actions_InvalidAction("Invalid action!");
						}
						switch(op) {
						case 2:
							return new types_Pair(l.x * f | 0,l.y * f | 0);
						case 3:
							return new types_Pair(l.x / f | 0,l.y / f | 0);
						default:
							y = f | 0;
							x = y;
						}
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
			}
		}
		return new types_Pair(runtime_actions_datatypes_IntegerActions.doMathOp(l.x,x,op,true) | 0,runtime_actions_datatypes_IntegerActions.doMathOp(l.y,y,op,true) | 0);
	}
	absolute(value) {
		return new types_Pair(Math.abs(value.x),Math.abs(value.y));
	}
	negate(value) {
		return new types_Pair(-value.x,-value.y);
	}
	add(value1,value2) {
		return this.doMath(value1,value2,0);
	}
	subtract(value1,value2) {
		return this.doMath(value1,value2,1);
	}
	multiply(value1,value2) {
		return this.doMath(value1,value2,2);
	}
	divide(value1,value2) {
		return this.doMath(value1,value2,3);
	}
	remainder(value1,value2) {
		return this.doMath(value1,value2,4);
	}
	round(value,options) {
		let tmp = options.to;
		let scale = tmp != null ? tmp.scale : null;
		if(((scale) instanceof types_Money)) {
			throw haxe_Exception.thrown("not related");
		}
		let y = 0;
		let scalexy;
		if(((scale) instanceof types_Pair) == true) {
			let __anon0__p = scale;
			let p = __anon0__p;
			y = p.y;
			options.to.scale = new types_Integer(p.x);
			scalexy = true;
		} else {
			scalexy = false;
		}
		let value1 = runtime_Actions.ACTIONS.get(10);
		let intActions;
		if(value1 != null) {
			intActions = value1;
		} else {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		let tmp1 = intActions.round(new types_Integer(value.x),options).int;
		if(scalexy) {
			options.to.scale.int = y;
		}
		return new types_Pair(tmp1,intActions.round(new types_Integer(value.y),options).int);
	}
	and(value1,value2) {
		return this.doMath(value1,value2,6);
	}
	or(value1,value2) {
		return this.doMath(value1,value2,5);
	}
	xor(value1,value2) {
		return this.doMath(value1,value2,7);
	}
	pick(value,index) {
		let idx;
		let _hx_tmp;
		if(((index) instanceof types_Integer) == true) {
			let __anon0__i = index;
			let i = __anon0__i;
			idx = i.int;
		} else {
			_hx_tmp = ((index) instanceof types_Word);
			if(_hx_tmp == true) {
				let __anon0__w = index;
				let w = __anon0__w;
				idx = runtime_actions_datatypes_PairActions.getNamedIndex(w,value);
			} else {
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
		}
		if(idx != 1 && idx != 2) {
			throw haxe_Exception.thrown("out of range");
		}
		return new types_Integer(idx == 1 ? value.x : value.y);
	}
	reverse(value,options) {
		return new types_Pair(value.y,value.x);
	}
	static getNamedIndex(w,ref) {
		let axis = w.symbol;
		if(axis != runtime_Words.X && axis != runtime_Words.Y) {
			if(((ref) instanceof types_Pair)) {
				throw haxe_Exception.thrown("cannot use");
			} else {
				throw haxe_Exception.thrown("invalid path");
			}
		}
		if(axis == runtime_Words.X) {
			return 1;
		} else {
			return 2;
		}
	}
}
runtime_actions_datatypes_PairActions.__name__ = true;
runtime_actions_datatypes_PairActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_PairActions.prototype, {
	__class__: runtime_actions_datatypes_PairActions
});
class runtime_actions_datatypes_PercentActions extends runtime_actions_datatypes_FloatActions {
	constructor() {
		super();
	}
	makeThis(f) {
		return new types_Percent(f);
	}
	mold(value,buffer,_,_1,_2,arg,part,_3) {
		return this.form(value,buffer,arg,part);
	}
}
runtime_actions_datatypes_PercentActions.__name__ = true;
runtime_actions_datatypes_PercentActions.__super__ = runtime_actions_datatypes_FloatActions;
Object.assign(runtime_actions_datatypes_PercentActions.prototype, {
	__class__: runtime_actions_datatypes_PercentActions
});
class runtime_actions_datatypes_TupleActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	make(proto,spec) {
		return this.to(proto,spec);
	}
	to(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		if(((spec) instanceof types_base__$Block) == true) {
			let __anon0__b = spec;
			let b = __anon0__b;
			let n = b.values.length - b.index;
			if(n > 12) {
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
			let tp = new Uint8ClampedArray(Math.max(n, 3));
			let _gthis = b;
			let _this = b.values.slice(b.index);
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = _gthis.wrap(_this[i]);
			}
			let _g_current = 0;
			let _g_array = result;
			while(_g_current < _g_array.length) {
				let _g_value = _g_array[_g_current];
				let _g_key = _g_current++;
				let i = _g_key;
				let v = _g_value;
				let value;
				let _hx_tmp;
				if(((v) instanceof types_base__$Integer) == true) {
					let __anon0__i = v;
					let i = __anon0__i;
					value = i.int;
				} else {
					_hx_tmp = ((v) instanceof types_Float);
					if(_hx_tmp == true) {
						let __anon0__f = v;
						let f = __anon0__f;
						value = f.float;
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
				tp[i] = value;
			}
			return new types_Tuple(tp);
		} else {
			_hx_tmp1 = ((spec) instanceof types_base__$String);
			if(_hx_tmp1 == true) {
				let __anon0__s = spec;
				let s = __anon0__s;
				let _g = Tokenizer.parse(s.toJs());
				if(_g.length == 1) {
					let _g1 = _g[0];
					if(((_g1) instanceof types_Tuple) == true) {
						let __anon0__t = _g1;
						let t = __anon0__t;
						return t;
					} else {
						throw haxe_Exception.thrown("Can't parse tuple! from \"" + s.toJs() + "\"");
					}
				} else {
					throw haxe_Exception.thrown("Can't parse tuple! from \"" + s.toJs() + "\"");
				}
			} else {
				_hx_tmp = ((spec) instanceof types_Tuple);
				if(_hx_tmp == true) {
					let __anon0__t = spec;
					let t = __anon0__t;
					return t;
				} else {
					throw new runtime_actions_InvalidAction("Invalid action!");
				}
			}
		}
	}
	form(value,buffer,arg,part) {
		let values = value.values;
		let size = values.length;
		let jsIterator = values.entries();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			let i = v[0];
			let formed = v[1].toString();
			buffer.appendLiteral(formed);
			if(i + 1 < size) {
				--part;
				buffer.values.push(46);
			}
			part -= formed.length;
		}
		return part;
	}
	mold(value,buffer,_,_1,_2,arg,part,_3) {
		return this.form(value,buffer,arg,part);
	}
	evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		if(((element) instanceof types_Integer) == true) {
			let __anon0__i = element;
			let i = __anon0__i;
			let _hx_tmp;
			if(value == null) {
				return this.pick(parent,i);
			} else {
				_hx_tmp = value;
				let value1 = _hx_tmp;
				let index = i.int;
				let tp = parent.values;
				let size = tp.length;
				if(index <= 0 || index > size) {
					throw haxe_Exception.thrown("out of range");
				}
				let _hx_tmp1;
				if(((value1) instanceof types_Integer) == true) {
					let __anon0__v = value1;
					let v = __anon0__v;
					tp = tp.slice();
					tp[index - 1] = v.int;
				} else {
					_hx_tmp1 = ((value1) instanceof types_None);
					if(_hx_tmp1 == true) {
						size = index > 3 ? index - 1 : 3;
						tp = tp.slice(0,size);
						if(index < 3) {
							let d = tp.fill(0,index - 1,null);
						}
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
				return new types_Tuple(tp);
			}
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
	}
	compare(value1,value2,op) {
		let tuple2;
		if(((value2) instanceof types_Tuple) == true) {
			let __anon0__t = value2;
			let t = __anon0__t;
			tuple2 = t;
		} else {
			return -2;
		}
		let t1 = value1.values;
		let t2 = tuple2.values;
		let sz1 = t1.length;
		let sz2 = t2.length;
		let sz = Math.max(sz1, sz2);
		let _g = 0;
		let _g1 = sz;
		while(_g < _g1) {
			let i = _g++;
			let v1 = i >= sz1 ? 0 : t1[i];
			let v2 = i >= sz2 ? 0 : t2[i];
			if(v1 != v2) {
				return Math.sign((v1 - v2));
			}
		}
		return 0;
	}
	doMath(left,right,op) {
		let isSwap = false;
		let l;
		if(((left) instanceof types_Tuple) == true) {
			let __anon0__t = left;
			let t = __anon0__t;
			l = t;
		} else {
			if(op == 1 || op == 3) {
				throw haxe_Exception.thrown("not related");
			}
			isSwap = true;
			[left, right] = [right, left];
			l = left;
		}
		let isFloat = false;
		let size2 = 0;
		let tp2 = null;
		let v = 0;
		let f2 = 0.0;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((right) instanceof types_Tuple) == true) {
			let __anon0__r = right;
			let r = __anon0__r;
			tp2 = r.values;
			size2 = tp2.length;
		} else {
			_hx_tmp2 = ((right) instanceof types_Integer);
			if(_hx_tmp2 == true) {
				let __anon0__r = right;
				let r = __anon0__r;
				v = r.int;
			} else {
				_hx_tmp1 = ((right) instanceof types_Float);
				if(_hx_tmp1 == true) {
					let __anon0__r = right;
					let r = __anon0__r;
					isFloat = true;
					f2 = r.float;
				} else {
					_hx_tmp = ((right) instanceof types_Percent);
					if(_hx_tmp == true) {
						let __anon0__r = right;
						let r = __anon0__r;
						isFloat = true;
						f2 = r.float;
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
			}
		}
		let tp1 = l.values;
		let size1 = tp1.length;
		if(isFloat) {
			tp1 = tp1.slice();
			let _g = 0;
			let _g1 = size1;
			while(_g < _g1) {
				let n = _g++;
				tp1[n] = runtime_actions_datatypes_FloatActions.doMathOp(tp1[n],f2,op);
			}
		} else {
			let size;
			if(size1 < size2) {
				tp1 = new Uint8ClampedArray(size2);
				tp1.set(l.values,null);
				size = size2;
			} else {
				tp1 = tp1.slice();
				size = size1;
			}
			let _g = 0;
			let _g1 = size;
			while(_g < _g1) {
				let n = _g++;
				if(size2 != 0) {
					v = n < size2 ? tp2[n] : 0;
				}
				let v1 = n < size1 ? tp1[n] : 0;
				tp1[n] = runtime_actions_datatypes_IntegerActions.doMathOp(v1,v,op,true);
			}
		}
		return new types_Tuple(tp1);
	}
	add(value1,value2) {
		return this.doMath(value1,value2,0);
	}
	subtract(value1,value2) {
		return this.doMath(value1,value2,1);
	}
	multiply(value1,value2) {
		return this.doMath(value1,value2,2);
	}
	divide(value1,value2) {
		return this.doMath(value1,value2,3);
	}
	remainder(value1,value2) {
		return this.doMath(value1,value2,4);
	}
	complement(value) {
		return new types_Tuple(value.values.map(function(v) {
			return ~v + 256;
		}));
	}
	and(value1,value2) {
		return this.doMath(value1,value2,6);
	}
	or(value1,value2) {
		return this.doMath(value1,value2,5);
	}
	xor(value1,value2) {
		return this.doMath(value1,value2,7);
	}
	length_q(tuple) {
		return new types_Integer(tuple.values.length);
	}
	pick(tuple,index) {
		let idx;
		if(((index) instanceof types_Integer) == true) {
			let __anon0__i = index;
			let i = __anon0__i;
			idx = i.int;
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
		let size = tuple.values.length;
		if(idx <= 0 || idx > size) {
			throw haxe_Exception.thrown("out of range");
		} else {
			return new types_Integer(tuple.values[idx - 1]);
		}
	}
	reverse(tuple,options) {
		let tp = tuple.values;
		let size = tp.length;
		let part = size;
		let skip = 1;
		let _g = options.part;
		if(_g != null) {
			let _g1 = _g.length;
			if(((_g1) instanceof types_Integer) == true) {
				let __anon0__i = _g1;
				let i = __anon0__i;
				part = i.int;
				if(part < 0) {
					throw haxe_Exception.thrown("out of range");
				}
			} else {
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
		}
		let _g1 = options.skip;
		if(_g1 != null) {
			let i = _g1.size;
			skip = i.int;
			if(skip == part) {
				return tuple;
			}
			if(skip <= 0) {
				throw haxe_Exception.thrown("out of range");
			}
			if(skip > part || part % skip != 0) {
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
		}
		if(skip == 1) {
			if(part == size) {
				return new types_Tuple(tp.slice().reverse());
			} else {
				let res = tuple.values.slice();
				let d = res.subarray(0,part).reverse();
				return new types_Tuple(res);
			}
		} else {
			if(part < size) {
				size = part;
			}
			let res = tp.slice();
			let temp = new Uint8ClampedArray(skip);
			let head = 0;
			let tail = size - skip;
			while(head < tail) {
				temp.set(res.subarray(head,head + skip),null);
				let d = res.copyWithin(head,tail,tail + skip);
				res.set(temp,tail);
				head += skip;
				tail -= skip;
			}
			return new types_Tuple(res);
		}
	}
}
runtime_actions_datatypes_TupleActions.__name__ = true;
runtime_actions_datatypes_TupleActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_TupleActions.prototype, {
	__class__: runtime_actions_datatypes_TupleActions
});
class runtime_actions_datatypes_MapActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	make(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((spec) instanceof types_Integer) == true) {
			return new types_Map([]);
		} else {
			_hx_tmp2 = ((spec) instanceof types_Float);
			if(_hx_tmp2 == true) {
				return new types_Map([]);
			} else {
				_hx_tmp1 = ((spec) instanceof types_base__$Block);
				if(_hx_tmp1 == true) {
					let __anon0__b = spec;
					let b = __anon0__b;
					if((b.values.length - b.index) % 2 != 0) {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
					let values = b.cloneValues();
					let i = 0;
					while(i < values.length) {
						values[i] = types_Map.preprocessKey(values[i]);
						i += 2;
					}
					return new types_Map(values);
				} else {
					_hx_tmp = ((spec) instanceof types_Map);
					if(_hx_tmp == true) {
						let __anon0__m = spec;
						let m = __anon0__m;
						return this.copy(m,runtime_actions_Copy.defaultOptions);
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
			}
		}
	}
	to(proto,spec) {
		if(((spec) instanceof types_Integer) || ((spec) instanceof types_Float)) {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
		return this.make(proto,spec);
	}
	form(value,buffer,arg,part) {
		let cycle;
		/*;
		cycle = */ //;
		[part, cycle] = Cycles.detect(value,buffer,part,false);
		if(cycle) {
			return part;
		}
		return runtime_actions_datatypes_MapActions.serialize(value,buffer,false,false,false,arg,part,false,0,false);
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		let cycle;
		/*;
		cycle = */ //;
		[part, cycle] = Cycles.detect(value,buffer,part,true);
		if(cycle) {
			return part;
		}
		buffer.appendLiteral("#[");
		let prev = part - 2;
		part = runtime_actions_datatypes_MapActions.serialize(value,buffer,false,isAll,isFlat,arg,prev,true,indent + 1,true);
		if(part != prev && indent > 0) {
			part = runtime_actions_datatypes_ObjectActions.doIndent(buffer,indent,part);
		}
		buffer.values.push(93);
		return part - 1;
	}
	evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		let table = parent.values;
		let key = parent.find(element,isCase ? 2 : 0);
		if(value != null) {
			if(key == null) {
				parent.set(element,value);
			} else {
				table[key + 1] = value;
			}
			return value;
		} else if(key == null || table[key + 1] == null) {
			return types_None.NONE;
		} else {
			return table[key + 1];
		}
	}
	compare(value1,value2,op) {
		if(((value2) instanceof types_Map) == true) {
			let __anon0__m = value2;
			let m = __anon0__m;
			switch(op) {
			case 0:case 1:case 2:case 9:case 11:
				return runtime_actions_datatypes_MapActions.compareEach(value1,m,op);
			case 7:case 8:
				return -1;
			default:
				return -2;
			}
		} else {
			return -2;
		}
	}
	clear(map) {
		map.values.length = 0;
		return map;
	}
	copy(value,options) {
		return new types_Map(value.values.slice());
	}
	find(map,value,options) {
		let op = options.same ? 9 : options._case ? 2 : 0;
		let table = map.values;
		let key = map.find(value,op);
		if(key == null || table[key + 1] == null) {
			return types_None.NONE;
		} else {
			let _g = table[key];
			if(((_g) instanceof types_SetWord) == true) {
				let __anon0__k = _g;
				let k = __anon0__k;
				return new types_Word(k.symbol,k.context,k.index);
			} else {
				let k = _g;
				return k;
			}
		}
	}
	length_q(map) {
		return new types_Integer(map.values.length / 2);
	}
	put(map,key,value,options) {
		map.set(key,value,options._case ? 2 : 0);
		return value;
	}
	remove(map,options) {
		let key;
		let tmp = options.key;
		let tmp1 = tmp != null ? tmp.keyArg : null;
		if(tmp1 != null) {
			key = tmp1;
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
		let table = map.values;
		let idx = map.find(key,2);
		if(idx != null && table[idx + 1] != null) {
			table[idx + 1] = null;
		}
		return map;
	}
	select(map,value,options) {
		let tmp = map.get(value,options.same ? 9 : options._case ? 2 : 0);
		if(tmp != null) {
			return tmp;
		} else {
			return types_None.NONE;
		}
	}
	static serialize(map,buffer,isOnly,isAll,isFlat,arg,part,isIndent,tabs,isMold) {
		if(map.values.length == 0) {
			return part;
		}
		let blank;
		if(isFlat) {
			isIndent = false;
			blank = 32;
		} else {
			if(isMold) {
				buffer.values.push(10);
				--part;
			}
			blank = 10;
		}
		let s = map.values;
		let i = 0;
		let tail = s.length;
		Cycles.push(map.values);
		while(i < tail) {
			let value = s[i];
			let next = s[i + 1];
			if(next != null) {
				if(isIndent) {
					part = runtime_actions_datatypes_ObjectActions.doIndent(buffer,tabs,part);
				}
				let value1 = value;
				value1 = value != null ? value : types_Tag.fromString("null");
				let value2 = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
				if(value2 == null) {
					throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
				}
				part = value2.mold(value1,buffer,isOnly,isAll,isFlat,arg,part,tabs);
				buffer.values.push(32);
				--part;
				let value3 = next;
				value3 = next != null ? next : types_Tag.fromString("null");
				let value4 = runtime_Actions.ACTIONS.get(value3.get_TYPE_KIND());
				if(value4 == null) {
					throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
				}
				part = value4.mold(value3,buffer,isOnly,isAll,isFlat,arg,part,tabs);
				if(isIndent || i + 2 < tail) {
					buffer.values.push(blank);
					--part;
				}
			}
			if(arg != null && part <= 0) {
				Cycles.pop();
				return part;
			}
			i += 2;
		}
		Cycles.pop();
		return part;
	}
	static compareEach(map1,map2,op) {
		let isSame = map1.values == map2.values;
		if(op == 9) {
			if(isSame) {
				return 0;
			} else {
				return -1;
			}
		}
		if(isSame) {
			return 0;
		}
		if(Cycles.find(map1.values)) {
			if(Cycles.find(map2.values)) {
				return 0;
			} else {
				return -1;
			}
		}
		let size1 = map1.values.length;
		let size2 = map2.values.length;
		if(size1 != size2) {
			switch(op) {
			case 0:case 1:case 2:case 11:
				return 1;
			default:
				return Math.sign((size1 - size2));
			}
		}
		if(size1 == 0) {
			return 0;
		}
		let n = 0;
		let table1 = map1.values;
		let res = 0;
		Cycles.push(table1);
		Cycles.push(map2.values);
		if(op == 2) {
			while(true) {
				let key1 = table1[n];
				let value1 = table1[n + 1];
				if(value1 == null) {
					n += 2;
					if(!(res == 0 && n != size1)) {
						break;
					} else {
						continue;
					}
				}
				let value2 = map2.get(key1,2);
				res = value2 == null ? 0 : runtime_Actions.compareValue(value1,value2,op);
				n += 2;
				if(!(res == 0 && n != size1)) {
					break;
				}
			}
		} else {
			while(true) {
				let key1 = table1[n];
				let value1 = table1[n + 1];
				if(value1 == null) {
					n += 2;
					if(!(res == 0 && n != size1)) {
						break;
					} else {
						continue;
					}
				}
				let value2 = map2.get(key1,0);
				if(value2 != null) {
					res = runtime_Actions.compareValue(value1,value2,0);
				} else {
					break;
				}
				n += 2;
				if(!(res == 0 && n != size1)) {
					break;
				}
			}
		}
		Cycles.popN(2);
		return 0;
	}
}
runtime_actions_datatypes_MapActions.__name__ = true;
runtime_actions_datatypes_MapActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_MapActions.prototype, {
	__class__: runtime_actions_datatypes_MapActions
});
class runtime_actions_datatypes_BinaryActions extends runtime_actions_datatypes_StringActions {
	constructor() {
		super();
	}
	form(value,buffer,arg,part) {
		return runtime_actions_datatypes_BinaryActions.serialize(value,buffer,false,false,false,arg,part,false);
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		return runtime_actions_datatypes_BinaryActions.serialize(value,buffer,isOnly,isAll,isFlat,arg,part,true);
	}
	evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		if(((element) instanceof types_Integer) == true) {
			let __anon0__i = element;
			let i = __anon0__i;
			let _hx_tmp;
			if(value == null) {
				return this.pick(parent,i);
			} else {
				_hx_tmp = value;
				let value1 = _hx_tmp;
				return this.poke(parent,i,value1);
			}
		} else {
			throw haxe_Exception.thrown("todo");
		}
	}
	compare(value1,value2,op) {
		if(((value2) instanceof types_Binary) == true) {
			let __anon0__bin2 = value2;
			let bin2 = __anon0__bin2;
			let bin1 = value1;
			let size1 = bin1.values.length - bin1.index;
			let size2 = bin2.values.length - bin2.index;
			if(size1 != size2) {
				switch(op) {
				case 0:case 1:case 2:case 10:case 11:
					return 1;
				default:
				}
			}
			if(size1 == 0) {
				return 0;
			}
			let len = Math.min(size1, size2);
			let v1 = null;
			let v2 = null;
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				v1 = bin1.wrap(bin1.values[bin1.index + i]).int;
				v2 = bin2.wrap(bin2.values[bin2.index + i]).int;
				if(v1 != v2) {
					break;
				}
			}
			if(v1 == v2) {
				return Math.sign((size1 - size2));
			} else {
				return Math.sign((v1 - v2));
			}
		} else {
			throw haxe_Exception.thrown("error");
		}
	}
	static serialize(bin,buffer,isOnly,isAll,isFlat,arg,part,isMold) {
		let head = bin.index;
		let tail = bin.values.length;
		let size = bin.values.length - bin.index;
		buffer.appendLiteral("#{");
		part -= 2;
		let bytes = 0;
		if(size > 30 && !isFlat) {
			buffer.values.push(10);
			--part;
		}
		while(head < tail) {
			buffer.appendLiteral(bin.values[head].toString(16).toUpperCase().padStart(2, "0"));
			++bytes;
			if(bytes % 32 == 0 && !isFlat) {
				buffer.values.push(10);
				--part;
			}
			part -= 2;
			if(arg != null && part <= 0) {
				return part;
			}
			++head;
		}
		if(size > 30 && bytes % 32 != 0 && !isFlat) {
			buffer.values.push(10);
			--part;
		}
		buffer.values.push(125);
		return part - 1;
	}
}
runtime_actions_datatypes_BinaryActions.__name__ = true;
runtime_actions_datatypes_BinaryActions.__super__ = runtime_actions_datatypes_StringActions;
Object.assign(runtime_actions_datatypes_BinaryActions.prototype, {
	__class__: runtime_actions_datatypes_BinaryActions
});
class runtime_actions_datatypes_TimeActions extends runtime_actions_datatypes_FloatActions {
	constructor() {
		super();
	}
	makeThis(f) {
		return new types_Time(f);
	}
	to(_,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		if(((spec) instanceof types_Time) == true) {
			let __anon0__t = spec;
			let t = __anon0__t;
			return t;
		} else {
			_hx_tmp3 = ((spec) instanceof types_Integer);
			if(_hx_tmp3 == true) {
				let __anon0__i = spec;
				let i = __anon0__i;
				return new types_Time(i.int);
			} else {
				_hx_tmp2 = ((spec) instanceof types_base__$Float);
				if(_hx_tmp2 == true) {
					let __anon0__f = spec;
					let f = __anon0__f;
					return new types_Time(f.float);
				} else {
					_hx_tmp1 = ((spec) instanceof types_base__$Block);
					if(_hx_tmp1 == true) {
						let __anon0__b = spec;
						let b = __anon0__b;
						let len = b.values.length - b.index;
						if(len > 3) {
							throw new runtime_actions_InvalidAction("Invalid action!");
						}
						let f1 = 0.0;
						let t = 0.0;
						let isNeg = false;
						let _g = 0;
						let _g1 = len;
						while(_g < _g1) {
							let i = _g++;
							let v = b.wrap(b.values[b.index + i]);
							let f;
							let _hx_tmp;
							if(((v) instanceof types_Float) == true) {
								let __anon0__v = v;
								if(i == 2) {
									let v = __anon0__v;
									f1 = v.float;
									f = f1;
								} else {
									_hx_tmp = ((v) instanceof types_Integer);
									if(_hx_tmp == true) {
										let __anon0__v = v;
										let v1 = __anon0__v;
										f = v1.int;
									} else {
										throw new runtime_actions_InvalidAction("Invalid action!");
									}
								}
							} else {
								_hx_tmp = ((v) instanceof types_Integer);
								if(_hx_tmp == true) {
									let __anon0__v = v;
									let v1 = __anon0__v;
									f = v1.int;
								} else {
									throw new runtime_actions_InvalidAction("Invalid action!");
								}
							}
							if(f < 0) {
								if(i == 0) {
									f = -f;
									isNeg = true;
								} else {
									throw new runtime_actions_InvalidAction("Invalid action!");
								}
							}
							switch(i) {
							case 0:
								t += f * 3600.0;
								break;
							case 1:
								t += f * 60.0;
								break;
							default:
								t += f;
							}
						}
						if(isNeg) {
							t = -t;
						}
						return new types_Time(t);
					} else {
						_hx_tmp = ((spec) instanceof types_base__$String);
						if(_hx_tmp == true) {
							let __anon0__s = spec;
							let s = __anon0__s;
							let _g = Tokenizer.parse(s.toJs());
							if(_g.length == 1) {
								let _g1 = _g[0];
								if(((_g1) instanceof types_Time) == true) {
									let __anon0__t = _g1;
									let t = __anon0__t;
									return t;
								} else {
									throw haxe_Exception.thrown("Can't parse time! from \"" + s.toJs() + "\"");
								}
							} else {
								throw haxe_Exception.thrown("Can't parse time! from \"" + s.toJs() + "\"");
							}
						} else {
							throw new runtime_actions_InvalidAction("Invalid action!");
						}
					}
				}
			}
		}
	}
	form(value,buffer,_,part) {
		return runtime_actions_datatypes_TimeActions.serialize(value,buffer,part);
	}
	mold(value,buffer,_,_1,_2,_3,part,_4) {
		return runtime_actions_datatypes_TimeActions.serialize(value,buffer,part);
	}
	evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		let time = parent.float;
		let field;
		let _hx_tmp;
		if(((element) instanceof types_Integer) == true) {
			let __anon0__i = element;
			let i = __anon0__i;
			field = i.int;
		} else {
			_hx_tmp = ((element) instanceof types_Word);
			if(_hx_tmp == true) {
				let __anon0__w = element;
				let w = __anon0__w;
				field = runtime_actions_datatypes_TimeActions.getNamedIndex(w,path);
			} else {
				field = -1;
			}
		}
		if(field <= 0 || field > 3) {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
		let _hx_tmp1;
		if(value == null) {
			return runtime_actions_datatypes_TimeActions.getField(time,field);
		} else {
			_hx_tmp1 = value;
			let value1 = _hx_tmp1;
			let tmp;
			switch(field) {
			case 1:
				if(((value1) instanceof types_Integer) == true) {
					let __anon0__i = value1;
					let i = __anon0__i;
					tmp = time - (runtime_actions_datatypes_TimeActions.getHours(time) - i.int) * 3600.0;
				} else {
					throw new runtime_actions_InvalidAction("Invalid action!");
				}
				break;
			case 2:
				if(((value1) instanceof types_Integer) == true) {
					let __anon0__i = value1;
					let i = __anon0__i;
					tmp = time - (runtime_actions_datatypes_TimeActions.getMinutes(time) - i.int) * 60.0;
				} else {
					throw new runtime_actions_InvalidAction("Invalid action!");
				}
				break;
			case 3:
				let fval;
				let _hx_tmp;
				if(((value1) instanceof types_Integer) == true) {
					let __anon0__i = value1;
					let i = __anon0__i;
					fval = i.int;
				} else {
					_hx_tmp = ((value1) instanceof types_Float);
					if(_hx_tmp == true) {
						let __anon0__f = value1;
						let f = __anon0__f;
						fval = f.float;
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
				tmp = time - (time % 60.0 - fval);
				break;
			default:
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
			return new types_Time(tmp);
		}
	}
	even_q(value) {
		let t = value.float;
		if(t >= 0) {
			t += 1e-6;
		} else {
			t -= 1e-6;
		}
		if(((t % 60.0 | 0) & 1) == 0) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
	odd_q(value) {
		let t = value.float;
		if(t >= 0) {
			t += 1e-6;
		} else {
			t -= 1e-6;
		}
		if(((t % 60.0 | 0) & 1) != 0) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
	round(value,options) {
		let ret = super.round(value,options);
		if(((ret) instanceof types_Time)) {
			return ret;
		} else {
			return new types_Time(ret.asFloat());
		}
	}
	pick(value,index) {
		let idx;
		let _hx_tmp;
		if(((index) instanceof types_Integer) == true) {
			let __anon0__i = index;
			let i = __anon0__i;
			idx = i.int;
		} else {
			_hx_tmp = ((index) instanceof types_Word);
			if(_hx_tmp == true) {
				let __anon0__w = index;
				let w = __anon0__w;
				idx = runtime_actions_datatypes_TimeActions.getNamedIndex(w,value);
			} else {
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
		}
		if(idx < 1 || idx > 3) {
			throw haxe_Exception.thrown("out of range");
		}
		return runtime_actions_datatypes_TimeActions.getField(value.float,idx);
	}
	static getHours(time) {
		time /= 3600.0;
		return Math.trunc(time);
	}
	static getMinutes(time) {
		if(time < 0) {
			time = -time;
		}
		return Math.floor(time % 3600.0 / 60.0);
	}
	static getNamedIndex(w,ref) {
		let sym = w.symbol;
		let idx = -1;
		if(sym == runtime_Words.HOUR) {
			idx = 1;
		} else if(sym == runtime_Words.MINUTE) {
			idx = 2;
		} else if(sym == runtime_Words.SECOND) {
			idx = 3;
		} else if(((ref) instanceof types_Time)) {
			throw haxe_Exception.thrown("cannot use");
		}
		return idx;
	}
	static getField(time,field) {
		switch(field) {
		case 1:
			return new types_Integer(runtime_actions_datatypes_TimeActions.getHours(time));
		case 2:
			return new types_Integer(runtime_actions_datatypes_TimeActions.getMinutes(time));
		case 3:
			return new types_Float(time % 60.0);
		default:
			throw haxe_Exception.thrown("bad");
		}
	}
	static serialize(time,buffer,part) {
		let t;
		if(time.float < 0.0) {
			buffer.values.push(45);
			t = Math.abs(time.float);
		} else {
			t = time.float;
		}
		let formed = runtime_actions_datatypes_TimeActions.getHours(t).toString();
		buffer.appendLiteral(formed);
		buffer.values.push(58);
		formed = runtime_actions_datatypes_TimeActions.getMinutes(t).toString().padStart(2, "0");
		buffer.appendLiteral(formed);
		buffer.values.push(58);
		let sec = t % 60.0;
		formed = sec < 1E-6 ? "00" : sec.toString().padStart(2, "0");
		if(formed.charCodeAt(1) == 46) {
			formed = "0" + formed;
		}
		buffer.appendLiteral(formed);
		return formed.length - 1;
	}
}
runtime_actions_datatypes_TimeActions.__name__ = true;
runtime_actions_datatypes_TimeActions.__super__ = runtime_actions_datatypes_FloatActions;
Object.assign(runtime_actions_datatypes_TimeActions.prototype, {
	__class__: runtime_actions_datatypes_TimeActions
});
class runtime_actions_datatypes_TagActions extends runtime_actions_datatypes_StringActions {
	constructor() {
		super();
	}
	form(value,buffer,arg,part) {
		buffer.values.push(60);
		part = super.form(value,buffer,arg,part - 1);
		buffer.values.push(62);
		return part - 1;
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		return this.form(value,buffer,arg,part);
	}
}
runtime_actions_datatypes_TagActions.__name__ = true;
runtime_actions_datatypes_TagActions.__super__ = runtime_actions_datatypes_StringActions;
Object.assign(runtime_actions_datatypes_TagActions.prototype, {
	__class__: runtime_actions_datatypes_TagActions
});
class runtime_actions_datatypes_EmailActions extends runtime_actions_datatypes_StringActions {
	constructor() {
		super();
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		return this.form(value,buffer,arg,part);
	}
}
runtime_actions_datatypes_EmailActions.__name__ = true;
runtime_actions_datatypes_EmailActions.__super__ = runtime_actions_datatypes_StringActions;
Object.assign(runtime_actions_datatypes_EmailActions.prototype, {
	__class__: runtime_actions_datatypes_EmailActions
});
class runtime_actions_datatypes_DateActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	make(proto,spec) {
		if(((spec) instanceof types_base__$Block) == true) {
			let __anon0__b = spec;
			let b = __anon0__b;
			return runtime_actions_datatypes_DateActions._create(b,false);
		} else {
			throw haxe_Exception.thrown("bad");
		}
	}
	to(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		if(((spec) instanceof types_Date) == true) {
			let __anon0__d = spec;
			let d = __anon0__d;
			return new types_Date(new Date(d.date),d.zone);
		} else {
			_hx_tmp1 = ((spec) instanceof types_base__$Block);
			if(_hx_tmp1 == true) {
				let __anon0__b = spec;
				let b = __anon0__b;
				return runtime_actions_datatypes_DateActions._create(b,true);
			} else {
				_hx_tmp = ((spec) instanceof types_Integer);
				if(_hx_tmp == true) {
					let __anon0__i = spec;
					let i = __anon0__i;
					let int = i.int;
					let d = runtime_actions_datatypes_DateActions.daysToDate((int / 86400 | 0) + runtime_actions_datatypes_DateActions.jan1stOf(new Date(258211840)),0,true);
					d.setTime(d.getTime() + int % 86400);
					return new types_Date(d);
				} else {
					throw new runtime_actions_InvalidAction("Invalid action!");
				}
			}
		}
	}
	form(value,buffer,arg,part) {
		return this.mold(value,buffer,false,false,false,arg,part,0);
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		let year = value.date.getFullYear();
		let sep = year < 0 ? 47 : 45;
		let formed = value.date.getDate().toString();
		buffer.appendLiteral(formed);
		part -= formed.length;
		buffer.values.push(sep);
		buffer.appendLiteral(runtime_actions_datatypes_DateActions.MONTHS[value.date.getMonth() + 1 - 1]);
		buffer.values.push(sep);
		if(year < 0) {
			year = -year;
			buffer.values.push(45);
		}
		formed = year.toString();
		if(year < 100) {
			buffer.values.push(48);
			if(year < 10) {
				buffer.values.push(48);
			}
			part -= 5;
		} else {
			part -= formed.length;
		}
		buffer.appendLiteral(formed);
		let hour = value.date.getHours();
		let minute = value.date.getMinutes();
		let second = value.date.getSeconds();
		let ms = value.date.getMilliseconds();
		if(hour != 0 || minute != 0 || second != 0 || ms != 0) {
			buffer.values.push(47);
			formed = hour.toString();
			buffer.appendLiteral(formed);
			part -= formed.length;
			buffer.values.push(58);
			--part;
			if(minute < 10) {
				buffer.values.push(48);
				--part;
			}
			formed = minute.toString();
			buffer.appendLiteral(formed);
			part -= formed.length;
			buffer.values.push(58);
			--part;
			if(second < 10) {
				buffer.values.push(48);
				--part;
			}
			formed = second.toString();
			buffer.appendLiteral(formed);
			part -= formed.length;
			if(ms != 0) {
				buffer.values.push(46);
				formed = ms.toString();
				buffer.appendLiteral(formed);
				part -= formed.length + 1;
			}
			let zone = value.zone;
			if(zone.float != 0) {
				buffer.values.push(zone.float < 0 ? 45 : 43);
				let hour = zone.float < 0 ? Math.ceil(zone.float / 3600) : Math.floor(zone.float / 3600);
				if(hour < 10) {
					buffer.values.push(48);
					--part;
				}
				formed = hour.toString();
				buffer.appendLiteral(formed);
				part -= formed.length + 1;
				buffer.values.push(58);
				let minute = Math.floor(Math.abs(zone.float) / 60) % 60;
				if(minute < 10) {
					buffer.values.push(48);
					--part;
				}
				formed = minute.toString();
				buffer.appendLiteral(formed);
				part -= formed.length + 1;
			}
		}
		return part;
	}
	evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		let idx;
		let _hx_tmp;
		if(((element) instanceof types_Integer) == true) {
			let __anon0__i = element;
			let i = __anon0__i;
			idx = i.int;
		} else {
			_hx_tmp = ((element) instanceof types_Word);
			if(_hx_tmp == true) {
				let __anon0__w = element;
				let w = __anon0__w;
				idx = runtime_actions_datatypes_DateActions.getNamedIndex(w);
			} else {
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
		}
		if(idx < 1 || idx > 14) {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
		if(value != null) {
			let v;
			switch(idx) {
			case 2:case 3:case 4:case 7:case 8:case 10:case 11:case 13:case 14:
				if(((value) instanceof types_Integer) == true) {
					let __anon0__i = value;
					let i = __anon0__i;
					v = i.int;
				} else {
					throw new runtime_actions_InvalidAction("Invalid action!");
				}
				break;
			default:
				v = 0;
			}
			let dt = parent;
			let d = dt.date;
			let hasTime = dt.date.getHours() + dt.date.getMinutes() + dt.date.getSeconds() + dt.date.getMilliseconds() != 0;
			switch(idx) {
			case 1:
				if(((value) instanceof types_Date) == true) {
					let __anon0__v = value;
					let v = __anon0__v;
					let d = v.date;
					dt.date.setFullYear(d.getFullYear());
					dt.date.setMonth(d.getMonth());
					dt.date.setDate(d.getDate());
				} else {
					throw new runtime_actions_InvalidAction("Invalid action!");
				}
				break;
			case 2:
				dt.date.setFullYear(v);
				break;
			case 3:
				dt.date.setMonth(v - 1);
				break;
			case 4:
				dt.date.setDate(v);
				break;
			case 6:
				let _hx_tmp;
				if(((value) instanceof types_None) == true) {
					dt.date.setHours(0);
					dt.date.setMinutes(0);
					dt.date.setSeconds(0);
					dt.date.setMilliseconds(0);
				} else {
					_hx_tmp = ((value) instanceof types_Time);
					if(_hx_tmp == true) {
						let __anon0__v = value;
						let v = __anon0__v;
						dt.date.setHours(v.float < 0 ? Math.ceil(v.float / 3600) : Math.floor(v.float / 3600));
						dt.date.setMinutes(Math.floor(Math.abs(v.float) / 60) % 60);
						dt.date.setSeconds(v.float % 60 | 0);
						dt.date.setMilliseconds((v.float % 60 - (v.float % 60 | 0)) * 1000 | 0);
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
				break;
			case 7:
				dt.date.setHours(v);
				break;
			case 8:
				dt.date.setMinutes(v);
				break;
			case 9:
				let _hx_tmp1;
				if(((value) instanceof types_Integer) == true) {
					let __anon0__v = value;
					let v = __anon0__v;
					dt.date.setSeconds(v.int);
				} else {
					_hx_tmp1 = ((value) instanceof types_Float);
					if(_hx_tmp1 == true) {
						let __anon0__v = value;
						let v = __anon0__v;
						dt.date.setSeconds(v.float | 0);
						dt.date.setMilliseconds((v.float - (v.float | 0)) * 1000 | 0);
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
				break;
			case 10:
				let days = runtime_actions_datatypes_DateActions.dateToDays(d);
				dt.date = runtime_actions_datatypes_DateActions.daysToDate(days + (v - 1) + (days + 2) % 7,dt.zone.float,hasTime);
				break;
			case 11:
				dt.date = runtime_actions_datatypes_DateActions.daysToDate(v + runtime_actions_datatypes_DateActions.jan1stOf(d) - 1,dt.zone.float,hasTime);
				break;
			case 5:case 12:
				if(((value) instanceof types_Time) == true) {
					let __anon0__v = value;
					let v = __anon0__v;
					dt.zone = v;
				} else {
					throw new runtime_actions_InvalidAction("Invalid action!");
				}
				break;
			case 13:
				let days1 = runtime_actions_datatypes_DateActions.jan1stOf(d);
				if(v > 1) {
					let wd = (days1 + 3) % 7;
					days1 += (v - 2) * 7 + 7 - wd;
				}
				dt.date = runtime_actions_datatypes_DateActions.daysToDate(days1,dt.zone.float,hasTime);
				break;
			case 14:
				/*;
				let wd = ;
				let d1 = ;
				*/ //;
				let [wd, d1] = runtime_actions_datatypes_DateActions.w11of(d);
				dt.date = runtime_actions_datatypes_DateActions.daysToDate((v - 1) * 7 + d1,dt.zone.float,hasTime);
				break;
			default:
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
			return value;
		} else {
			return runtime_actions_datatypes_DateActions.getField(parent,idx);
		}
	}
	compare(value1,value2,op) {
		if(((value2) instanceof types_Date) == true) {
			let __anon0__v2 = value2;
			let v2 = __anon0__v2;
			let t1 = +value1.date;
			let t2 = +v2.date;
			switch(op) {
			case 0:case 1:case 2:case 9:case 11:
				return +((t1 != t2));
			default:
				if(t1 == t2) {
					return 0;
				} else if(t1 < t2) {
					return -1;
				} else {
					return 1;
				}
			}
		} else {
			return -2;
		}
	}
	doMath(left,right,op) {
		let l = js_Boot.__cast(left , types_Date);
		if(!(op == 0 || op == 1)) {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
		let _hx_tmp;
		let _hx_tmp1;
		if(((right) instanceof types_Integer) == true) {
			let __anon0__r = right;
			let r = __anon0__r;
			let dt = new Date(l.date);
			dt.setDate(op == 0 ? dt.getDate() + r.int : dt.getDate() - r.int);
			return new types_Date(dt,l.zone);
		} else {
			_hx_tmp1 = ((right) instanceof types_Time);
			if(_hx_tmp1 == true) {
				let __anon0__r = right;
				let r = __anon0__r;
				let h = r.float < 0 ? Math.ceil(r.float / 3600) : Math.floor(r.float / 3600);
				let m = Math.floor(Math.abs(r.float) / 60) % 60;
				let s = r.float % 60 | 0;
				let ms = (r.float % 60 - s) * 1000 | 0;
				let dt = l.date;
				if(op == 0) {
					dt.setHours(dt.getHours() + h);
					dt.setMinutes(dt.getMinutes() + m);
					dt.setSeconds(dt.getSeconds() + s);
					dt.setMilliseconds(dt.getMilliseconds() + ms);
				} else {
					dt.setHours(dt.getHours() - h);
					dt.setMinutes(dt.getMinutes() - m);
					dt.setSeconds(dt.getSeconds() - s);
					dt.setMilliseconds(dt.getMilliseconds() - ms);
				}
				return new types_Date(dt,l.zone);
			} else {
				_hx_tmp = ((right) instanceof types_Date);
				if(_hx_tmp == true) {
					let __anon0__r = right;
					let r = __anon0__r;
					if(op == 0) {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
					return new types_Integer(l.date - r.date);
				} else {
					throw new runtime_actions_InvalidAction("Invalid action!");
				}
			}
		}
	}
	add(value1,value2) {
		return this.doMath(value1,value2,0);
	}
	subtract(value1,value2) {
		return this.doMath(value1,value2,1);
	}
	pick(date,index) {
		let idx;
		let _hx_tmp;
		if(((index) instanceof types_Integer) == true) {
			let __anon0__i = index;
			let i = __anon0__i;
			idx = i.int;
		} else {
			_hx_tmp = ((index) instanceof types_Word);
			if(_hx_tmp == true) {
				let __anon0__w = index;
				let w = __anon0__w;
				idx = runtime_actions_datatypes_DateActions.getNamedIndex(w);
			} else {
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
		}
		if(idx < 1 || idx > 14) {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
		return runtime_actions_datatypes_DateActions.getField(date,idx);
	}
	static getNamedIndex(w) {
		let idx = runtime_actions_datatypes_DateActions.ACCESSORS.indexOf(w.symbol);
		if(idx > 11) {
			return idx - 1;
		} else {
			return idx;
		}
	}
	static getField(d,field) {
		switch(field) {
		case 1:
			return d.getDate();
		case 2:
			return new types_Integer(d.date.getFullYear());
		case 3:
			return new types_Integer(d.date.getMonth() + 1);
		case 4:
			return new types_Integer(d.date.getDate());
		case 6:
			let h = d.date.getHours();
			let m = d.date.getMinutes();
			let s = d.date.getSeconds();
			let ms = d.date.getMilliseconds();
			if(h + m + s + ms == 0) {
				return types_None.NONE;
			} else {
				return new types_Time((Math.abs(h) * 3600 + m * 60 + (ms == 0 ? s : s + ms / 1000)) * Math.sign(h));
			}
			break;
		case 7:
			return new types_Integer(d.date.getHours());
		case 8:
			return new types_Integer(d.date.getMinutes());
		case 9:
			let s1 = d.date.getSeconds();
			let ms1 = d.date.getMilliseconds();
			return new types_Float(ms1 == 0 ? s1 : s1 + ms1 / 1000);
		case 10:
			return new types_Integer(d.date.getDay() + 1 - 1);
		case 11:
			return new types_Integer(runtime_actions_datatypes_DateActions.getYearday(d.date));
		case 5:case 12:
			return d.zone;
		case 13:
			let wd = (runtime_actions_datatypes_DateActions.jan1stOf(d.date) + 3) % 7;
			let yd = runtime_actions_datatypes_DateActions.getYearday(d.date);
			yd = yd <= 7 - wd ? 1 : (yd + wd - 1) % 7 + 1;
			return new types_Integer(yd);
		case 14:
			/*;
			let wd1 = ;
			let d1 = ;
			*/ //;
			let [wd1, d1] = runtime_actions_datatypes_DateActions.w11of(d.date);
			let days = runtime_actions_datatypes_DateActions.dateToDays(d.date);
			let w;
			if(days >= d1) {
				let y = 1 + d.date.getFullYear();
				let dt = new Date(d.date);
				dt.setFullYear(y);
				let d2;
				/*;
				d2 = */ //;
				[wd1, d2] = runtime_actions_datatypes_DateActions.w11of(dt);
				w = days < d2 ? ((days - d1) / 7 | 0) + 1 : 1;
			} else {
				switch(wd1) {
				case 1:case 2:case 3:case 4:
					w = 1;
					break;
				case 5:
					w = 53;
					break;
				case 6:
					w = runtime_actions_datatypes_DateActions.isLeapYear(d.date.getFullYear() - 1) ? 53 : 52;
					break;
				case 7:
					w = 52;
					break;
				default:
					throw new runtime_actions_InvalidAction("Invalid action!");
				}
			}
			return new types_Integer(w);
		default:
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
	}
	static daysToDate(days,tz,hasTime) {
		let y = (10000 * days + 14780) / 3652425 | 0;
		let dd = days - (365 * y + (y / 4 | 0) - (y / 100 | 0) + (y / 400 | 0));
		if(dd < 0) {
			--y;
			dd = days - (365 * y + (y / 4 | 0) - (y / 100 | 0) + (y / 400 | 0));
		}
		let mi = (100 * dd + 52) / 3060 | 0;
		y += (mi + 2) / 12 | 0;
		let d = dd - ((mi * 306 + 5) / 10 | 0) + 1;
		d = y << 17 | (mi + 2) % 12 << 12 | d << 7 | tz;
		return new Date(d & -65537 | +(hasTime) << 16);
	}
	static dateToDays(d) {
		let y = d.getFullYear();
		let m = d.getMonth() + 1;
		m = (m + 9) % 12;
		y -= m / 10 | 0;
		return 365 * y + (y / 4 | 0) - (y / 100 | 0) + (y / 400 | 0) + ((m * 306 + 5) / 10 | 0) + (d.getDate() - 1);
	}
	static isLeapYear(year) {
		if(!((year & 3) == 0 && year % 100 != 0)) {
			return year % 400 == 0;
		} else {
			return true;
		}
	}
	static jan1stOf(d) {
		d = new Date(d);
		d.setDate(1);
		d.setMonth(0);
		return runtime_actions_datatypes_DateActions.dateToDays(d);
	}
	static getYearday(d) {
		return runtime_actions_datatypes_DateActions.dateToDays(d) - runtime_actions_datatypes_DateActions.jan1stOf(d) + 1;
	}
	static w11of(d) {
		let days = runtime_actions_datatypes_DateActions.jan1stOf(d);
		let wd = (days + 2) % 7 + 1;
		return [wd,days + (wd < 5 ? 1 : 8) - wd];
	}
	static _create(spec,isNorm) {
		let zone = null;
		let year = 0;
		let month = 0;
		let day = 0;
		let hours = 0;
		let minutes = 0;
		let seconds = 0;
		let zone1 = 0;
		let ftime = types_Time.ZERO;
		let zoneT = types_Time.ZERO;
		let secT = types_Time.ZERO;
		let cnt = 0;
		let _gthis = spec;
		let _this = spec.values.slice(spec.index);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _gthis.wrap(_this[i]);
		}
		let _g_current = 0;
		let _g_array = result;
		while(_g_current < _g_array.length) {
			let value = _g_array[_g_current++];
			let i = 0;
			let t = types_Time.ZERO;
			let v;
			if(((value) instanceof types_Word) == true) {
				let __anon0__w = value;
				let w = __anon0__w;
				v = w.get();
			} else {
				v = value;
			}
			let _hx_tmp;
			let _hx_tmp1;
			let _hx_tmp2 = ((v) instanceof types_Integer) ? v : null;
			if(_hx_tmp2 == null) {
				_hx_tmp1 = ((v) instanceof types_Float) ? v : null;
				if(_hx_tmp1 == null) {
					_hx_tmp = ((v) instanceof types_Time);
					if(_hx_tmp == true) {
						let __anon0__time = v;
						let time = __anon0__time;
						if(cnt <= 3) {
							throw haxe_Exception.thrown("bad");
						}
						t = time;
					} else {
						throw haxe_Exception.thrown("bad");
					}
				} else {
					let _g = _hx_tmp1.get_TYPE_KIND();
					let float = _hx_tmp1.float;
					i = float | 0;
				}
			} else {
				let _g = _hx_tmp2.get_TYPE_KIND();
				let int = _hx_tmp2.int;
				i = int;
			}
			switch(cnt) {
			case 0:
				day = i;
				break;
			case 1:
				month = i - 1;
				break;
			case 2:
				year = i;
				break;
			case 3:
				hours = i;
				ftime = t;
				break;
			case 4:
				minutes = i;
				zoneT = t;
				break;
			case 5:
				seconds = i;
				secT = t;
				break;
			case 6:
				zone1 = i;
				zoneT = t;
				break;
			}
			++cnt;
		}
		if(cnt < 3 && cnt > 7 || cnt == 4 && hours != 0 || cnt == 5 && hours != 0) {
			throw haxe_Exception.thrown("bad");
		}
		if(cnt == 5 || cnt == 7) {
			let i;
			let mn;
			if((cnt == 5 && minutes == 0 || cnt == 7 && zone1 == 0) && zoneT.float != 0.0) {
				i = zoneT.float < 0 ? Math.ceil(zoneT.float / 3600) : Math.floor(zoneT.float / 3600);
				mn = Math.floor(Math.abs(zoneT.float) / 60) % 60 / 15 | 0;
			} else {
				i = cnt == 5 && minutes != 0 ? minutes : zone1;
				mn = 0;
			}
			if(cnt == 7 && zoneT.float == 0.0 && (zone1 > 15 || zone1 < -15)) {
				throw haxe_Exception.thrown("bad");
			}
			let isNeg;
			if(i < 0) {
				i = -i;
				isNeg = true;
			} else {
				isNeg = false;
			}
			zone1 = i << 2 & 127 | mn;
			if(isNeg) {
				zone1 |= 64;
			}
		}
		if(cnt == 6 || cnt == 7) {
			let t = hours * 3600 + minutes * 60;
			ftime.float = secT.float == 0.0 ? t + seconds : t + secT.float;
		}
		if(day >= 100 && day > year) {
			[day, year] = [year, day];
		}
		let date = new Date(year,month,day,hours,minutes,seconds);
		if(!isNorm) {
			let h = ftime.float < 0 ? Math.ceil(ftime.float / 3600) : Math.floor(ftime.float / 3600);
			minutes = cnt == 4 || cnt == 5 ? Math.floor(Math.abs(ftime.float) / 60) % 60 : date.getMinutes();
			if(year != date.getFullYear() || month != date.getMonth() || day != date.getDate() || ftime.float != 0.0 && (h < 0 || h > 23 || minutes != date.getMinutes()) || ftime.float == 0.0 && (hours != date.getHours() || minutes != date.getMinutes())) {
				throw haxe_Exception.thrown("bad");
			}
		}
		return new types_Date(date,new types_Time(zone1));
	}
}
runtime_actions_datatypes_DateActions.__name__ = true;
runtime_actions_datatypes_DateActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_DateActions.prototype, {
	__class__: runtime_actions_datatypes_DateActions
});
class runtime_actions_datatypes_MoneyActions extends runtime_actions_datatypes_ValueActions {
	constructor() {
		super();
	}
	make(proto,spec) {
		let _hx_tmp;
		if(((spec) instanceof types_Word) == true) {
			let __anon0__w = spec;
			let w = __anon0__w;
			return new types_Money(util_Dec64.ZERO,w);
		} else {
			_hx_tmp = ((spec) instanceof types_Block);
			if(_hx_tmp == true) {
				let __anon0__b = spec;
				let b = __anon0__b;
				if(b.values.length - b.index < 1) {
					throw new runtime_actions_InvalidAction("Invalid action!");
				}
				let i = 0;
				let region = null;
				let _g = b.values[b.index + i];
				if(((_g) instanceof types_Word) == true) {
					let __anon0__w = _g;
					let w = __anon0__w;
					region = w;
					++i;
					if(b.values.length - b.index < 2) {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
				let _g1 = b.values[b.index + i];
				let _hx_tmp;
				if(((_g1) instanceof types_Float) == true) {
					let __anon0__f = _g1;
					let f = __anon0__f;
					return runtime_actions_datatypes_MoneyActions.fromFloat(f,region);
				} else {
					_hx_tmp = ((_g1) instanceof types_Integer);
					if(_hx_tmp == true) {
						let __anon0__i1 = _g1;
						let i1 = __anon0__i1;
						++i;
						if(b.values.length - b.index < i + 1) {
							return runtime_actions_datatypes_MoneyActions.fromInteger(i1,region);
						} else {
							let _g = b.values[b.index + i];
							if(((_g) instanceof types_Integer) == true) {
								let __anon0__i2 = _g;
								let i2 = __anon0__i2;
								let int1 = i1.int;
								let int2 = i2.int;
								if(int2 < 0) {
									throw new runtime_actions_InvalidAction("Invalid action!");
								}
								let s = int2.toString().padStart(5, "0");
								if(s.length > 5) {
									throw new runtime_actions_InvalidAction("Invalid action!");
								}
								return new types_Money(util_Dec64.fromString("" + int1 + "." + s),region);
							} else {
								throw new runtime_actions_InvalidAction("Invalid action!");
							}
						}
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
			} else {
				return this.to(proto,spec);
			}
		}
	}
	to(proto,spec) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((spec) instanceof types_Money) == true) {
			let __anon0__m = spec;
			let m = __anon0__m;
			return m;
		} else {
			_hx_tmp2 = ((spec) instanceof types_Integer);
			if(_hx_tmp2 == true) {
				let __anon0__i = spec;
				let i = __anon0__i;
				return runtime_actions_datatypes_MoneyActions.fromInteger(i);
			} else {
				_hx_tmp1 = ((spec) instanceof types_Float);
				if(_hx_tmp1 == true) {
					let __anon0__f = spec;
					let f = __anon0__f;
					return runtime_actions_datatypes_MoneyActions.fromFloat(f);
				} else {
					_hx_tmp = ((spec) instanceof types_base__$String);
					if(_hx_tmp == true) {
						let __anon0__s = spec;
						let s = __anon0__s;
						return runtime_actions_datatypes_MoneyActions.fromString(s);
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
			}
		}
	}
	evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		let axis;
		let _hx_tmp;
		if(((element) instanceof types_Integer) == true) {
			let __anon0__i = element;
			let i = __anon0__i;
			if(i.int != 1 && i.int != 2) {
				throw haxe_Exception.thrown("invalid path");
			}
			axis = i.int;
		} else {
			_hx_tmp = ((element) instanceof types_Word);
			if(_hx_tmp == true) {
				let __anon0__w = element;
				let w = __anon0__w;
				axis = runtime_actions_datatypes_MoneyActions.getNamedIndex(w,path);
			} else {
				throw haxe_Exception.thrown("invalid path");
			}
		}
		if(value == null) {
			if(axis == 1) {
				return new types_Money(parent.m,null);
			} else {
				let tmp = parent.region;
				if(tmp != null) {
					return tmp;
				} else {
					return types_None.NONE;
				}
			}
		} else {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
	}
	compare(value1,value2,op) {
		let strict = op == 2 || op == 9 || op == 11;
		if(strict && value2.constructor != value1.constructor) {
			return 1;
		}
		let value;
		let _hx_tmp;
		let _hx_tmp1;
		if(((value2) instanceof types_Money) == true) {
			let __anon0__m = value2;
			let m = __anon0__m;
			switch(op) {
			case 3:case 4:case 5:case 6:
				if(!runtime_actions_datatypes_MoneyActions.sameRegion(value1,m,false)) {
					throw haxe_Exception.thrown("wrong denomination");
				}
				value = m;
				break;
			case 7:case 8:
				return runtime_actions_datatypes_MoneyActions.sortMoney(value1,m);
			default:
				if(op == 11) {
					strict = value1.region != null;
				}
				if(!runtime_actions_datatypes_MoneyActions.sameRegion(value1,m,strict)) {
					return 1;
				} else {
					value = m;
				}
			}
		} else {
			_hx_tmp1 = ((value2) instanceof types_Integer);
			if(_hx_tmp1 == true) {
				let __anon0__i = value2;
				let i = __anon0__i;
				value = runtime_actions_datatypes_MoneyActions.fromInteger(i);
			} else {
				_hx_tmp = ((value2) instanceof types_Float);
				if(_hx_tmp == true) {
					let __anon0__f = value2;
					let f = __anon0__f;
					let f1 = f.float;
					f1 = Math.abs(f1);
					if(f1 > 0 && f1 < 1e-5) {
						return 1;
					}
					if(Math.abs(f.float) >= 1e17) {
						return -1;
					}
					value = runtime_actions_datatypes_MoneyActions.fromFloat(f);
				} else {
					throw new runtime_actions_InvalidAction("Invalid action!");
				}
			}
		}
		return runtime_actions_datatypes_MoneyActions.compareMoney(value1,value);
	}
	form(value,buffer,arg,part) {
		let res = util_Dec64.toFixed(value.m,2);
		let neg = res.startsWith("-");
		res = "$" + (neg ? res.substr(1) : res);
		let _g = value.region;
		if(_g != null) {
			res = _g.symbol.name + res;
		}
		if(neg) {
			res = "-" + res;
		}
		if(arg != null && res.length > part) {
			res = res.substr(0,part);
		}
		buffer.appendLiteral(res);
		return part - res.length;
	}
	mold(value,buffer,_,isAll,_1,arg,part,_2) {
		let res = util_Dec64.toFixed(value.m,isAll ? 5 : 2);
		let neg = res.startsWith("-");
		res = "$" + (neg ? res.substr(1) : res);
		let _g = value.region;
		if(_g != null) {
			res = _g.symbol.name + res;
		}
		if(neg) {
			res = "-" + res;
		}
		if(arg != null && res.length > part) {
			res = res.substr(0,part);
		}
		buffer.appendLiteral(res);
		return part - res.length;
	}
	doMath(left,right,op) {
		let l;
		let _hx_tmp;
		let _hx_tmp1;
		if(((left) instanceof types_Money) == true) {
			let __anon0__m = left;
			let m = __anon0__m;
			l = m;
		} else {
			_hx_tmp1 = ((left) instanceof types_Integer);
			if(_hx_tmp1 == true) {
				let __anon0__i = left;
				let i = __anon0__i;
				l = runtime_actions_datatypes_MoneyActions.fromInteger(i);
			} else {
				_hx_tmp = ((left) instanceof types_base__$Float);
				if(_hx_tmp == true) {
					let __anon0__f = left;
					let f = __anon0__f;
					l = runtime_actions_datatypes_MoneyActions.fromFloat(f);
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
		}
		let r;
		let _hx_tmp2;
		let _hx_tmp3;
		if(((right) instanceof types_Money) == true) {
			let __anon0__m = right;
			let m = __anon0__m;
			r = m;
		} else {
			_hx_tmp3 = ((right) instanceof types_Integer);
			if(_hx_tmp3 == true) {
				let __anon0__i = right;
				let i = __anon0__i;
				r = runtime_actions_datatypes_MoneyActions.fromInteger(i);
			} else {
				_hx_tmp2 = ((right) instanceof types_base__$Float);
				if(_hx_tmp2 == true) {
					let __anon0__f = right;
					let f = __anon0__f;
					r = runtime_actions_datatypes_MoneyActions.fromFloat(f);
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
		}
		if(l.region != null && r.region != null && l.region != r.region) {
			throw haxe_Exception.thrown("wrong denomination");
		}
		let result = runtime_actions_datatypes_MoneyActions.doMathOp(l.m,r.m,op);
		if(op == 3 && ((left) instanceof types_Money) && ((right) instanceof types_Money)) {
			return new types_Float(util_Dec64.toDouble(result));
		} else {
			let tmp = l.region;
			return new types_Money(result,tmp != null ? tmp : r.region);
		}
	}
	absolute(value) {
		return new types_Money(util_Dec64.abs(value.m),value.region);
	}
	negate(value) {
		return new types_Money(util_Dec64.neg(value.m),value.region);
	}
	add(value1,value2) {
		return this.doMath(value1,value2,0);
	}
	subtract(value1,value2) {
		return this.doMath(value1,value2,1);
	}
	multiply(value1,value2) {
		return this.doMath(value1,value2,2);
	}
	divide(value1,value2) {
		return this.doMath(value1,value2,3);
	}
	remainder(value1,value2) {
		return this.doMath(value1,value2,4);
	}
	round(value,options) {
		let sign = util_Dec64.sign(value.m);
		if(sign == 0) {
			return value;
		}
		let scale;
		let tmp = options.to;
		let _g = tmp != null ? tmp.scale : null;
		let _hx_tmp;
		if(_g == null) {
			scale = runtime_actions_datatypes_MoneyActions.fromInt(1);
		} else {
			_hx_tmp = _g;
			let scale1 = _hx_tmp;
			let _hx_tmp1;
			let _hx_tmp2;
			if(((scale1) instanceof types_Money) == true) {
				let __anon0__m = scale1;
				let m = __anon0__m;
				scale = m;
			} else {
				_hx_tmp2 = ((scale1) instanceof types_Integer);
				if(_hx_tmp2 == true) {
					let __anon0__i = scale1;
					let i = __anon0__i;
					scale = runtime_actions_datatypes_MoneyActions.fromInteger(i);
				} else {
					_hx_tmp1 = ((scale1) instanceof types_Float);
					if(_hx_tmp1 == true) {
						let __anon0__f = scale1;
						let f = __anon0__f;
						throw haxe_Exception.thrown("NYI");
					} else {
						throw new runtime_actions_InvalidAction("Invalid action!");
					}
				}
			}
		}
		if(util_Dec64.isZero(scale.m)) {
			return value;
		}
		value = this.absolute(value);
		let lower = util_Dec64.mod(value.m,scale.m);
		let upper = util_Dec64.sub(scale.m,lower);
		let isHalf = util_Dec64.isInteger(util_Dec64.sub(lower,util_Dec64.ofZA2IntZ_Int(5,-1)));
		if(options.down) {
			return new types_Money(util_Dec64.sub(value.m,lower),value.region);
		} else if(options.floor) {
			if(sign < 0) {
				return new types_Money(util_Dec64.add(value.m,upper),value.region);
			} else {
				return new types_Money(util_Dec64.sub(value.m,lower),value.region);
			}
		} else if(options.ceiling) {
			if(sign < 0) {
				return new types_Money(util_Dec64.sub(value.m,lower),value.region);
			} else {
				return new types_Money(util_Dec64.add(value.m,upper),value.region);
			}
		} else if(options.even) {
			if(isHalf && this.even_q(value).cond) {
				return new types_Money(util_Dec64.sub(value.m,lower),value.region);
			} else if(util_Dec64.sign(util_Dec64.sub(lower,upper)) == -1) {
				return new types_Money(util_Dec64.sub(value.m,lower),value.region);
			} else {
				return new types_Money(util_Dec64.add(value.m,upper),value.region);
			}
		} else if(options.halfDown) {
			if(isHalf) {
				return new types_Money(util_Dec64.sub(value.m,lower),value.region);
			} else if(util_Dec64.sign(util_Dec64.sub(lower,upper)) == -1) {
				return new types_Money(util_Dec64.sub(value.m,lower),value.region);
			} else {
				return new types_Money(util_Dec64.add(value.m,upper),value.region);
			}
		} else if(options.halfCeiling) {
			if(isHalf) {
				if(sign < 0) {
					return new types_Money(util_Dec64.sub(value.m,lower),value.region);
				} else {
					return new types_Money(util_Dec64.add(value.m,upper),value.region);
				}
			} else if(util_Dec64.sign(util_Dec64.sub(lower,upper)) == -1) {
				return new types_Money(util_Dec64.sub(value.m,lower),value.region);
			} else {
				return new types_Money(util_Dec64.add(value.m,upper),value.region);
			}
		} else if(util_Dec64.sign(util_Dec64.sub(lower,upper)) == -1) {
			return new types_Money(util_Dec64.sub(value.m,lower),value.region);
		} else {
			return new types_Money(util_Dec64.add(value.m,upper),value.region);
		}
	}
	even_q(value) {
		if(!this.odd_q(value).cond) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
	odd_q(value) {
		if(util_Dec64.toDouble(value.m) % 1 == 0) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
	pick(value,index) {
		let idx;
		let _hx_tmp;
		if(((index) instanceof types_Integer) == true) {
			let __anon0__i = index;
			let i = __anon0__i;
			idx = i.int;
		} else {
			_hx_tmp = ((index) instanceof types_Word);
			if(_hx_tmp == true) {
				let __anon0__w = index;
				let w = __anon0__w;
				idx = runtime_actions_datatypes_MoneyActions.getNamedIndex(w,value);
			} else {
				throw new runtime_actions_InvalidAction("Invalid action!");
			}
		}
		switch(idx) {
		case 1:
			return new types_Money(value.m,null);
		case 2:
			let tmp = value.region;
			if(tmp != null) {
				return tmp;
			} else {
				return types_None.NONE;
			}
			break;
		default:
			throw haxe_Exception.thrown("out of range");
		}
	}
	static getNamedIndex(w,ref) {
		let axis = w.symbol;
		if(axis != runtime_Words.AMOUNT && axis != runtime_Words.CODE) {
			if(((ref) instanceof types_Money)) {
				throw haxe_Exception.thrown("cannot use");
			} else {
				throw haxe_Exception.thrown("invalid path");
			}
		}
		if(axis == runtime_Words.AMOUNT) {
			return 1;
		} else {
			return 2;
		}
	}
	static fromInteger(i,region) {
		return new types_Money(util_Dec64.ofZA2IntZ_Int(i.int,0),region);
	}
	static fromInt(i,region) {
		return new types_Money(util_Dec64.ofZA2IntZ_Int(i,0),region);
	}
	static fromFloat(f,region) {
		let fl = f.float;
		let tmp;
		if(!(!isFinite(fl) || Math.abs(fl) >= 1e17)) {
			let f = fl;
			f = Math.abs(fl);
			tmp = f > 0 && f < 1e-5;
		} else {
			tmp = true;
		}
		if(tmp) {
			throw new runtime_actions_InvalidAction("Invalid action!");
		}
		return new types_Money(util_Dec64.fromDouble(fl),region);
	}
	static fromString(s) {
		let _g = Tokenizer.parse(s.toJs());
		if(_g.length == 1) {
			let _g1 = _g[0];
			let _hx_tmp;
			let _hx_tmp1;
			if(((_g1) instanceof types_Money) == true) {
				let __anon0__m = _g1;
				let m = __anon0__m;
				return m;
			} else {
				_hx_tmp1 = ((_g1) instanceof types_Integer);
				if(_hx_tmp1 == true) {
					let __anon0__i = _g1;
					let i = __anon0__i;
					return runtime_actions_datatypes_MoneyActions.fromInteger(i);
				} else {
					_hx_tmp = ((_g1) instanceof types_Float);
					if(_hx_tmp == true) {
						let __anon0__f = _g1;
						let f = __anon0__f;
						return runtime_actions_datatypes_MoneyActions.fromFloat(f);
					} else {
						throw haxe_Exception.thrown("Can't parse tuple! from \"" + s.toJs() + "\"");
					}
				}
			}
		} else {
			throw haxe_Exception.thrown("Can't parse tuple! from \"" + s.toJs() + "\"");
		}
	}
	static sameRegion(l,r,strict) {
		let c1 = l.region;
		let c2 = r.region;
		if(!(!strict && (c1 == null || c2 == null))) {
			return (c1 != null ? c1.symbol : null) == (c2 != null ? c2.symbol : null);
		} else {
			return true;
		}
	}
	static sortMoney(l,r) {
		let c1 = l.region;
		let c2 = r.region;
		let flag;
		if(c1?.constructor == c2?.constructor) {
			if(c1 == null) {
				flag = 0;
			} else {
				let value = runtime_Actions.ACTIONS.get(12);
				if(value == null) {
					throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
				}
				flag = value.compare(c1,c2,3);
			}
		} else {
			flag = c1 == null ? -1 : 1;
		}
		if(flag == 0) {
			return runtime_actions_datatypes_MoneyActions.compareMoney(l,r);
		} else {
			return flag;
		}
	}
	static compareMoney(l,r) {
		return util_Dec64.sign(util_Dec64.sub(l.m,r.m));
	}
	static doMathOp(left,right,op) {
		switch(op) {
		case 0:
			return util_Dec64.add(left,right);
		case 1:
			return util_Dec64.sub(left,right);
		case 2:
			return util_Dec64.mul(left,right);
		case 3:
			return util_Dec64.div(left,right);
		case 4:
			return util_Dec64.mod(left,right);
		default:
			throw haxe_Exception.thrown("bad");
		}
	}
}
runtime_actions_datatypes_MoneyActions.__name__ = true;
runtime_actions_datatypes_MoneyActions.__super__ = runtime_actions_datatypes_ValueActions;
Object.assign(runtime_actions_datatypes_MoneyActions.prototype, {
	__class__: runtime_actions_datatypes_MoneyActions
});
class runtime_actions_datatypes_RefActions extends runtime_actions_datatypes_StringActions {
	constructor() {
		super();
	}
	mold(value,buffer,isOnly,isAll,isFlat,arg,part,indent) {
		buffer.values.push(64);
		return this.form(value,buffer,arg,part - 1);
	}
}
runtime_actions_datatypes_RefActions.__name__ = true;
runtime_actions_datatypes_RefActions.__super__ = runtime_actions_datatypes_StringActions;
Object.assign(runtime_actions_datatypes_RefActions.prototype, {
	__class__: runtime_actions_datatypes_RefActions
});
class runtime_Actions {
	static callAction(action,args,refines) {
		let _g = action.fn;
		switch(_g[1]) {
		case 0:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 1:
			if(args.length == 1) {
				return _g[2](args[0],{ only : refines.get("only") != null, secure : refines.get("secure") != null, seed : refines.get("seed") != null});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 2:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				let value = ((_g2) instanceof types_Word) ? _g2 : null;
				let tmp;
				if(value != null) {
					tmp = value;
				} else {
					throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
				}
				return _g[2](_g1,tmp);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 3:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 4:
			if(args.length == 1) {
				let _g1 = args[0];
				let _g2 = refines.get("part");
				let tmp;
				if(_g2 == null) {
					tmp = null;
				} else {
					let tmp1;
					if(((_g2[0]) instanceof types_Integer)) {
						tmp1 = js_Boot.__cast(_g2[0] , types_Integer);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { limit : tmp1};
				}
				return _g[2](_g1,{ part : tmp});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 5:
			if(args.length == 1) {
				let _g1 = args[0];
				let tmp = refines.get("all") != null;
				let tmp1 = refines.get("flat") != null;
				let tmp2 = refines.get("only") != null;
				let _g2 = refines.get("part");
				let tmp3;
				if(_g2 == null) {
					tmp3 = null;
				} else {
					let tmp;
					if(((_g2[0]) instanceof types_Integer)) {
						tmp = js_Boot.__cast(_g2[0] , types_Integer);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp3 = { limit : tmp};
				}
				return _g[2](_g1,{ all : tmp, flat : tmp1, only : tmp2, part : tmp3});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 6:
			if(args.length == 3) {
				let _g1 = args[0];
				let _g2 = args[1];
				let _g3 = args[2];
				let value = ((_g2) instanceof types_Word) ? _g2 : null;
				let tmp;
				if(value != null) {
					tmp = value;
				} else {
					throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
				}
				return _g[2](_g1,tmp,_g3,{ _case : refines.get("case") != null});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 7:
			throw haxe_Exception.thrown("this can't be called directly!");
		case 8:
			throw haxe_Exception.thrown("this can't be called directly!");
		case 9:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 10:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 11:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 12:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 13:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 14:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				let value = ((_g1) instanceof types_base__$Number) ? _g1 : null;
				let tmp;
				if(value != null) {
					tmp = value;
				} else {
					throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
				}
				let value1 = ((_g2) instanceof types_base__$Number) ? _g2 : null;
				let tmp1;
				if(value1 != null) {
					tmp1 = value1;
				} else {
					throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
				}
				return _g[2](tmp,tmp1);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 15:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 16:
			if(args.length == 1) {
				let _g1 = args[0];
				let tmp = refines.get("ceiling") != null;
				let tmp1 = refines.get("down") != null;
				let tmp2 = refines.get("even") != null;
				let tmp3 = refines.get("floor") != null;
				let tmp4 = refines.get("halfCeiling") != null;
				let tmp5 = refines.get("halfDown") != null;
				let _g2 = refines.get("to");
				let tmp6;
				if(_g2 == null) {
					tmp6 = null;
				} else {
					let tmp;
					if(((_g2[0]) instanceof Value)) {
						tmp = js_Boot.__cast(_g2[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp6 = { scale : tmp};
				}
				return _g[2](_g1,{ ceiling : tmp, down : tmp1, even : tmp2, floor : tmp3, halfCeiling : tmp4, halfDown : tmp5, to : tmp6});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 17:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 18:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 19:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 20:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 21:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 22:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 23:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 24:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				let tmp;
				let _g3 = refines.get("dup");
				if(_g3 == null) {
					tmp = null;
				} else {
					let tmp1;
					if(((_g3[0]) instanceof types_Integer)) {
						tmp1 = js_Boot.__cast(_g3[0] , types_Integer);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { count : tmp1};
				}
				let tmp1 = refines.get("only") != null;
				let _g4 = refines.get("part");
				let tmp2;
				if(_g4 == null) {
					tmp2 = null;
				} else {
					let tmp;
					if(((_g4[0]) instanceof Value)) {
						tmp = js_Boot.__cast(_g4[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp2 = { length : tmp};
				}
				return _g[2](_g1,_g2,{ dup : tmp, only : tmp1, part : tmp2});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 25:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 26:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 27:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				let tmp;
				let _g3 = refines.get("dup");
				if(_g3 == null) {
					tmp = null;
				} else {
					let tmp1;
					if(((_g3[0]) instanceof types_base__$Number)) {
						tmp1 = js_Boot.__cast(_g3[0] , types_base__$Number);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { count : tmp1};
				}
				let tmp1 = refines.get("only") != null;
				let _g4 = refines.get("part");
				let tmp2;
				if(_g4 == null) {
					tmp2 = null;
				} else {
					let tmp;
					if(((_g4[0]) instanceof Value)) {
						tmp = js_Boot.__cast(_g4[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp2 = { range : tmp};
				}
				return _g[2](_g1,_g2,{ dup : tmp, only : tmp1, part : tmp2});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 28:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 29:
			if(args.length == 1) {
				let _g1 = args[0];
				let tmp = refines.get("deep") != null;
				let tmp1;
				let _g2 = refines.get("part");
				if(_g2 == null) {
					tmp1 = null;
				} else {
					let tmp;
					if(((_g2[0]) instanceof Value)) {
						tmp = js_Boot.__cast(_g2[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp1 = { length : tmp};
				}
				let _g3 = refines.get("types");
				let tmp2;
				if(_g3 == null) {
					tmp2 = null;
				} else {
					let tmp;
					if(js_Boot.__implements(_g3[0],types_base_IDatatype)) {
						tmp = js_Boot.__cast(_g3[0] , types_base_IDatatype);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp2 = { kind : tmp};
				}
				return _g[2](_g1,{ deep : tmp, part : tmp1, types : tmp2});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 30:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				let tmp = refines.get("case") != null;
				let tmp1 = refines.get("any") != null;
				let tmp2 = refines.get("last") != null;
				let tmp3 = refines.get("match") != null;
				let tmp4 = refines.get("only") != null;
				let tmp5;
				let _g3 = refines.get("part");
				if(_g3 == null) {
					tmp5 = null;
				} else {
					let tmp;
					if(((_g3[0]) instanceof Value)) {
						tmp = js_Boot.__cast(_g3[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp5 = { length : tmp};
				}
				let tmp6 = refines.get("reverse") != null;
				let tmp7 = refines.get("same") != null;
				let tmp8;
				let _g4 = refines.get("skip");
				if(_g4 == null) {
					tmp8 = null;
				} else {
					let tmp;
					if(((_g4[0]) instanceof types_Integer)) {
						tmp = js_Boot.__cast(_g4[0] , types_Integer);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp8 = { size : tmp};
				}
				let tmp9 = refines.get("tail") != null;
				let _g5 = refines.get("with");
				let tmp10;
				if(_g5 == null) {
					tmp10 = null;
				} else {
					let tmp;
					if(((_g5[0]) instanceof types_String)) {
						tmp = js_Boot.__cast(_g5[0] , types_String);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp10 = { wild : tmp};
				}
				return _g[2](_g1,_g2,{ _case : tmp, any : tmp1, last : tmp2, match : tmp3, only : tmp4, part : tmp5, reverse : tmp6, same : tmp7, skip : tmp8, tail : tmp9, 'with' : tmp10});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 31:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 32:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 33:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 34:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				let tmp;
				let _g3 = refines.get("dup");
				if(_g3 == null) {
					tmp = null;
				} else {
					let tmp1;
					if(((_g3[0]) instanceof types_Integer)) {
						tmp1 = js_Boot.__cast(_g3[0] , types_Integer);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { count : tmp1};
				}
				let tmp1 = refines.get("only") != null;
				let _g4 = refines.get("part");
				let tmp2;
				if(_g4 == null) {
					tmp2 = null;
				} else {
					let tmp;
					if(((_g4[0]) instanceof Value)) {
						tmp = js_Boot.__cast(_g4[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp2 = { length : tmp};
				}
				return _g[2](_g1,_g2,{ dup : tmp, only : tmp1, part : tmp2});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 35:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 36:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				let _g3 = refines.get("part");
				let tmp;
				if(_g3 == null) {
					tmp = null;
				} else {
					let tmp1;
					if(((_g3[0]) instanceof types_Integer)) {
						tmp1 = js_Boot.__cast(_g3[0] , types_Integer);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { length : tmp1};
				}
				return _g[2](_g1,_g2,{ part : tmp});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 37:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 38:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 39:
			if(args.length == 3) {
				return _g[2](args[0],args[1],args[2]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 40:
			if(args.length == 3) {
				return _g[2](args[0],args[1],args[2],{ _case : refines.get("case") != null});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 41:
			if(args.length == 1) {
				let _g1 = args[0];
				let tmp;
				let _g2 = refines.get("key");
				if(_g2 == null) {
					tmp = null;
				} else {
					let tmp1;
					if(((_g2[0]) instanceof Value)) {
						tmp1 = js_Boot.__cast(_g2[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { keyArg : tmp1};
				}
				let _g3 = refines.get("part");
				let tmp1;
				if(_g3 == null) {
					tmp1 = null;
				} else {
					let tmp;
					if(((_g3[0]) instanceof Value)) {
						tmp = js_Boot.__cast(_g3[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp1 = { length : tmp};
				}
				return _g[2](_g1,{ key : tmp, part : tmp1});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 42:
			if(args.length == 1) {
				let _g1 = args[0];
				let tmp;
				let _g2 = refines.get("part");
				if(_g2 == null) {
					tmp = null;
				} else {
					let tmp1;
					if(((_g2[0]) instanceof Value)) {
						tmp1 = js_Boot.__cast(_g2[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { length : tmp1};
				}
				let _g3 = refines.get("skip");
				let tmp1;
				if(_g3 == null) {
					tmp1 = null;
				} else {
					let tmp;
					if(((_g3[0]) instanceof types_Integer)) {
						tmp = js_Boot.__cast(_g3[0] , types_Integer);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp1 = { size : tmp};
				}
				return _g[2](_g1,{ part : tmp, skip : tmp1});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 43:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				let tmp = refines.get("case") != null;
				let tmp1 = refines.get("any") != null;
				let tmp2 = refines.get("last") != null;
				let tmp3 = refines.get("only") != null;
				let tmp4;
				let _g3 = refines.get("part");
				if(_g3 == null) {
					tmp4 = null;
				} else {
					let tmp;
					if(((_g3[0]) instanceof Value)) {
						tmp = js_Boot.__cast(_g3[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp4 = { length : tmp};
				}
				let tmp5 = refines.get("reverse") != null;
				let tmp6 = refines.get("same") != null;
				let tmp7;
				let _g4 = refines.get("skip");
				if(_g4 == null) {
					tmp7 = null;
				} else {
					let tmp;
					if(((_g4[0]) instanceof types_Integer)) {
						tmp = js_Boot.__cast(_g4[0] , types_Integer);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp7 = { size : tmp};
				}
				let _g5 = refines.get("with");
				let tmp8;
				if(_g5 == null) {
					tmp8 = null;
				} else {
					let tmp;
					if(((_g5[0]) instanceof types_String)) {
						tmp = js_Boot.__cast(_g5[0] , types_String);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp8 = { wild : tmp};
				}
				return _g[2](_g1,_g2,{ _case : tmp, any : tmp1, last : tmp2, only : tmp3, part : tmp4, reverse : tmp5, same : tmp6, skip : tmp7, 'with' : tmp8});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 44:
			if(args.length == 1) {
				let _g1 = args[0];
				let tmp = refines.get("case") != null;
				let tmp1 = refines.get("all") != null;
				let tmp2;
				let _g2 = refines.get("compare");
				if(_g2 == null) {
					tmp2 = null;
				} else {
					let tmp;
					if(((_g2[0]) instanceof Value)) {
						tmp = js_Boot.__cast(_g2[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp2 = { comparator : tmp};
				}
				let tmp3;
				let _g3 = refines.get("part");
				if(_g3 == null) {
					tmp3 = null;
				} else {
					let tmp;
					if(((_g3[0]) instanceof Value)) {
						tmp = js_Boot.__cast(_g3[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp3 = { length : tmp};
				}
				let tmp4 = refines.get("reverse") != null;
				let tmp5;
				let _g4 = refines.get("skip");
				if(_g4 == null) {
					tmp5 = null;
				} else {
					let tmp;
					if(((_g4[0]) instanceof types_Integer)) {
						tmp = js_Boot.__cast(_g4[0] , types_Integer);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp5 = { size : tmp};
				}
				return _g[2](_g1,{ _case : tmp, all : tmp1, compare : tmp2, part : tmp3, reverse : tmp4, skip : tmp5, stable : refines.get("stable") != null});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 45:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 46:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 47:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 48:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 49:
			if(args.length == 1) {
				let _g1 = args[0];
				let tmp = refines.get("deep") != null;
				let tmp1 = refines.get("last") != null;
				let _g2 = refines.get("part");
				let tmp2;
				if(_g2 == null) {
					tmp2 = null;
				} else {
					let tmp;
					if(((_g2[0]) instanceof Value)) {
						tmp = js_Boot.__cast(_g2[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp2 = { length : tmp};
				}
				return _g[2](_g1,{ deep : tmp, last : tmp1, part : tmp2});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 50:
			if(args.length == 1) {
				let _g1 = args[0];
				let tmp = refines.get("all") != null;
				let tmp1 = refines.get("auto") != null;
				let tmp2 = refines.get("head") != null;
				let tmp3 = refines.get("lines") != null;
				let tmp4 = refines.get("tail") != null;
				let _g2 = refines.get("with");
				let tmp5;
				if(_g2 == null) {
					tmp5 = null;
				} else {
					let tmp;
					if(((_g2[0]) instanceof Value)) {
						tmp = js_Boot.__cast(_g2[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp5 = { str : tmp};
				}
				return _g[2](_g1,{ all : tmp, auto : tmp1, head : tmp2, lines : tmp3, tail : tmp4, 'with' : tmp5});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 51:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 52:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 53:
			if(args.length == 1) {
				let _g1 = args[0];
				let tmp = refines.get("new") != null;
				let tmp1;
				let _g2 = refines.get("allow");
				if(_g2 == null) {
					tmp1 = null;
				} else {
					let tmp;
					if(((_g2[0]) instanceof types_Block)) {
						tmp = js_Boot.__cast(_g2[0] , types_Block);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp1 = { access : tmp};
				}
				return _g[2](_g1,{ _new : tmp, allow : tmp1, read : refines.get("read") != null, seek : refines.get("seek") != null, write : refines.get("write") != null});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 54:
			if(args.length == 1) {
				return _g[2](args[0]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 55:
			if(args.length == 1) {
				let _g1 = args[0];
				let tmp;
				let _g2 = refines.get("as");
				if(_g2 == null) {
					tmp = null;
				} else {
					let tmp1;
					if(((_g2[0]) instanceof types_Word)) {
						tmp1 = js_Boot.__cast(_g2[0] , types_Word);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { encoding : tmp1};
				}
				let tmp1 = refines.get("binary") != null;
				let tmp2 = refines.get("info") != null;
				let tmp3 = refines.get("lines") != null;
				let tmp4;
				let _g3 = refines.get("part");
				if(_g3 == null) {
					tmp4 = null;
				} else {
					let tmp;
					if(((_g3[0]) instanceof types_base__$Number)) {
						tmp = js_Boot.__cast(_g3[0] , types_base__$Number);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp4 = { length : tmp};
				}
				let _g4 = refines.get("seek");
				let tmp5;
				if(_g4 == null) {
					tmp5 = null;
				} else {
					let tmp;
					if(((_g4[0]) instanceof types_base__$Number)) {
						tmp = js_Boot.__cast(_g4[0] , types_base__$Number);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp5 = { index : tmp};
				}
				return _g[2](_g1,{ as : tmp, binary : tmp1, info : tmp2, lines : tmp3, part : tmp4, seek : tmp5});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 56:
			if(args.length == 2) {
				return _g[2](args[0],args[1]);
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		case 57:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				let tmp;
				let _g3 = refines.get("allow");
				if(_g3 == null) {
					tmp = null;
				} else {
					let tmp1;
					if(((_g3[0]) instanceof types_Block)) {
						tmp1 = js_Boot.__cast(_g3[0] , types_Block);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { access : tmp1};
				}
				let tmp1 = refines.get("append") != null;
				let tmp2;
				let _g4 = refines.get("as");
				if(_g4 == null) {
					tmp2 = null;
				} else {
					let tmp;
					if(((_g4[0]) instanceof types_Word)) {
						tmp = js_Boot.__cast(_g4[0] , types_Word);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp2 = { encoding : tmp};
				}
				let tmp3 = refines.get("binary") != null;
				let tmp4 = refines.get("info") != null;
				let tmp5 = refines.get("lines") != null;
				let tmp6;
				let _g5 = refines.get("part");
				if(_g5 == null) {
					tmp6 = null;
				} else {
					let tmp;
					if(((_g5[0]) instanceof types_base__$Number)) {
						tmp = js_Boot.__cast(_g5[0] , types_base__$Number);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp6 = { length : tmp};
				}
				let _g6 = refines.get("seek");
				let tmp7;
				if(_g6 == null) {
					tmp7 = null;
				} else {
					let tmp;
					if(((_g6[0]) instanceof types_base__$Number)) {
						tmp = js_Boot.__cast(_g6[0] , types_base__$Number);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp7 = { index : tmp};
				}
				return _g[2](_g1,_g2,{ allow : tmp, append : tmp1, as : tmp2, binary : tmp3, info : tmp4, lines : tmp5, part : tmp6, seek : tmp7});
			} else {
				throw haxe_Exception.thrown("Invalid number of args");
			}
			break;
		}
	}
	static compare(value1,value2,op) {
		let value = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		let cmp = value.compare(value1,value2,op);
		if(cmp == -2 && !(op == 0 || op == 9 || op == 2 || op == 10 || op == 1 || op == 11)) {
			throw haxe_Exception.thrown("Invalid comparison: " + Std.string(value1) + ", " + op + ", " + Std.string(value2));
		}
		let cond;
		switch(op) {
		case 1:
			cond = cmp != 0;
			break;
		case 3:
			cond = cmp == -1;
			break;
		case 4:
			cond = cmp != 1;
			break;
		case 5:
			cond = cmp == 1;
			break;
		case 6:
			cond = cmp != -1;
			break;
		case 0:case 2:case 9:case 10:case 11:
			cond = cmp == 0;
			break;
		default:
			throw haxe_Exception.thrown("error!");
		}
		if(cond) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
	static compareValue(value1,value2,op,flags) {
		if(flags == null) {
			flags = 0;
		}
		let res;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((value1) instanceof types_Logic) == true) {
			let __anon0__l1 = value1;
			let l1 = __anon0__l1;
			res = l1.cond - value2.cond;
		} else {
			_hx_tmp2 = ((value1) instanceof types_base__$Function);
			if(_hx_tmp2 == true) {
				let __anon0__f = value1;
				let f = __anon0__f;
				res = value1 == value2 ? 0 : -1;
			} else {
				_hx_tmp1 = ((value1) instanceof types_None);
				if(_hx_tmp1 == true) {
					res = 0;
				} else {
					_hx_tmp = ((value1) instanceof types_Unset);
					if(_hx_tmp == true) {
						res = 0;
					} else {
						let value = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
						let res1;
						if(value != null) {
							res1 = value;
						} else {
							throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
						}
						res = res1.compare(value1,value2,op);
					}
				}
			}
		}
		return (flags & 1) != 0 ? -res : res;
	}
}
runtime_Actions.__name__ = true;
class runtime_Eval {
	static evalCode(input) {
		return runtime_natives_Do.evalValues(new util__$Series__$Series(Tokenizer.parse(input),0));
	}
	static callAnyFunction(fn,args,refines) {
		while(true) {
			let _hx_tmp;
			let _hx_tmp1;
			let _hx_tmp2;
			if(((fn) instanceof types_Native) == true) {
				let __anon0__n = fn;
				let n = __anon0__n;
				return runtime_Natives.callNative(n,args,refines);
			} else {
				_hx_tmp2 = ((fn) instanceof types_Action);
				if(_hx_tmp2 == true) {
					let __anon0__a = fn;
					let a = __anon0__a;
					return runtime_Actions.callAction(a,args,refines);
				} else {
					_hx_tmp1 = ((fn) instanceof types_Function);
					if(_hx_tmp1 == true) {
						let __anon0__f = fn;
						let f = __anon0__f;
						return runtime_Eval.callFunction(f,args,refines);
					} else {
						_hx_tmp = ((fn) instanceof types_Op);
						if(_hx_tmp == true) {
							let __anon0__o = fn;
							let o = __anon0__o;
							fn = o.fn;
							continue;
						} else {
							throw haxe_Exception.thrown("error!");
						}
					}
				}
			}
		}
	}
	static callFunction(fn,args,refines) {
		let fctx = fn.ctx;
		let oldValues = fctx.values;
		fctx.values = fctx.values.slice();
		let _this = fn.get_params();
		let _g_current = 0;
		while(_g_current < _this.length) fctx.set(_this[_g_current++].name,args[_g_current - 1]);
		let _g = 0;
		let _g1 = fn.get_refines();
		while(_g < _g1.length) {
			let refine = _g1[_g];
			++_g;
			let self = refine.name;
			let rx = /-([a-z])/g;
			let name = self.replace(rx,function(_,l) {
				return l.toUpperCase();
			});
			haxe_Log.trace(refine,{ fileName : "src/runtime/Eval.hx", lineNumber : 41, className : "runtime.Eval", methodName : "callFunction", customParams : [name,name]});
			let _g2 = refines.get(name);
			if(_g2 != null) {
				fctx.set(name,types_Logic.TRUE);
				let _this = refine.params;
				let _g_current = 0;
				while(_g_current < _this.length) fctx.set(_this[_g_current++].name,_g2[_g_current - 1]);
			}
		}
		try {
			let series = fn.body;
			let res = runtime_natives_Do.evalValues(new util__$Series__$Series(series.values,series.index));
			fctx.values = oldValues;
			return res;
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g);
			if(((_g1) instanceof runtime_RedError)) {
				let e = _g1;
				fctx.values = oldValues;
				if(e.error.isReturn()) {
					return e.error.ctx.get("arg1",false);
				} else {
					throw e;
				}
			} else {
				throw _g;
			}
		}
	}
}
runtime_Eval.__name__ = true;
class runtime_Natives {
	static callNative(native,args,refines) {
		let _g = native.fn;
		switch(_g[1]) {
		case 0:
			if(args.length == 2) {
				let _g1 = args[1];
				if(((_g1) instanceof types_Block) == true) {
					let cond = args[0];
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					return f(cond,b);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 1:
			if(args.length == 2) {
				let _g1 = args[1];
				if(((_g1) instanceof types_Block) == true) {
					let cond = args[0];
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					return f(cond,b);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 2:
			if(args.length == 3) {
				let _g1 = args[1];
				let _g2 = args[2];
				if(((_g1) instanceof types_Block) == true) {
					if(((_g2) instanceof types_Block) == true) {
						let cond = args[0];
						let __anon0__tb = _g1;
						let __anon1__fb = _g2;
						let f = _g[2];
						let tb = __anon0__tb;
						let fb = __anon1__fb;
						return f(cond,tb,fb);
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 3:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_Block) == true) {
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					return f(b);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 4:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_Block) == true) {
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					return f(b);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 5:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				if(((_g1) instanceof types_Block) == true) {
					if(((_g2) instanceof types_Block) == true) {
						let __anon0__cond = _g1;
						let __anon1__body = _g2;
						let f = _g[2];
						let cond = __anon0__cond;
						let body = __anon1__body;
						return f(cond,body);
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 6:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_Block) == true) {
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					return f(b);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 7:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				if(((_g1) instanceof types_base__$Number) == true) {
					if(((_g2) instanceof types_Block) == true) {
						let __anon0__n = _g1;
						let __anon1__b = _g2;
						let f = _g[2];
						let n = __anon0__n;
						let b = __anon1__b;
						return f(n,b);
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 8:
			if(args.length == 3) {
				let _g1 = args[0];
				let _g2 = args[1];
				let _g3 = args[2];
				if(((_g1) instanceof types_Word) == true) {
					if(((_g2) instanceof types_base__$Number) == true) {
						if(((_g3) instanceof types_Block) == true) {
							let __anon0__w = _g1;
							let __anon1__n = _g2;
							let __anon2__b = _g3;
							let f = _g[2];
							let w = __anon0__w;
							let n = __anon1__n;
							let b = __anon2__b;
							return f(w,n,b);
						} else {
							throw haxe_Exception.thrown("NYI");
						}
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 9:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_Block) == true) {
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					return f(b);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 10:
			if(args.length == 3) {
				let _g1 = args[2];
				if(((_g1) instanceof types_Block) == true) {
					let word = args[0];
					let series = args[1];
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					return f(word,series,b);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 11:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				if(((_g1) instanceof types_Word) == true) {
					if(((_g2) instanceof types_Block) == true) {
						let __anon0__word = _g1;
						let __anon1__body = _g2;
						let f = _g[2];
						let word = __anon0__word;
						let body = __anon1__body;
						return f(word,body);
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 12:
			if(args.length == 3) {
				let _g1 = args[2];
				if(((_g1) instanceof types_Block) == true) {
					let word = args[0];
					let series = args[1];
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					return f(word,series,b);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 13:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				if(((_g1) instanceof types_Block) == true) {
					if(((_g2) instanceof types_Block) == true) {
						let __anon0__spec = _g1;
						let __anon1__body = _g2;
						let f = _g[2];
						let spec = __anon0__spec;
						let body = __anon1__body;
						return f(spec,body);
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 14:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				if(((_g1) instanceof types_Block) == true) {
					if(((_g2) instanceof types_Block) == true) {
						let __anon0__spec = _g1;
						let __anon1__body = _g2;
						let f = _g[2];
						let spec = __anon0__spec;
						let body = __anon1__body;
						return f(spec,body,{ _extern : refines.get("extern") != null});
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 15:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_Block) == true) {
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					return f(b);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 16:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				if(((_g1) instanceof types_Block) == true) {
					if(((_g2) instanceof types_Block) == true) {
						let __anon0__spec = _g1;
						let __anon1__body = _g2;
						let f = _g[2];
						let spec = __anon0__spec;
						let body = __anon1__body;
						return f(spec,body);
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 17:
			if(args.length == 2) {
				let _g1 = args[1];
				if(((_g1) instanceof types_Block) == true) {
					let v = args[0];
					let __anon0__cs = _g1;
					let f = _g[2];
					let cs = __anon0__cs;
					let _g2 = refines.get("default");
					let tmp;
					if(_g2 == null) {
						tmp = null;
					} else {
						let args = _g2;
						let tmp1;
						if(((args[0]) instanceof types_Block)) {
							tmp1 = js_Boot.__cast(args[0] , types_Block);
						} else {
							throw haxe_Exception.thrown("type error!");
						}
						tmp = { _case : tmp1};
					}
					return f(v,cs,{ _default : tmp});
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 18:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_Block) == true) {
					let __anon0__cs = _g1;
					let f = _g[2];
					let cs = __anon0__cs;
					return f(cs,{ all : refines.get("all") != null});
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 19:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				let tmp;
				let _g1 = refines.get("args");
				if(_g1 == null) {
					tmp = null;
				} else {
					let args = _g1;
					let tmp1;
					if(((args[0]) instanceof Value)) {
						tmp1 = js_Boot.__cast(args[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { arg : tmp1};
				}
				let tmp1 = refines.get("expand") != null;
				let _g2 = refines.get("next");
				let tmp2;
				if(_g2 == null) {
					tmp2 = null;
				} else {
					let args = _g2;
					let tmp;
					if(((args[0]) instanceof types_Word)) {
						tmp = js_Boot.__cast(args[0] , types_Word);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp2 = { position : tmp};
				}
				return f(v,{ args : tmp, expand : tmp1, next : tmp2});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 20:
			if(args.length == 1) {
				let w = args[0];
				let f = _g[2];
				return f(w,{ _case : refines.get("case") != null, any : refines.get("any") != null});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 21:
			if(args.length == 2) {
				let w = args[0];
				let v = args[1];
				let f = _g[2];
				return f(w,v,{ _case : refines.get("case") != null, any : refines.get("any") != null, only : refines.get("only") != null, some : refines.get("some") != null});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 22:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				return f(v);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 23:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				return f(v);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 24:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				return f(v1,v2);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 25:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				return f(v1,v2);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 26:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				return f(v1,v2);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 27:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				return f(v1,v2);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 28:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				return f(v1,v2);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 29:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				return f(v1,v2);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 30:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				return f(v1,v2);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 31:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				return f(v1,v2);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 32:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				return f(v);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 33:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				return f(v,{ word : refines.get("word") != null});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 34:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				let _g1 = refines.get("into");
				let tmp;
				if(_g1 == null) {
					tmp = null;
				} else {
					let args = _g1;
					let tmp1;
					if(((args[0]) instanceof Value)) {
						tmp1 = js_Boot.__cast(args[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { out : tmp1};
				}
				return f(v,{ into : tmp});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 35:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_Block) == true) {
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					let tmp = refines.get("deep") != null;
					let tmp1;
					let _g2 = refines.get("into");
					if(_g2 == null) {
						tmp1 = null;
					} else {
						let args = _g2;
						let tmp;
						if(((args[0]) instanceof Value)) {
							tmp = js_Boot.__cast(args[0] , Value);
						} else {
							throw haxe_Exception.thrown("type error!");
						}
						tmp1 = { out : tmp};
					}
					return f(b,{ deep : tmp, into : tmp1, only : refines.get("only") != null});
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 36:
			if(args.length == 0) {
				let f = _g[2];
				return f({ info : refines.get("info") != null, show : refines.get("show") != null});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 37:
			if(args.length == 2) {
				let w = args[0];
				let c = args[1];
				let f = _g[2];
				return f(w,c,{ copy : refines.get("copy") != null});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 38:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				if(((_g1) instanceof types_Object) == true) {
					if(((_g2) instanceof types_base__$AnyWord) == true) {
						let __anon0__o = _g1;
						let __anon1__s = _g2;
						let f = _g[2];
						let o = __anon0__o;
						let s = __anon1__s;
						return f(o,s);
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 40:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				let tmp = refines.get("case") != null;
				let _g1 = refines.get("skip");
				let tmp1;
				if(_g1 == null) {
					tmp1 = null;
				} else {
					let args = _g1;
					let tmp;
					if(((args[0]) instanceof types_Integer)) {
						tmp = js_Boot.__cast(args[0] , types_Integer);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp1 = { size : tmp};
				}
				return f(v1,v2,{ _case : tmp, skip : tmp1});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 41:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				let tmp = refines.get("case") != null;
				let _g1 = refines.get("skip");
				let tmp1;
				if(_g1 == null) {
					tmp1 = null;
				} else {
					let args = _g1;
					let tmp;
					if(((args[0]) instanceof types_Integer)) {
						tmp = js_Boot.__cast(args[0] , types_Integer);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp1 = { size : tmp};
				}
				return f(v1,v2,{ _case : tmp, skip : tmp1});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 42:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				let tmp = refines.get("case") != null;
				let _g1 = refines.get("skip");
				let tmp1;
				if(_g1 == null) {
					tmp1 = null;
				} else {
					let args = _g1;
					let tmp;
					if(((args[0]) instanceof types_Integer)) {
						tmp = js_Boot.__cast(args[0] , types_Integer);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp1 = { size : tmp};
				}
				return f(v,{ _case : tmp, skip : tmp1});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 43:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				let tmp = refines.get("case") != null;
				let _g1 = refines.get("skip");
				let tmp1;
				if(_g1 == null) {
					tmp1 = null;
				} else {
					let args = _g1;
					let tmp;
					if(((args[0]) instanceof types_Integer)) {
						tmp = js_Boot.__cast(args[0] , types_Integer);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp1 = { size : tmp};
				}
				return f(v1,v2,{ _case : tmp, skip : tmp1});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 44:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				let tmp = refines.get("case") != null;
				let _g1 = refines.get("skip");
				let tmp1;
				if(_g1 == null) {
					tmp1 = null;
				} else {
					let args = _g1;
					let tmp;
					if(((args[0]) instanceof types_Integer)) {
						tmp = js_Boot.__cast(args[0] , types_Integer);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp1 = { size : tmp};
				}
				return f(v1,v2,{ _case : tmp, skip : tmp1});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 45:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_Bitset) == true) {
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					return f(b);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 46:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$String) == true) {
					let __anon0__s = _g1;
					let f = _g[2];
					let s = __anon0__s;
					return f(s);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 47:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$String) == true) {
					let __anon0__s = _g1;
					let f = _g[2];
					let s = __anon0__s;
					return f(s);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 48:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				return f(v);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 49:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				return f(v);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 50:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				return f(v1,v2);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 51:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				return f(v1,v2);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 52:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				if(((_g1) instanceof types_Integer) == true) {
					if(((_g2) instanceof types_Integer) == true) {
						let __anon0__d = _g1;
						let __anon1__b = _g2;
						let f = _g[2];
						let d = __anon0__d;
						let b = __anon1__b;
						return f(d,b,{ left : refines.get("left") != null, logical : refines.get("logical") != null});
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 53:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_Integer) == true) {
					let __anon0__i = _g1;
					let f = _g[2];
					let i = __anon0__i;
					let _g2 = refines.get("size");
					let tmp;
					if(_g2 == null) {
						tmp = null;
					} else {
						let args = _g2;
						let tmp1;
						if(((args[0]) instanceof types_Integer)) {
							tmp1 = js_Boot.__cast(args[0] , types_Integer);
						} else {
							throw haxe_Exception.thrown("type error!");
						}
						tmp = { length : tmp1};
					}
					return f(i,{ size : tmp});
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 54:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$Number) == true) {
					let __anon0__n = _g1;
					let f = _g[2];
					let n = __anon0__n;
					return f(n,{ radians : refines.get("radians") != null});
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 55:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$Number) == true) {
					let __anon0__n = _g1;
					let f = _g[2];
					let n = __anon0__n;
					return f(n,{ radians : refines.get("radians") != null});
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 56:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$Number) == true) {
					let __anon0__n = _g1;
					let f = _g[2];
					let n = __anon0__n;
					return f(n,{ radians : refines.get("radians") != null});
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 57:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$Number) == true) {
					let __anon0__n = _g1;
					let f = _g[2];
					let n = __anon0__n;
					return f(n,{ radians : refines.get("radians") != null});
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 58:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$Number) == true) {
					let __anon0__n = _g1;
					let f = _g[2];
					let n = __anon0__n;
					return f(n,{ radians : refines.get("radians") != null});
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 59:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$Number) == true) {
					let __anon0__n = _g1;
					let f = _g[2];
					let n = __anon0__n;
					return f(n,{ radians : refines.get("radians") != null});
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 60:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				if(((_g1) instanceof types_base__$Number) == true) {
					if(((_g2) instanceof types_base__$Number) == true) {
						let __anon0__y = _g1;
						let __anon1__x = _g2;
						let f = _g[2];
						let y = __anon0__y;
						let x = __anon1__x;
						return f(y,x,{ radians : refines.get("radians") != null});
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 61:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$Number) == true) {
					let __anon0__n = _g1;
					let f = _g[2];
					let n = __anon0__n;
					return f(n);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 62:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$Number) == true) {
					let __anon0__n = _g1;
					let f = _g[2];
					let n = __anon0__n;
					return f(n);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 63:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$Number) == true) {
					let __anon0__n = _g1;
					let f = _g[2];
					let n = __anon0__n;
					return f(n);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 64:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$Number) == true) {
					let __anon0__n = _g1;
					let f = _g[2];
					let n = __anon0__n;
					return f(n);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 65:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$Number) == true) {
					let __anon0__n = _g1;
					let f = _g[2];
					let n = __anon0__n;
					return f(n);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 66:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$Number) == true) {
					let __anon0__n = _g1;
					let f = _g[2];
					let n = __anon0__n;
					return f(n);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 67:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_Block) == true) {
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					let tmp = refines.get("only") != null;
					let _g2 = refines.get("with");
					let tmp1;
					if(_g2 == null) {
						tmp1 = null;
					} else {
						let args = _g2;
						let tmp;
						if(((args[0]) instanceof types_Object)) {
							tmp = js_Boot.__cast(args[0] , types_Object);
						} else {
							throw haxe_Exception.thrown("type error!");
						}
						tmp1 = { object : tmp};
					}
					return f(b,{ only : tmp, 'with' : tmp1});
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 68:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				return f(v);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 69:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_Block) == true) {
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					return f(b,{ all : refines.get("all") != null, keep : refines.get("keep") != null});
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 70:
			if(args.length == 1) {
				let s = args[0];
				let f = _g[2];
				let _g1 = refines.get("part");
				let tmp;
				if(_g1 == null) {
					tmp = null;
				} else {
					let args = _g1;
					let tmp1;
					if(((args[0]) instanceof Value)) {
						tmp1 = js_Boot.__cast(args[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { limit : tmp1};
				}
				return f(s,{ part : tmp});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 71:
			if(args.length == 1) {
				let s = args[0];
				let f = _g[2];
				let _g1 = refines.get("part");
				let tmp;
				if(_g1 == null) {
					tmp = null;
				} else {
					let args = _g1;
					let tmp1;
					if(((args[0]) instanceof Value)) {
						tmp1 = js_Boot.__cast(args[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { limit : tmp1};
				}
				return f(s,{ part : tmp});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 72:
			let _g1 = _g[2];
			if(args.length == 2) {
				let _g = args[0];
				let _g2 = args[1];
				let _hx_tmp;
				if(((_g2) instanceof types_Integer) == true) {
					_hx_tmp = ((_g2) instanceof types_Float);
					if(_hx_tmp == true) {
						let _hx_tmp;
						if(((_g) instanceof types_Integer) == true) {
							let __anon1__y = _g2;
							let __anon0__x = _g;
							let f = _g1;
							let x = __anon0__x;
							let y = __anon1__y;
							return f(x,y);
						} else {
							_hx_tmp = ((_g) instanceof types_Float);
							if(_hx_tmp == true) {
								let __anon1__y = _g2;
								let __anon0__x = _g;
								let f = _g1;
								let x = __anon0__x;
								let y = __anon1__y;
								return f(x,y);
							} else {
								throw haxe_Exception.thrown("NYI");
							}
						}
					} else {
						let _hx_tmp;
						if(((_g) instanceof types_Integer) == true) {
							let __anon1__y = _g2;
							let __anon0__x = _g;
							let f = _g1;
							let x = __anon0__x;
							let y = __anon1__y;
							return f(x,y);
						} else {
							_hx_tmp = ((_g) instanceof types_Float);
							if(_hx_tmp == true) {
								let __anon1__y = _g2;
								let __anon0__x = _g;
								let f = _g1;
								let x = __anon0__x;
								let y = __anon1__y;
								return f(x,y);
							} else {
								throw haxe_Exception.thrown("NYI");
							}
						}
					}
				} else {
					_hx_tmp = ((_g2) instanceof types_Float);
					if(_hx_tmp == true) {
						let _hx_tmp;
						if(((_g) instanceof types_Integer) == true) {
							let __anon1__y = _g2;
							let __anon0__x = _g;
							let f = _g1;
							let x = __anon0__x;
							let y = __anon1__y;
							return f(x,y);
						} else {
							_hx_tmp = ((_g) instanceof types_Float);
							if(_hx_tmp == true) {
								let __anon1__y = _g2;
								let __anon0__x = _g;
								let f = _g1;
								let x = __anon0__x;
								let y = __anon1__y;
								return f(x,y);
							} else {
								throw haxe_Exception.thrown("NYI");
							}
						}
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 73:
			let _g2 = _g[2];
			if(args.length == 2) {
				let _g = args[0];
				let _g1 = args[1];
				let _hx_tmp;
				if(((_g1) instanceof types_Integer) == true) {
					_hx_tmp = ((_g1) instanceof types_Float);
					if(_hx_tmp == true) {
						if(((_g) instanceof types_Word) == true) {
							let __anon1__a = _g1;
							let __anon0__w = _g;
							let f = _g2;
							let w = __anon0__w;
							let a = __anon1__a;
							return f(w,a);
						} else {
							throw haxe_Exception.thrown("NYI");
						}
					} else if(((_g) instanceof types_Word) == true) {
						let __anon1__a = _g1;
						let __anon0__w = _g;
						let f = _g2;
						let w = __anon0__w;
						let a = __anon1__a;
						return f(w,a);
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else {
					_hx_tmp = ((_g1) instanceof types_Float);
					if(_hx_tmp == true) {
						if(((_g) instanceof types_Word) == true) {
							let __anon1__a = _g1;
							let __anon0__w = _g;
							let f = _g2;
							let w = __anon0__w;
							let a = __anon1__a;
							return f(w,a);
						} else {
							throw haxe_Exception.thrown("NYI");
						}
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 74:
			if(args.length == 0) {
				let f = _g[2];
				let _g1 = refines.get("return");
				let tmp;
				if(_g1 == null) {
					tmp = null;
				} else {
					let args = _g1;
					let tmp1;
					if(((args[0]) instanceof Value)) {
						tmp1 = js_Boot.__cast(args[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { value : tmp1};
				}
				return f({ _return : tmp});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 75:
			if(args.length == 0) {
				let f = _g[2];
				return f();
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 76:
			if(args.length == 0) {
				let f = _g[2];
				return f();
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 77:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				return f(v);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 78:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				let _g1 = refines.get("name");
				let tmp;
				if(_g1 == null) {
					tmp = null;
				} else {
					let args = _g1;
					let tmp1;
					if(((args[0]) instanceof types_Word)) {
						tmp1 = js_Boot.__cast(args[0] , types_Word);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { word : tmp1};
				}
				return f(v,{ name : tmp});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 79:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_Block) == true) {
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					let _g2 = refines.get("name");
					let tmp;
					if(_g2 == null) {
						tmp = null;
					} else {
						let args = _g2;
						let tmp1;
						if(((args[0]) instanceof Value)) {
							tmp1 = js_Boot.__cast(args[0] , Value);
						} else {
							throw haxe_Exception.thrown("type error!");
						}
						tmp = { word : tmp1};
					}
					return f(b,{ name : tmp});
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 80:
			if(args.length == 2) {
				let o = args[0];
				let s = args[1];
				let f = _g[2];
				return f(o,s,{ _case : refines.get("case") != null});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 85:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				return f(v);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 86:
			if(args.length == 2) {
				let _g1 = args[0];
				let _g2 = args[1];
				if(((_g1) instanceof types_base__$Block) == true) {
					if(((_g2) instanceof types_Logic) == true) {
						let __anon0__l = _g1;
						let __anon1__c = _g2;
						let f = _g[2];
						let l = __anon0__l;
						let c = __anon1__c;
						let tmp = refines.get("all") != null;
						let _g3 = refines.get("skip");
						let tmp1;
						if(_g3 == null) {
							tmp1 = null;
						} else {
							let args = _g3;
							let tmp;
							if(((args[0]) instanceof types_Integer)) {
								tmp = js_Boot.__cast(args[0] , types_Integer);
							} else {
								throw haxe_Exception.thrown("type error!");
							}
							tmp1 = { size : tmp};
						}
						return f(l,c,{ all : tmp, skip : tmp1});
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 87:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$Block) == true) {
					let __anon0__l = _g1;
					let f = _g[2];
					let l = __anon0__l;
					return f(l);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 89:
			if(args.length == 1) {
				let _g1 = args[0];
				if(((_g1) instanceof types_base__$AnyWord) == true) {
					let __anon0__w = _g1;
					let f = _g[2];
					let w = __anon0__w;
					return f(w);
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 93:
			if(args.length == 0) {
				let f = _g[2];
				return f({ date : refines.get("date") != null, day : refines.get("day") != null, month : refines.get("month") != null, precise : refines.get("precise") != null, time : refines.get("time") != null, utc : refines.get("utc") != null, weekday : refines.get("weekday") != null, year : refines.get("year") != null, yearday : refines.get("yearday") != null, zone : refines.get("zone") != null});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 94:
			if(args.length == 1) {
				let n = args[0];
				let f = _g[2];
				return f(n);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 95:
			if(args.length == 2) {
				let v1 = args[0];
				let v2 = args[1];
				let f = _g[2];
				return f(v1,v2);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 97:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				return f(v);
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 103:
			if(args.length == 1) {
				let v = args[0];
				let f = _g[2];
				let tmp;
				let _g1 = refines.get("into");
				if(_g1 == null) {
					tmp = null;
				} else {
					let args = _g1;
					let tmp1;
					if(((args[0]) instanceof Value)) {
						tmp1 = js_Boot.__cast(args[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp = { dst : tmp1};
				}
				let tmp1 = refines.get("next") != null;
				let tmp2 = refines.get("one") != null;
				let tmp3;
				let _g2 = refines.get("part");
				if(_g2 == null) {
					tmp3 = null;
				} else {
					let args = _g2;
					let tmp;
					if(((args[0]) instanceof Value)) {
						tmp = js_Boot.__cast(args[0] , Value);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp3 = { length : tmp};
				}
				let tmp4 = refines.get("prescan") != null;
				let tmp5 = refines.get("scan") != null;
				let _g3 = refines.get("trace");
				let tmp6;
				if(_g3 == null) {
					tmp6 = null;
				} else {
					let args = _g3;
					let tmp;
					if(((args[0]) instanceof types_Function)) {
						tmp = js_Boot.__cast(args[0] , types_Function);
					} else {
						throw haxe_Exception.thrown("type error!");
					}
					tmp6 = { callback : tmp};
				}
				return f(v,{ into : tmp, next : tmp1, one : tmp2, part : tmp3, prescan : tmp4, scan : tmp5, trace : tmp6});
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		case 104:
			if(args.length == 2) {
				let _g1 = args[1];
				if(((_g1) instanceof types_Block) == true) {
					let fn = args[0];
					let __anon0__b = _g1;
					let f = _g[2];
					let b = __anon0__b;
					return f(fn,b,{ all : refines.get("all") != null, safer : refines.get("safer") != null});
				} else {
					throw haxe_Exception.thrown("NYI");
				}
			} else {
				throw haxe_Exception.thrown("NYI");
			}
			break;
		default:
			throw haxe_Exception.thrown("NYI");
		}
	}
}
runtime_Natives.__name__ = true;
class runtime_RedError extends haxe_Exception {
	constructor(error,name,previous,native) {
		super(error.description(),previous,native);
		this.error = error;
		this.name = name;
		this.__skipStack++;
	}
}
runtime_RedError.__name__ = true;
runtime_RedError.__super__ = haxe_Exception;
Object.assign(runtime_RedError.prototype, {
	__class__: runtime_RedError
});
class runtime_Sort {
	static swapFunc(base,aOffset,bOffset,n) {
		let i = aOffset;
		let j = bOffset;
		let _g = 0;
		while(_g < n) {
			++_g;
			[base[i], base[j]] = [base[j], base[i]];
			++i;
			++j;
		}
	}
	static med3(base,aOffset,bOffset,cOffset,op,flags,cmpFunc) {
		if(cmpFunc(base[aOffset],base[bOffset],op,flags) < 0) {
			if(cmpFunc(base[bOffset],base[cOffset],op,flags) < 0) {
				return bOffset;
			} else if(cmpFunc(base[aOffset],base[cOffset],op,flags) < 0) {
				return cOffset;
			} else {
				return aOffset;
			}
		} else if(cmpFunc(base[bOffset],base[cOffset],op,flags) > 0) {
			return bOffset;
		} else if(cmpFunc(base[aOffset],base[cOffset],op,flags) < 0) {
			return aOffset;
		} else {
			return cOffset;
		}
	}
	static quickSort(base,baseOffset,num,width,op,flags,cmpFunc) {
		let aOffset = 0;
		let bOffset = 0;
		let cOffset = 0;
		let dOffset = 0;
		let mOffset = 0;
		let nOffset = 0;
		let endOffset = 0;
		let r = 0;
		let part = 0;
		let result = 0;
		let swapped = false;
		do {
			swapped = false;
			endOffset = baseOffset + num * width;
			if(num < 7) {
				mOffset = baseOffset + width;
				while(mOffset < endOffset) {
					nOffset = mOffset;
					while(nOffset > baseOffset && cmpFunc(base[nOffset - width],base[nOffset],op,flags) > 0) {
						runtime_Sort.swapFunc(base,nOffset - width,nOffset,width);
						nOffset -= width;
					}
					mOffset += width;
				}
				return;
			}
			mOffset = baseOffset + (num / 2 | 0) * width;
			if(num > 7) {
				aOffset = baseOffset;
				bOffset = baseOffset + (num - 1) * width;
				if(num > 40) {
					part = (num >> 3) * width;
					aOffset = runtime_Sort.med3(base,aOffset,aOffset + part,aOffset + 2 * part,op,flags,cmpFunc);
					mOffset = runtime_Sort.med3(base,mOffset - part,mOffset,mOffset + part,op,flags,cmpFunc);
					bOffset = runtime_Sort.med3(base,bOffset - 2 * part,bOffset - part,bOffset,op,flags,cmpFunc);
				}
				mOffset = runtime_Sort.med3(base,aOffset,mOffset,bOffset,op,flags,cmpFunc);
			}
			runtime_Sort.swapFunc(base,baseOffset,mOffset,width);
			aOffset = baseOffset + width;
			bOffset = aOffset;
			cOffset = baseOffset + (num - 1) * width;
			dOffset = cOffset;
			while(true) {
				while(bOffset <= cOffset) {
					result = cmpFunc(base[bOffset],base[baseOffset],op,flags);
					if(result > 0) {
						break;
					}
					if(result == 0) {
						swapped = true;
						runtime_Sort.swapFunc(base,aOffset,bOffset,width);
						aOffset += width;
					}
					bOffset += width;
				}
				while(bOffset <= cOffset) {
					result = cmpFunc(base[cOffset],base[baseOffset],op,flags);
					if(result < 0) {
						break;
					}
					if(result == 0) {
						swapped = true;
						runtime_Sort.swapFunc(base,cOffset,dOffset,width);
						dOffset += width;
					}
					cOffset += width;
				}
				if(bOffset > cOffset) {
					break;
				}
				runtime_Sort.swapFunc(base,bOffset,cOffset,width);
				swapped = true;
				bOffset += width;
				cOffset -= width;
			}
			if(!swapped) {
				mOffset = baseOffset + width;
				while(mOffset < endOffset) {
					nOffset = mOffset;
					while(nOffset > baseOffset && cmpFunc(base[nOffset - width],base[nOffset],op,flags) > 0) {
						runtime_Sort.swapFunc(base,nOffset - width,nOffset,width);
						nOffset -= width;
					}
					mOffset += width;
				}
				return;
			}
			r = Math.min((aOffset - baseOffset), (bOffset - aOffset));
			if(r > 0) {
				runtime_Sort.swapFunc(base,baseOffset,bOffset - r,r);
			}
			r = Math.min((dOffset - cOffset), (endOffset - dOffset - width));
			if(r > 0) {
				runtime_Sort.swapFunc(base,bOffset,endOffset - r,r);
			}
			r = bOffset - aOffset;
			if(r > width) {
				runtime_Sort.quickSort(base,baseOffset,r / width | 0,width,op,flags,cmpFunc);
			}
			r = dOffset - cOffset;
			if(r > width) {
				baseOffset = endOffset - r;
				num = r / width | 0;
			}
		} while(r <= width);
	}
	static grailRotate(base,baseOffset,n1,n2,width) {
		while(n1 != 0 && n2 != 0) {
			let endOffset = baseOffset + n1 * width;
			let b1Offset = endOffset;
			if(n1 <= n2) {
				let aOffset = baseOffset;
				let bOffset = endOffset;
				let _g = 0;
				let _g1 = n1;
				while(_g < _g1) {
					++_g;
					runtime_Sort.swapFunc(base,aOffset,bOffset,width);
					aOffset += width;
					bOffset += width;
				}
				baseOffset = endOffset;
				n2 -= n1;
			} else {
				b1Offset = baseOffset + (n1 - n2) * width;
				let aOffset = b1Offset;
				let bOffset = endOffset;
				let _g = 0;
				let _g1 = n2;
				while(_g < _g1) {
					++_g;
					runtime_Sort.swapFunc(base,aOffset,bOffset,width);
					aOffset += width;
					bOffset += width;
				}
				n1 -= n2;
			}
		}
	}
	static grailSearchLeft(base,baseOffset,num,keyOffset,width,op,flags,cmpFunc) {
		let a = -1;
		let b = num;
		let c;
		while(a < b - 1) {
			c = a + (b - a >> 1);
			if(0 <= cmpFunc(base[baseOffset + c * width],base[keyOffset],op,flags)) {
				b = c;
			} else {
				a = c;
			}
		}
		return b;
	}
	static grailSearchRight(base,baseOffset,num,keyOffset,width,op,flags,cmpFunc) {
		let a = -1;
		let b = num;
		let c;
		while(a < b - 1) {
			c = a + (b - a >> 1);
			if(cmpFunc(base[baseOffset + c * width],base[keyOffset],op,flags) > 0) {
				b = c;
			} else {
				a = c;
			}
		}
		return b;
	}
	static grailMergeNoBuf(base,baseOffset,n1,n2,width,op,flags,cmpFunc) {
		if(n1 < n2) {
			let h = runtime_Sort.grailSearchLeft(base,baseOffset + n1 * width,n2,baseOffset,width,op,flags,cmpFunc);
			if(h != 0) {
				runtime_Sort.grailRotate(base,baseOffset,n1,h,width);
				baseOffset += h * width;
				n2 -= h;
			}
			if(n2 != 0) {
				do {
					baseOffset += width;
					--n1;
				} while(!(n1 == 0 || cmpFunc(base[baseOffset],base[baseOffset + n1 * width],op,flags) > 0));
			}
		} else {
			let h = runtime_Sort.grailSearchRight(base,baseOffset,n1,baseOffset + (n1 + n2 - 1) * width,width,op,flags,cmpFunc);
			if(h != n1) {
				runtime_Sort.grailRotate(base,baseOffset + h * width,n1 - h,n2,width);
				n1 = h;
			}
			if(n1 != 0) {
				do --n2; while(!(n2 == 0 || cmpFunc(base[baseOffset + (n1 - 1) * width],base[baseOffset + (n1 + n2 - 1) * width],op,flags) > 0));
			}
		}
	}
	static grailClassicMerge(base,baseOffset,n1,n2,width,op,flags,cmpFunc) {
		while(true) {
			if(n1 < 9 || n2 < 9) {
				runtime_Sort.grailMergeNoBuf(base,baseOffset,n1,n2,width,op,flags,cmpFunc);
				return;
			}
			let ak = baseOffset + (n1 < n2 ? n1 + (n2 / 2 | 0) : n1 / 2 | 0) * width;
			let k1 = runtime_Sort.grailSearchLeft(base,baseOffset,n1,ak,width,op,flags,cmpFunc);
			let k2 = k1;
			if(k1 < n1 && cmpFunc(base[baseOffset + k1 * width],base[ak],op,flags) == 0) {
				k2 = k1 + runtime_Sort.grailSearchRight(base,baseOffset + k1 * width,n1 - k1,ak,width,op,flags,cmpFunc);
			}
			let m1 = runtime_Sort.grailSearchLeft(base,baseOffset + n1 * width,n2,ak,width,op,flags,cmpFunc);
			let m2 = m1;
			if(m1 < n2 && cmpFunc(base[baseOffset + (n1 + m1) * width],base[ak],op,flags) == 0) {
				m2 = m1 + runtime_Sort.grailSearchRight(base,baseOffset + (n1 + m1) * width,n2 - m1,ak,width,op,flags,cmpFunc);
			}
			if(k1 == k2) {
				runtime_Sort.grailRotate(base,baseOffset + k2 * width,n1 - k2,m2,width);
			} else {
				runtime_Sort.grailRotate(base,baseOffset + k1 * width,n1 - k1,m1,width);
				if(m2 != m1) {
					runtime_Sort.grailRotate(base,baseOffset + (k2 + m1) * width,n1 - k2,m2 - m1,width);
				}
			}
			runtime_Sort.grailClassicMerge(base,baseOffset + (k2 + m2) * width,n1 - k2,m2 - m1,width,op,flags,cmpFunc);
			n1 = k1;
			n2 = m1;
		}
	}
	static mergeSort(base,baseOffset,num,width,op,flags,cmpFunc) {
		let h = 2;
		let m = 1;
		while(m < num) {
			let pm0 = baseOffset + (m - 1) * width;
			let pm1 = baseOffset + m * width;
			if(cmpFunc(base[pm0],base[pm1],op,flags) > 0) {
				runtime_Sort.swapFunc(base,pm0,pm1,width);
			}
			m += 2;
		}
		while(h < num) {
			let p0 = 0;
			let p1 = num - 2 * h;
			while(p0 <= p1) {
				runtime_Sort.grailClassicMerge(base,baseOffset + p0 * width,h,h,width,op,flags,cmpFunc);
				p0 += 2 * h;
			}
			let rest = num - p0;
			if(rest > h) {
				runtime_Sort.grailClassicMerge(base,baseOffset + p0 * width,h,rest - h,width,op,flags,cmpFunc);
			}
			h *= 2;
		}
	}
}
runtime_Sort.__name__ = true;
class runtime_Words {
	static build() {
		types_base_Context.GLOBAL.addSymbol(runtime_Words.SELF = types_base_Symbol.make("self"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.LOCAL = types_base_Symbol.make("local"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.HOUR = types_base_Symbol.make("hour"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.MINUTE = types_base_Symbol.make("minute"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.SECOND = types_base_Symbol.make("second"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.X = types_base_Symbol.make("x"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.Y = types_base_Symbol.make("y"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.Z = types_base_Symbol.make("z"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.DASH = types_base_Symbol.make("-"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.NOT = types_base_Symbol.make("not"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.SPEC = types_base_Symbol.make("spec"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.BODY = types_base_Symbol.make("body"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.WORDS = types_base_Symbol.make("words"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.CHANGED = types_base_Symbol.make("changed"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.CLASS = types_base_Symbol.make("class"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.VALUES = types_base_Symbol.make("values"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.OWNER = types_base_Symbol.make("owner"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.AMOUNT = types_base_Symbol.make("amount"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.CODE = types_base_Symbol.make("code"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.DATE = types_base_Symbol.make("date"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.YEAR = types_base_Symbol.make("year"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.MONTH = types_base_Symbol.make("month"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.DAY = types_base_Symbol.make("day"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.ZONE = types_base_Symbol.make("zone"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.TIME = types_base_Symbol.make("time"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.WEEKDAY = types_base_Symbol.make("weekday"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.YEARDAY = types_base_Symbol.make("yearday"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.JULIAN = types_base_Symbol.make("julian"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.TIMEZONE = types_base_Symbol.make("timezone"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.WEEK = types_base_Symbol.make("week"));
		types_base_Context.GLOBAL.addSymbol(runtime_Words.ISOWEEK = types_base_Symbol.make("isoweek"));
		runtime_actions_datatypes_DateActions.ACCESSORS = [null,runtime_Words.DATE,runtime_Words.YEAR,runtime_Words.MONTH,runtime_Words.DAY,runtime_Words.ZONE,runtime_Words.TIME,runtime_Words.HOUR,runtime_Words.MINUTE,runtime_Words.SECOND,runtime_Words.WEEKDAY,runtime_Words.YEARDAY,runtime_Words.JULIAN,runtime_Words.TIMEZONE,runtime_Words.WEEK,runtime_Words.ISOWEEK];
	}
}
runtime_Words.__name__ = true;
var types_ActionFn = { __ename__:true,__constructs__:["AMake","ARandom","AReflect","ATo","AForm","AMold","AModify","AEvalPath","ACompare","AAbsolute","AAdd","ADivide","AMultiply","ANegate","APower","ARemainder","ARound","ASubtract","AEven_q","AOdd_q","AAnd","AComplement","AOr","AXor","AAppend","AAt","ABack","AChange","AClear","ACopy","AFind","AHead","AHead_q","AIndex_q","AInsert","ALength_q","AMove","ANext","APick","APoke","APut","ARemove","AReverse","ASelect","ASort","ASkip","ASwap","ATail","ATail_q","ATake","ATrim","ACreate","ADelete","AOpen","AQuery","ARead","ARename","AWrite"] };
types_ActionFn.AMake = function(fn) { var $x = ["AMake",0,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ARandom = function(fn) { var $x = ["ARandom",1,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AReflect = function(fn) { var $x = ["AReflect",2,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ATo = function(fn) { var $x = ["ATo",3,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AForm = function(fn) { var $x = ["AForm",4,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AMold = function(fn) { var $x = ["AMold",5,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AModify = function(fn) { var $x = ["AModify",6,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AEvalPath = function(fn) { var $x = ["AEvalPath",7,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ACompare = function(fn) { var $x = ["ACompare",8,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AAbsolute = function(fn) { var $x = ["AAbsolute",9,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AAdd = function(fn) { var $x = ["AAdd",10,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ADivide = function(fn) { var $x = ["ADivide",11,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AMultiply = function(fn) { var $x = ["AMultiply",12,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ANegate = function(fn) { var $x = ["ANegate",13,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.APower = function(fn) { var $x = ["APower",14,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ARemainder = function(fn) { var $x = ["ARemainder",15,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ARound = function(fn) { var $x = ["ARound",16,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ASubtract = function(fn) { var $x = ["ASubtract",17,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AEven_q = function(fn) { var $x = ["AEven_q",18,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AOdd_q = function(fn) { var $x = ["AOdd_q",19,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AAnd = function(fn) { var $x = ["AAnd",20,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AComplement = function(fn) { var $x = ["AComplement",21,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AOr = function(fn) { var $x = ["AOr",22,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AXor = function(fn) { var $x = ["AXor",23,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AAppend = function(fn) { var $x = ["AAppend",24,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AAt = function(fn) { var $x = ["AAt",25,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ABack = function(fn) { var $x = ["ABack",26,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AChange = function(fn) { var $x = ["AChange",27,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AClear = function(fn) { var $x = ["AClear",28,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ACopy = function(fn) { var $x = ["ACopy",29,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AFind = function(fn) { var $x = ["AFind",30,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AHead = function(fn) { var $x = ["AHead",31,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AHead_q = function(fn) { var $x = ["AHead_q",32,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AIndex_q = function(fn) { var $x = ["AIndex_q",33,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AInsert = function(fn) { var $x = ["AInsert",34,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ALength_q = function(fn) { var $x = ["ALength_q",35,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AMove = function(fn) { var $x = ["AMove",36,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ANext = function(fn) { var $x = ["ANext",37,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.APick = function(fn) { var $x = ["APick",38,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.APoke = function(fn) { var $x = ["APoke",39,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.APut = function(fn) { var $x = ["APut",40,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ARemove = function(fn) { var $x = ["ARemove",41,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AReverse = function(fn) { var $x = ["AReverse",42,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ASelect = function(fn) { var $x = ["ASelect",43,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ASort = function(fn) { var $x = ["ASort",44,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ASkip = function(fn) { var $x = ["ASkip",45,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ASwap = function(fn) { var $x = ["ASwap",46,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ATail = function(fn) { var $x = ["ATail",47,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ATail_q = function(fn) { var $x = ["ATail_q",48,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ATake = function(fn) { var $x = ["ATake",49,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ATrim = function(fn) { var $x = ["ATrim",50,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ACreate = function(fn) { var $x = ["ACreate",51,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ADelete = function(fn) { var $x = ["ADelete",52,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AOpen = function(fn) { var $x = ["AOpen",53,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AQuery = function(fn) { var $x = ["AQuery",54,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ARead = function(fn) { var $x = ["ARead",55,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.ARename = function(fn) { var $x = ["ARename",56,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
types_ActionFn.AWrite = function(fn) { var $x = ["AWrite",57,fn]; $x.__enum__ = types_ActionFn; $x.toString = $estr; return $x; }
class util_errors_NullException extends haxe_exceptions_PosException {
	constructor(message,previous,pos) {
		super(message == null ? "Value was null" : message,previous,pos);
		this.__skipStack++;
	}
}
util_errors_NullException.__name__ = true;
util_errors_NullException.__super__ = haxe_exceptions_PosException;
Object.assign(util_errors_NullException.prototype, {
	__class__: util_errors_NullException
});
class runtime_actions_Absolute {
	static call(value) {
		let value1 = runtime_Actions.ACTIONS.get(value.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.absolute(value);
	}
}
runtime_actions_Absolute.__name__ = true;
class runtime_actions_Add {
	static call(value1,value2) {
		let value = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.add(value1,value2);
	}
}
runtime_actions_Add.__name__ = true;
class runtime_actions_And {
	static call(value1,value2) {
		let value = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.and(value1,value2);
	}
}
runtime_actions_And.__name__ = true;
class runtime_actions_Append {
	static call(series,value,options) {
		let value1 = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.append(series,value,options);
	}
}
runtime_actions_Append.__name__ = true;
class runtime_actions_At {
	static call(series,index) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.at(series,index);
	}
}
runtime_actions_At.__name__ = true;
class runtime_actions_Back {
	static call(series) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.back(series);
	}
}
runtime_actions_Back.__name__ = true;
class runtime_actions_Change {
	static call(series,value,options) {
		let value1 = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.change(series,value,options);
	}
}
runtime_actions_Change.__name__ = true;
class runtime_actions_Clear {
	static call(value) {
		let value1 = runtime_Actions.ACTIONS.get(value.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.clear(value);
	}
}
runtime_actions_Clear.__name__ = true;
class runtime_actions_Complement {
	static call(value) {
		let value1 = runtime_Actions.ACTIONS.get(value.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.complement(value);
	}
}
runtime_actions_Complement.__name__ = true;
class runtime_actions_Copy {
	static call(value,options) {
		let value1 = runtime_Actions.ACTIONS.get(value.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.copy(value,options);
	}
	static block(blk,deep,any) {
		if(blk.values.length - blk.index == 0) {
			return blk.copy();
		}
		let res = blk.copy();
		if(deep) {
			let values = blk.values;
			let length = blk.values.length;
			if(any) {
				let _g = 0;
				let _g1 = length;
				while(_g < _g1) {
					let i = _g++;
					let value = values[i];
					if(((value) instanceof types_Block) || ((value) instanceof types_Paren) || ((value) instanceof types_base__$Path)) {
						values[i] = runtime_actions_Copy.block(value,true,true);
					}
				}
			} else {
				let _g = 0;
				let _g1 = length;
				while(_g < _g1) {
					let i = _g++;
					let value = values[i];
					if(((value) instanceof types_Block)) {
						values[i] = runtime_actions_Copy.block(value,true,false);
					}
				}
			}
		}
		return res;
	}
}
runtime_actions_Copy.__name__ = true;
class runtime_actions_Divide {
	static call(value1,value2) {
		let value = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.divide(value1,value2);
	}
}
runtime_actions_Divide.__name__ = true;
class runtime_actions_EvalPath {
	static call(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail) {
		let value1 = runtime_Actions.ACTIONS.get(parent.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.evalPath(parent,element,value,path,gparent,pItem,index,isCase,isGet,isTail);
	}
}
runtime_actions_EvalPath.__name__ = true;
class runtime_actions_Even_$q {
	static call(value) {
		let value1 = runtime_Actions.ACTIONS.get(value.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.even_q(value);
	}
}
runtime_actions_Even_$q.__name__ = true;
class runtime_actions_Find {
	static call(series,value,options) {
		let value1 = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.find(series,value,options);
	}
}
runtime_actions_Find.__name__ = true;
class types_base_ISetPath {
}
types_base_ISetPath.__name__ = true;
types_base_ISetPath.__isInterface__ = true;
types_base_ISetPath.__interfaces__ = [types_base_IValue];
Object.assign(types_base_ISetPath.prototype, {
	__class__: types_base_ISetPath
});
class types_base_IGetPath {
}
types_base_IGetPath.__name__ = true;
types_base_IGetPath.__isInterface__ = true;
types_base_IGetPath.__interfaces__ = [types_base_IValue];
Object.assign(types_base_IGetPath.prototype, {
	__class__: types_base_IGetPath
});
class types_base_ISeriesOf {
}
types_base_ISeriesOf.__name__ = true;
types_base_ISeriesOf.__isInterface__ = true;
types_base_ISeriesOf.__interfaces__ = [types_base_ISetPath,types_base_IGetPath];
Object.assign(types_base_ISeriesOf.prototype, {
	__class__: types_base_ISeriesOf
});
class types_base__$SeriesOf extends Value {
	constructor(values,index) {
		super();
		this.values = values;
		this.index = index != null ? index : 0;
	}
	cloneValues() {
		return this.values.slice(this.index);
	}
	pick(index) {
		if(index < 0 || index >= this.values.length - this.index) {
			return null;
		} else {
			return this.wrap(this.values[this.index + index]);
		}
	}
	poke(index,value) {
		if(index < 0 || index >= this.values.length - this.index) {
			return null;
		} else {
			this.values[this.index + index] = this.unwrap(value);
			return value;
		}
	}
	rawPoke(index,value) {
		if(index < 0 || index >= this.values.length - this.index) {
			return null;
		} else {
			return this.values[this.index + index] = value;
		}
	}
	remove() {
		if(this.isTail()) {
			throw haxe_Exception.thrown("out of bounds!");
		} else {
			return this.wrap(this.values.splice(this.index,1)[0]);
		}
	}
	removePart(count) {
		let _this = this.values.splice(this.index,count);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = this.wrap(_this[i]);
		}
		return result;
	}
	removeAt(index,count) {
		if(count == null) {
			count = 1;
		}
		this.values.splice(this.index + index,count);
	}
	at(index) {
		return this.clone(this.values,Math.max(0, Math.min((this.index + (index <= 0 ? index : index - 1)), this.values.length)));
	}
	skip(index) {
		return this.clone(this.values,Math.max(0, Math.min((this.index + index), this.values.length)));
	}
	fastSkipHead(index) {
		return this.clone(this.values,index);
	}
	copy() {
		return this.clone(this.values.slice(this.index),0);
	}
	head() {
		return this.clone(this.values,0);
	}
	tail() {
		return this.clone(this.values,this.values.length);
	}
	isHead() {
		return this.index == 0;
	}
	isTail() {
		return this.index == this.values.length;
	}
	iterator() {
		let _this = this.values.slice(this.index);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = this.wrap(_this[i]);
		}
		return new haxe_iterators_ArrayIterator(result);
	}
	getPath(access,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let _hx_tmp = ((access) instanceof types_Integer) ? access : null;
		let _hx_tmp_a = _hx_tmp != null;
		let _hx_tmp_b = _hx_tmp;
		let _g = _hx_tmp_b;
		if(_hx_tmp_a == true) {
			let _hx_tmp;
			if(_g == null) {
				_hx_tmp = _g;
				let i = _hx_tmp.int - 1;
				let value = this.pick(i);
				if(value == null) {
					return haxe_ds_Option.None;
				} else {
					return haxe_ds_Option.Some(value);
				}
			} else {
				_hx_tmp = _g;
				let i = _hx_tmp.int - 1;
				let value = this.pick(i);
				if(value == null) {
					return haxe_ds_Option.None;
				} else {
					return haxe_ds_Option.Some(value);
				}
			}
		} else {
			return haxe_ds_Option.None;
		}
	}
	setPath(access,newValue,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let _hx_tmp = ((access) instanceof types_Integer) ? access : null;
		let _hx_tmp_a = _hx_tmp != null;
		let _hx_tmp_b = _hx_tmp;
		let _g = _hx_tmp_b;
		if(_hx_tmp_a == true) {
			let _hx_tmp;
			if(_g == null) {
				_hx_tmp = _g;
				let i = _hx_tmp.int - 1;
				this.poke(i,newValue);
				return true;
			} else {
				_hx_tmp = _g;
				let i = _hx_tmp.int - 1;
				this.poke(i,newValue);
				return true;
			}
		} else {
			return false;
		}
	}
}
types_base__$SeriesOf.__name__ = true;
types_base__$SeriesOf.__interfaces__ = [types_base_ISeriesOf];
types_base__$SeriesOf.__super__ = Value;
Object.assign(types_base__$SeriesOf.prototype, {
	__class__: types_base__$SeriesOf
});
class types_base__$String extends types_base__$SeriesOf {
	constructor(values,index) {
		super(values,index);
	}
	toJs() {
		return String.fromCharCode(...(this.index == 0 ? this.values : this.values.slice(this.index)));
	}
	wrap(value) {
		return types_Char.fromCode(value);
	}
	unwrap(value) {
		return value.int;
	}
	append(value,limit) {
		this.values.push(...(limit == null ? value.index == 0 ? value.values : value.values.slice(value.index) : value.index == 0 ? value.values.slice(0,value.index + limit) : value.values.slice(value.index,value.index + limit)));
	}
	insert(value,index,limit) {
		let array = this.values;
		let values = limit == null ? value.index == 0 ? value.values : value.values.slice(value.index) : value.index == 0 ? value.values.slice(0,value.index + limit) : value.values.slice(value.index,value.index + limit);
		array.splice(index,0,...values);
	}
	overwrite(value,index,limit) {
		let chars = limit == null ? value.index == 0 ? value.values : value.values.slice(value.index) : value.index == 0 ? value.values.slice(0,value.index + limit) : value.values.slice(value.index,value.index + limit);
		this.values.splice(index,chars.length,...chars);
	}
	appendLiteral(value) {
		let _g = 0;
		let _g1 = value.length;
		while(_g < _g1) this.values.push(value.charCodeAt((_g++)));
	}
	appendLiteralPart(value,part) {
		let _g = 0;
		while(_g < part) this.values.push(value.charCodeAt((_g++)));
	}
	appendEscapedChar(char,isEsc,isAll) {
		if(char == 30 || 128 <= char && char <= 159 || isAll && char > 127) {
			this.values.push(94);
			this.values.push(40);
			this.appendLiteral(char.toString(16).toUpperCase().padStart(2, "0"));
			this.values.push(41);
		} else if(isEsc) {
			let c;
			switch(char) {
			case 9:
				c = 45;
				break;
			case 10:
				c = 47;
				break;
			case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 11:case 13:case 14:case 15:case 16:case 17:case 18:case 19:case 20:case 21:case 22:case 23:case 24:case 25:case 26:case 27:case 28:case 29:case 30:case 31:
				c = char + 64;
				break;
			case 34:
				c = 34;
				break;
			case 94:case 127:
				c = 94;
				break;
			default:
				c = -1;
			}
			if(c == -1) {
				this.values.push(char);
			} else {
				this.values.push(94);
				this.values.push(c);
			}
		} else {
			this.values.push(char);
		}
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_base__$String);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_base__$String);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_base__$String);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_base__$String);
	}
	head() {
		return js_Boot.__cast(super.head() , types_base__$String);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_base__$String);
	}
	static codesFromRed(str) {
		let _g = [];
		while(str.length > 0) {
			let code = 0;
			let len = 0;
			if(str.charCodeAt(0) == 94) {
				let value = str.charCodeAt(1);
				if(value == null) {
					throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
				}
				switch(value) {
				case 40:
					let nstr = str.substr(2).toUpperCase();
					let res = null;
					if(nstr.startsWith("NULL)")) {
						code = 0;
						res = 0;
						len = 2 + "NULL)".length;
					} else if(nstr.startsWith("BACK)")) {
						code = 8;
						res = 8;
						len = 2 + "BACK)".length;
					} else if(nstr.startsWith("TAB)")) {
						code = 9;
						res = 9;
						len = 2 + "TAB)".length;
					} else if(nstr.startsWith("LINE)")) {
						code = 10;
						res = 10;
						len = 2 + "LINE)".length;
					} else if(nstr.startsWith("PAGE)")) {
						code = 12;
						res = 12;
						len = 2 + "PAGE)".length;
					} else if(nstr.startsWith("ESC)")) {
						code = 27;
						res = 27;
						len = 2 + "ESC)".length;
					} else if(nstr.startsWith("DEL)")) {
						code = 127;
						res = 127;
						len = 2 + "DEL)".length;
					}
					if(res == null) {
						let rx = new EReg("^([A-F\\d]+)\\)","i");
						if(rx.match(nstr)) {
							code = Util.mustParseInt("0x" + rx.matched(0));
							len = 2 + rx.matchedPos().len;
						} else {
							throw haxe_Exception.thrown("Invalid string! escape \"^" + str.charAt(1) + "\"!");
						}
					}
					break;
				case 45:
					code = 9;
					len = 2;
					break;
				case 47:
					code = 10;
					len = 2;
					break;
				case 64:
					code = 0;
					len = 2;
					break;
				case 65:case 66:case 67:case 68:case 69:case 70:case 71:case 72:case 73:case 74:case 75:case 76:case 77:case 78:case 79:case 80:case 81:case 82:case 83:case 84:case 85:case 86:case 87:case 88:case 89:case 90:
					code = value - 64;
					len = 2;
					break;
				case 91:
					code = 27;
					len = 2;
					break;
				case 92:
					code = 28;
					len = 2;
					break;
				case 93:
					code = 29;
					len = 2;
					break;
				case 34:case 94:
					code = value;
					len = 2;
					break;
				case 95:
					code = 31;
					len = 2;
					break;
				case 97:case 98:case 99:case 100:case 101:case 102:case 103:case 104:case 105:case 106:case 107:case 108:case 109:case 110:case 111:case 112:case 113:case 114:case 115:case 116:case 117:case 118:case 119:case 120:case 121:case 122:
					code = value - 32 - 64;
					len = 2;
					break;
				case 126:
					code = 127;
					len = 2;
					break;
				default:
					throw haxe_Exception.thrown("Invalid string! escape \"^" + str.charAt(1) + "\"!");
				}
			} else {
				code = str.charCodeAt(0);
				len = 1;
			}
			str = str.substr(len);
			_g.push(code);
		}
		return _g;
	}
}
types_base__$String.__name__ = true;
types_base__$String.__super__ = types_base__$SeriesOf;
Object.assign(types_base__$String.prototype, {
	__class__: types_base__$String
});
class types_String extends types_base__$String {
	constructor(values,index) {
		super(values,index);
	}
	clone(values,index) {
		return new types_String(values,index);
	}
	get_TYPE_KIND() {
		return 6;
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_String);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_String);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_String);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_String);
	}
	head() {
		return js_Boot.__cast(super.head() , types_String);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_String);
	}
	static fromRed(str) {
		return new types_String(types_base__$String.codesFromRed(str));
	}
	static fromString(str) {
		let _g = [];
		let _g1 = 0;
		let _g2 = str.length;
		while(_g1 < _g2) _g.push(str.charCodeAt((_g1++)));
		return new types_String(_g);
	}
}
types_String.__name__ = true;
types_String.__super__ = types_base__$String;
Object.assign(types_String.prototype, {
	__class__: types_String
});
class runtime_actions_Form {
	static call(value,options) {
		let tmp = options.part;
		let arg = tmp != null ? tmp.limit.int : null;
		let expected = 0;
		let limit;
		let _hx_tmp;
		if(arg == null) {
			limit = Infinity;
		} else {
			_hx_tmp = arg;
			if(arg <= 0) {
				return new types_String([]);
			}
			expected = _hx_tmp;
			limit = _hx_tmp;
		}
		let buffer = new types_String([]);
		let value1 = runtime_Actions.ACTIONS.get(value.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		value1.form(value,buffer,arg,limit);
		if(expected > 0) {
			buffer.values.length = expected;
		}
		return buffer;
	}
}
runtime_actions_Form.__name__ = true;
class runtime_actions_Head {
	static call(series) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.head(series);
	}
}
runtime_actions_Head.__name__ = true;
class runtime_actions_Head_$q {
	static call(series) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.head_q(series);
	}
}
runtime_actions_Head_$q.__name__ = true;
class runtime_actions_Index_$q {
	static call(series) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.index_q(series);
	}
}
runtime_actions_Index_$q.__name__ = true;
class runtime_actions_Insert {
	static call(series,value,options) {
		let value1 = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.insert(series,value,options);
	}
}
runtime_actions_Insert.__name__ = true;
class runtime_actions_InvalidAction extends haxe_Exception {
	constructor(message,previous,native) {
		super(message,previous,native);
		this.__skipStack++;
	}
}
runtime_actions_InvalidAction.__name__ = true;
runtime_actions_InvalidAction.__super__ = haxe_Exception;
Object.assign(runtime_actions_InvalidAction.prototype, {
	__class__: runtime_actions_InvalidAction
});
class runtime_actions_Length_$q {
	static call(series) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.length_q(series);
	}
}
runtime_actions_Length_$q.__name__ = true;
class runtime_actions_Make {
	static call(type,spec) {
		if(((type) instanceof types_Datatype) == true) {
			let __anon0__d = type;
			let d = __anon0__d;
			let value = runtime_Actions.ACTIONS.get(d.kind);
			let tmp;
			if(value != null) {
				tmp = value;
			} else {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			return tmp.make(null,spec);
		} else {
			let value = runtime_Actions.ACTIONS.get(type.get_TYPE_KIND());
			let tmp;
			if(value != null) {
				tmp = value;
			} else {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			return tmp.make(type,spec);
		}
	}
}
runtime_actions_Make.__name__ = true;
class runtime_actions_Mold {
	static call(value,options) {
		let tmp = options.part;
		let arg = tmp != null ? tmp.limit.int : null;
		let expected = 0;
		let limit;
		let _hx_tmp;
		if(arg == null) {
			limit = Infinity;
		} else {
			_hx_tmp = arg;
			if(arg <= 0) {
				return new types_String([]);
			}
			expected = _hx_tmp;
			limit = _hx_tmp;
		}
		let buffer = new types_String([]);
		let value1 = runtime_Actions.ACTIONS.get(value.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		value1.mold(value,buffer,options.only,options.all,options.flat,arg,limit,0);
		if(expected > 0) {
			buffer.values.length = expected;
		}
		return buffer;
	}
}
runtime_actions_Mold.__name__ = true;
class runtime_actions_Move {
	static call(origin,target,options) {
		let value = runtime_Actions.ACTIONS.get(origin.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.move(origin,target,options);
	}
}
runtime_actions_Move.__name__ = true;
class runtime_actions_Multiply {
	static call(value1,value2) {
		let value = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.multiply(value1,value2);
	}
}
runtime_actions_Multiply.__name__ = true;
class runtime_actions_Negate {
	static call(value) {
		let value1 = runtime_Actions.ACTIONS.get(value.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.negate(value);
	}
}
runtime_actions_Negate.__name__ = true;
class runtime_actions_Next {
	static call(series) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.next(series);
	}
}
runtime_actions_Next.__name__ = true;
class runtime_actions_Odd_$q {
	static call(value) {
		let value1 = runtime_Actions.ACTIONS.get(value.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.odd_q(value);
	}
}
runtime_actions_Odd_$q.__name__ = true;
class runtime_actions_Or {
	static call(value1,value2) {
		let value = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.or(value1,value2);
	}
}
runtime_actions_Or.__name__ = true;
class runtime_actions_Pick {
	static call(series,index) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.pick(series,index);
	}
}
runtime_actions_Pick.__name__ = true;
class runtime_actions_Poke {
	static call(series,index,value) {
		let value1 = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.poke(series,index,value);
	}
}
runtime_actions_Poke.__name__ = true;
class runtime_actions_Power {
	static call(number,exponent) {
		let value = runtime_Actions.ACTIONS.get(number.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.power(number,exponent);
	}
}
runtime_actions_Power.__name__ = true;
class runtime_actions_Put {
	static call(series,key,value,options) {
		let value1 = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.put(series,key,value,options);
	}
}
runtime_actions_Put.__name__ = true;
class runtime_actions_Reflect {
	static call(value,field) {
		let value1 = runtime_Actions.ACTIONS.get(value.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.reflect(value,field);
	}
}
runtime_actions_Reflect.__name__ = true;
class runtime_actions_Remainder {
	static call(value1,value2) {
		let value = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.remainder(value1,value2);
	}
}
runtime_actions_Remainder.__name__ = true;
class runtime_actions_Remove {
	static call(series,options) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.remove(series,options);
	}
}
runtime_actions_Remove.__name__ = true;
class runtime_actions_Reverse {
	static call(series,options) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.reverse(series,options);
	}
}
runtime_actions_Reverse.__name__ = true;
class runtime_actions_Round {
	static call(value,options) {
		let value1 = runtime_Actions.ACTIONS.get(value.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.round(value,options);
	}
}
runtime_actions_Round.__name__ = true;
class runtime_actions_Select {
	static call(series,value,options) {
		let value1 = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value1 == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value1.select(series,value,options);
	}
}
runtime_actions_Select.__name__ = true;
class runtime_actions_Skip {
	static call(series,index) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.skip(series,index);
	}
}
runtime_actions_Skip.__name__ = true;
class runtime_actions_Sort {
	static call(series,options) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.sort(series,options);
	}
}
runtime_actions_Sort.__name__ = true;
class runtime_actions_Subtract {
	static call(value1,value2) {
		let value = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.subtract(value1,value2);
	}
}
runtime_actions_Subtract.__name__ = true;
class runtime_actions_Swap {
	static call(series1,series2) {
		let value = runtime_Actions.ACTIONS.get(series1.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.swap(series1,series2);
	}
}
runtime_actions_Swap.__name__ = true;
class runtime_actions_Tail {
	static call(series) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.tail(series);
	}
}
runtime_actions_Tail.__name__ = true;
class runtime_actions_Tail_$q {
	static call(series) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.tail_q(series);
	}
}
runtime_actions_Tail_$q.__name__ = true;
class runtime_actions_Take {
	static call(series,options) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.take(series,options);
	}
}
runtime_actions_Take.__name__ = true;
class runtime_actions_To {
	static call(type,spec) {
		if(((type) instanceof types_Datatype) == true) {
			let __anon0__d = type;
			let d = __anon0__d;
			let value = runtime_Actions.ACTIONS.get(d.kind);
			let tmp;
			if(value != null) {
				tmp = value;
			} else {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			return tmp.to(null,spec);
		} else {
			let value = runtime_Actions.ACTIONS.get(type.get_TYPE_KIND());
			let tmp;
			if(value != null) {
				tmp = value;
			} else {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			return tmp.to(type,spec);
		}
	}
}
runtime_actions_To.__name__ = true;
class runtime_actions_Trim {
	static call(series,options) {
		let value = runtime_Actions.ACTIONS.get(series.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.trim(series,options);
	}
}
runtime_actions_Trim.__name__ = true;
class runtime_actions_Xor {
	static call(value1,value2) {
		let value = runtime_Actions.ACTIONS.get(value1.get_TYPE_KIND());
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return value.xor(value1,value2);
	}
}
runtime_actions_Xor.__name__ = true;
function runtime_actions_datatypes__$BlockLikeActions_compareEach(blk1,blk2,op) {
	let isSame = blk1 == blk2 || blk1.constructor == blk2.constructor && blk1.values == blk2.values && blk1.index == blk2.index;
	if(op == 9) {
		if(isSame) {
			return 0;
		} else {
			return -1;
		}
	}
	if(isSame) {
		return 0;
	}
	if(Cycles.find(blk1.values)) {
		return Cycles.find(blk2.values) ? 0 : -1;
	}
	let size1 = blk1.values.length - blk1.index;
	let size2 = blk2.values.length - blk2.index;
	if(size1 != size2) {
		switch(op) {
		case 0:case 1:case 2:case 10:case 11:
			return 1;
		default:
		}
	}
	if(size1 == 0) {
		return 0;
	}
	let len = Math.min(size1, size2);
	Cycles.push(blk1.values);
	Cycles.push(blk2.values);
	let res = 0;
	let _g = 0;
	while(_g < len) {
		let i = _g++;
		let v1 = blk1.wrap(blk1.values[blk1.index + i]);
		let v2 = blk2.wrap(blk2.values[blk2.index + i]);
		if(v1.constructor == v2.constructor || ((v1) instanceof types_base__$AnyWord) && ((v2) instanceof types_base__$AnyWord) || (((v1) instanceof types_Integer) || ((v1) instanceof types_Float)) && (((v2) instanceof types_Float) || ((v2) instanceof types_Integer))) {
			res = runtime_Actions.compareValue(v1,v2,op);
		} else {
			Cycles.popN(2);
			return Math.sign((v1.get_TYPE_KIND() - v2.get_TYPE_KIND()));
		}
		if(res != 0) {
			break;
		}
	}
	Cycles.popN(2);
	if(res == 0) {
		return Math.sign((size1 - size2));
	} else {
		return res;
	}
}
var types_NativeFn = { __ename__:true,__constructs__:["NIf","NUnless","NEither","NAny","NAll","NWhile","NUntil","NLoop","NRepeat","NForever","NForeach","NForall","NRemoveEach","NFunc","NFunction","NDoes","NHas","NSwitch","NCase","NDo","NGet","NSet","NPrint","NPrin","NEqual_q","NNotEqual_q","NStrictEqual_q","NLesser_q","NGreater_q","NLesserOrEqual_q","NGreaterOrEqual_q","NSame_q","NNot","NType_q","NReduce","NCompose","NStats","NBind","NIn","NParse","NUnion","NIntersect","NUnique","NDifference","NExclude","NComplement_q","NDehex","NEnhex","NNegative_q","NPositive_q","NMax","NMin","NShift","NToHex","NSine","NCosine","NTangent","NArcsine","NArccosine","NArctangent","NArctangent2","NNan_q","NLog2","NLog10","NLogE","NExp","NSquareRoot","NConstruct","NValue_q","NTry","NUppercase","NLowercase","NAsPair","NAsMoney","NBreak","NContinue","NExit","NReturn","NThrow","NCatch","NExtend","NDebase","NToLocalFile","NWait","NChecksum","NUnset","NNewLine","NNewLine_q","NEnbase","NContext_q","NSetEnv","NGetEnv","NListEnv","NNow","NSign_q","NAs","NCall","NZero_q","NSize_q","NBrowse","NCompress","NDecompress","NRecycle","NTranscode","NApply"] };
types_NativeFn.NIf = function(fn) { var $x = ["NIf",0,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NUnless = function(fn) { var $x = ["NUnless",1,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NEither = function(fn) { var $x = ["NEither",2,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NAny = function(fn) { var $x = ["NAny",3,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NAll = function(fn) { var $x = ["NAll",4,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NWhile = function(fn) { var $x = ["NWhile",5,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NUntil = function(fn) { var $x = ["NUntil",6,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NLoop = function(fn) { var $x = ["NLoop",7,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NRepeat = function(fn) { var $x = ["NRepeat",8,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NForever = function(fn) { var $x = ["NForever",9,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NForeach = function(fn) { var $x = ["NForeach",10,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NForall = function(fn) { var $x = ["NForall",11,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NRemoveEach = function(fn) { var $x = ["NRemoveEach",12,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NFunc = function(fn) { var $x = ["NFunc",13,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NFunction = function(fn) { var $x = ["NFunction",14,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NDoes = function(fn) { var $x = ["NDoes",15,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NHas = function(fn) { var $x = ["NHas",16,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NSwitch = function(fn) { var $x = ["NSwitch",17,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NCase = function(fn) { var $x = ["NCase",18,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NDo = function(fn) { var $x = ["NDo",19,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NGet = function(fn) { var $x = ["NGet",20,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NSet = function(fn) { var $x = ["NSet",21,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NPrint = function(fn) { var $x = ["NPrint",22,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NPrin = function(fn) { var $x = ["NPrin",23,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NEqual_q = function(fn) { var $x = ["NEqual_q",24,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NNotEqual_q = function(fn) { var $x = ["NNotEqual_q",25,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NStrictEqual_q = function(fn) { var $x = ["NStrictEqual_q",26,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NLesser_q = function(fn) { var $x = ["NLesser_q",27,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NGreater_q = function(fn) { var $x = ["NGreater_q",28,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NLesserOrEqual_q = function(fn) { var $x = ["NLesserOrEqual_q",29,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NGreaterOrEqual_q = function(fn) { var $x = ["NGreaterOrEqual_q",30,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NSame_q = function(fn) { var $x = ["NSame_q",31,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NNot = function(fn) { var $x = ["NNot",32,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NType_q = function(fn) { var $x = ["NType_q",33,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NReduce = function(fn) { var $x = ["NReduce",34,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NCompose = function(fn) { var $x = ["NCompose",35,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NStats = function(fn) { var $x = ["NStats",36,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NBind = function(fn) { var $x = ["NBind",37,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NIn = function(fn) { var $x = ["NIn",38,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NParse = function(fn) { var $x = ["NParse",39,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NUnion = function(fn) { var $x = ["NUnion",40,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NIntersect = function(fn) { var $x = ["NIntersect",41,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NUnique = function(fn) { var $x = ["NUnique",42,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NDifference = function(fn) { var $x = ["NDifference",43,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NExclude = function(fn) { var $x = ["NExclude",44,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NComplement_q = function(fn) { var $x = ["NComplement_q",45,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NDehex = function(fn) { var $x = ["NDehex",46,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NEnhex = function(fn) { var $x = ["NEnhex",47,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NNegative_q = function(fn) { var $x = ["NNegative_q",48,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NPositive_q = function(fn) { var $x = ["NPositive_q",49,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NMax = function(fn) { var $x = ["NMax",50,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NMin = function(fn) { var $x = ["NMin",51,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NShift = function(fn) { var $x = ["NShift",52,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NToHex = function(fn) { var $x = ["NToHex",53,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NSine = function(fn) { var $x = ["NSine",54,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NCosine = function(fn) { var $x = ["NCosine",55,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NTangent = function(fn) { var $x = ["NTangent",56,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NArcsine = function(fn) { var $x = ["NArcsine",57,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NArccosine = function(fn) { var $x = ["NArccosine",58,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NArctangent = function(fn) { var $x = ["NArctangent",59,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NArctangent2 = function(fn) { var $x = ["NArctangent2",60,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NNan_q = function(fn) { var $x = ["NNan_q",61,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NLog2 = function(fn) { var $x = ["NLog2",62,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NLog10 = function(fn) { var $x = ["NLog10",63,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NLogE = function(fn) { var $x = ["NLogE",64,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NExp = function(fn) { var $x = ["NExp",65,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NSquareRoot = function(fn) { var $x = ["NSquareRoot",66,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NConstruct = function(fn) { var $x = ["NConstruct",67,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NValue_q = function(fn) { var $x = ["NValue_q",68,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NTry = function(fn) { var $x = ["NTry",69,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NUppercase = function(fn) { var $x = ["NUppercase",70,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NLowercase = function(fn) { var $x = ["NLowercase",71,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NAsPair = function(fn) { var $x = ["NAsPair",72,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NAsMoney = function(fn) { var $x = ["NAsMoney",73,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NBreak = function(fn) { var $x = ["NBreak",74,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NContinue = function(fn) { var $x = ["NContinue",75,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NExit = function(fn) { var $x = ["NExit",76,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NReturn = function(fn) { var $x = ["NReturn",77,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NThrow = function(fn) { var $x = ["NThrow",78,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NCatch = function(fn) { var $x = ["NCatch",79,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NExtend = function(fn) { var $x = ["NExtend",80,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NDebase = function(fn) { var $x = ["NDebase",81,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NToLocalFile = function(fn) { var $x = ["NToLocalFile",82,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NWait = function(fn) { var $x = ["NWait",83,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NChecksum = function(fn) { var $x = ["NChecksum",84,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NUnset = function(fn) { var $x = ["NUnset",85,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NNewLine = function(fn) { var $x = ["NNewLine",86,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NNewLine_q = function(fn) { var $x = ["NNewLine_q",87,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NEnbase = function(fn) { var $x = ["NEnbase",88,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NContext_q = function(fn) { var $x = ["NContext_q",89,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NSetEnv = function(fn) { var $x = ["NSetEnv",90,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NGetEnv = function(fn) { var $x = ["NGetEnv",91,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NListEnv = function(fn) { var $x = ["NListEnv",92,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NNow = function(fn) { var $x = ["NNow",93,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NSign_q = function(fn) { var $x = ["NSign_q",94,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NAs = function(fn) { var $x = ["NAs",95,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NCall = function(fn) { var $x = ["NCall",96,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NZero_q = function(fn) { var $x = ["NZero_q",97,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NSize_q = function(fn) { var $x = ["NSize_q",98,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NBrowse = function(fn) { var $x = ["NBrowse",99,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NCompress = function(fn) { var $x = ["NCompress",100,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NDecompress = function(fn) { var $x = ["NDecompress",101,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NRecycle = function(fn) { var $x = ["NRecycle",102,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NTranscode = function(fn) { var $x = ["NTranscode",103,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
types_NativeFn.NApply = function(fn) { var $x = ["NApply",104,fn]; $x.__enum__ = types_NativeFn; $x.toString = $estr; return $x; }
class types_None extends Value {
	constructor() {
		super();
	}
	isTruthy() {
		return false;
	}
	get_TYPE_KIND() {
		return 2;
	}
}
types_None.__name__ = true;
types_None.__super__ = Value;
Object.assign(types_None.prototype, {
	__class__: types_None
});
class util__$Series__$Series {
	constructor(values,offset) {
		this.values = values;
		this.offset = offset;
	}
}
util__$Series__$Series.__name__ = true;
Object.assign(util__$Series__$Series.prototype, {
	__class__: util__$Series__$Series
});
class runtime_natives_Do {
	static _doesBecomeFunction(value,values) {
		while(true) {
			let _hx_tmp;
			if(js_Boot.__implements(value,types_base_IFunction) == true) {
				let __anon0__fn = value;
				let fn = __anon0__fn;
				return [fn,values];
			} else {
				_hx_tmp = js_Boot.__implements(value,types_base_IGetPath);
				if(_hx_tmp == true) {
					let __anon0__g = value;
					if(values.offset < values.values.length) {
						let g = __anon0__g;
						values.offset++;
						let _g = g.getPath(values.values[values.offset - 1]);
						switch(_g[1]) {
						case 0:
							let v = _g[2];
							value = v;
							continue;
						case 1:
							return null;
						}
					} else {
						return null;
					}
				} else {
					return null;
				}
			}
		}
	}
	static doesBecomeFunction(path) {
		let _g = path.pick(0);
		if(((_g) instanceof types_Word) == true) {
			let __anon0__head = _g;
			let head = __anon0__head;
			let tmp = head.get(true);
			let this_values = path.values;
			let this_offset = path.index;
			return runtime_natives_Do._doesBecomeFunction(tmp,new util__$Series__$Series(this_values,this_offset + 1));
		} else {
			return null;
		}
	}
	static checkForOp(values) {
		if(values.values.length - values.offset >= 2) {
			let _g = values.values[values.offset];
			let _hx_tmp;
			let _hx_tmp1 = ((_g) instanceof types_Word) ? _g : null;
			let _hx_tmp_a = _hx_tmp1 != null;
			let _hx_tmp_b = _hx_tmp1;
			let _g1 = _hx_tmp_b;
			if(_hx_tmp_a == true) {
				let _hx_tmp2;
				if(_g1 == null) {
					_hx_tmp2 = _g1;
					let _hx_tmp3 = _hx_tmp2.get(true);
					if(((_hx_tmp3) instanceof types_Op) == true) {
						let __anon0__o = _hx_tmp3;
						let o = __anon0__o;
						return o;
					} else if(_hx_tmp1 == null) {
						_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
						let _hx_tmp_a = _hx_tmp != null;
						let _hx_tmp_b = _hx_tmp;
						let _g1 = _hx_tmp_b;
						if(_hx_tmp_a == true) {
							let _hx_tmp;
							if(_g1 == null) {
								_hx_tmp = _g1;
								let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
								if(_hx_tmp1 == null) {
									return null;
								} else {
									let _g = _hx_tmp1[0];
									let _g1 = _hx_tmp1[1];
									if(((_g) instanceof types_Op) == true) {
										let __anon0__o = _g;
										let o = __anon0__o;
										return o;
									} else {
										return null;
									}
								}
							} else {
								_hx_tmp = _g1;
								let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
								if(_hx_tmp1 == null) {
									return null;
								} else {
									let _g = _hx_tmp1[0];
									let _g1 = _hx_tmp1[1];
									if(((_g) instanceof types_Op) == true) {
										let __anon0__o = _g;
										let o = __anon0__o;
										return o;
									} else {
										return null;
									}
								}
							}
						} else {
							return null;
						}
					} else {
						_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
						let _hx_tmp_a = _hx_tmp != null;
						let _hx_tmp_b = _hx_tmp;
						let _g1 = _hx_tmp_b;
						if(_hx_tmp_a == true) {
							let _hx_tmp;
							if(_g1 == null) {
								_hx_tmp = _g1;
								let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
								if(_hx_tmp1 == null) {
									return null;
								} else {
									let _g = _hx_tmp1[0];
									let _g1 = _hx_tmp1[1];
									if(((_g) instanceof types_Op) == true) {
										let __anon0__o = _g;
										let o = __anon0__o;
										return o;
									} else {
										return null;
									}
								}
							} else {
								_hx_tmp = _g1;
								let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
								if(_hx_tmp1 == null) {
									return null;
								} else {
									let _g = _hx_tmp1[0];
									let _g1 = _hx_tmp1[1];
									if(((_g) instanceof types_Op) == true) {
										let __anon0__o = _g;
										let o = __anon0__o;
										return o;
									} else {
										return null;
									}
								}
							}
						} else {
							return null;
						}
					}
				} else {
					_hx_tmp2 = _g1;
					let _hx_tmp3 = _hx_tmp2.get(true);
					if(((_hx_tmp3) instanceof types_Op) == true) {
						let __anon0__o = _hx_tmp3;
						let o = __anon0__o;
						return o;
					} else if(_hx_tmp1 == null) {
						_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
						let _hx_tmp_a = _hx_tmp != null;
						let _hx_tmp_b = _hx_tmp;
						let _g1 = _hx_tmp_b;
						if(_hx_tmp_a == true) {
							let _hx_tmp;
							if(_g1 == null) {
								_hx_tmp = _g1;
								let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
								if(_hx_tmp1 == null) {
									return null;
								} else {
									let _g = _hx_tmp1[0];
									let _g1 = _hx_tmp1[1];
									if(((_g) instanceof types_Op) == true) {
										let __anon0__o = _g;
										let o = __anon0__o;
										return o;
									} else {
										return null;
									}
								}
							} else {
								_hx_tmp = _g1;
								let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
								if(_hx_tmp1 == null) {
									return null;
								} else {
									let _g = _hx_tmp1[0];
									let _g1 = _hx_tmp1[1];
									if(((_g) instanceof types_Op) == true) {
										let __anon0__o = _g;
										let o = __anon0__o;
										return o;
									} else {
										return null;
									}
								}
							}
						} else {
							return null;
						}
					} else {
						_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
						let _hx_tmp_a = _hx_tmp != null;
						let _hx_tmp_b = _hx_tmp;
						let _g1 = _hx_tmp_b;
						if(_hx_tmp_a == true) {
							let _hx_tmp;
							if(_g1 == null) {
								_hx_tmp = _g1;
								let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
								if(_hx_tmp1 == null) {
									return null;
								} else {
									let _g = _hx_tmp1[0];
									let _g1 = _hx_tmp1[1];
									if(((_g) instanceof types_Op) == true) {
										let __anon0__o = _g;
										let o = __anon0__o;
										return o;
									} else {
										return null;
									}
								}
							} else {
								_hx_tmp = _g1;
								let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
								if(_hx_tmp1 == null) {
									return null;
								} else {
									let _g = _hx_tmp1[0];
									let _g1 = _hx_tmp1[1];
									if(((_g) instanceof types_Op) == true) {
										let __anon0__o = _g;
										let o = __anon0__o;
										return o;
									} else {
										return null;
									}
								}
							}
						} else {
							return null;
						}
					}
				}
			} else if(_g1 == null) {
				if(_hx_tmp1 == null) {
					_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
					let _hx_tmp_a = _hx_tmp != null;
					let _hx_tmp_b = _hx_tmp;
					let _g1 = _hx_tmp_b;
					if(_hx_tmp_a == true) {
						let _hx_tmp;
						if(_g1 == null) {
							_hx_tmp = _g1;
							let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
							if(_hx_tmp1 == null) {
								return null;
							} else {
								let _g = _hx_tmp1[0];
								let _g1 = _hx_tmp1[1];
								if(((_g) instanceof types_Op) == true) {
									let __anon0__o = _g;
									let o = __anon0__o;
									return o;
								} else {
									return null;
								}
							}
						} else {
							_hx_tmp = _g1;
							let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
							if(_hx_tmp1 == null) {
								return null;
							} else {
								let _g = _hx_tmp1[0];
								let _g1 = _hx_tmp1[1];
								if(((_g) instanceof types_Op) == true) {
									let __anon0__o = _g;
									let o = __anon0__o;
									return o;
								} else {
									return null;
								}
							}
						}
					} else {
						return null;
					}
				} else {
					_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
					let _hx_tmp_a = _hx_tmp != null;
					let _hx_tmp_b = _hx_tmp;
					let _g1 = _hx_tmp_b;
					if(_hx_tmp_a == true) {
						let _hx_tmp;
						if(_g1 == null) {
							_hx_tmp = _g1;
							let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
							if(_hx_tmp1 == null) {
								return null;
							} else {
								let _g = _hx_tmp1[0];
								let _g1 = _hx_tmp1[1];
								if(((_g) instanceof types_Op) == true) {
									let __anon0__o = _g;
									let o = __anon0__o;
									return o;
								} else {
									return null;
								}
							}
						} else {
							_hx_tmp = _g1;
							let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
							if(_hx_tmp1 == null) {
								return null;
							} else {
								let _g = _hx_tmp1[0];
								let _g1 = _hx_tmp1[1];
								if(((_g) instanceof types_Op) == true) {
									let __anon0__o = _g;
									let o = __anon0__o;
									return o;
								} else {
									return null;
								}
							}
						}
					} else {
						return null;
					}
				}
			} else if(_hx_tmp1 == null) {
				_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
				let _hx_tmp_a = _hx_tmp != null;
				let _hx_tmp_b = _hx_tmp;
				let _g1 = _hx_tmp_b;
				if(_hx_tmp_a == true) {
					let _hx_tmp;
					if(_g1 == null) {
						_hx_tmp = _g1;
						let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
						if(_hx_tmp1 == null) {
							return null;
						} else {
							let _g = _hx_tmp1[0];
							let _g1 = _hx_tmp1[1];
							if(((_g) instanceof types_Op) == true) {
								let __anon0__o = _g;
								let o = __anon0__o;
								return o;
							} else {
								return null;
							}
						}
					} else {
						_hx_tmp = _g1;
						let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
						if(_hx_tmp1 == null) {
							return null;
						} else {
							let _g = _hx_tmp1[0];
							let _g1 = _hx_tmp1[1];
							if(((_g) instanceof types_Op) == true) {
								let __anon0__o = _g;
								let o = __anon0__o;
								return o;
							} else {
								return null;
							}
						}
					}
				} else {
					return null;
				}
			} else {
				_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
				let _hx_tmp_a = _hx_tmp != null;
				let _hx_tmp_b = _hx_tmp;
				let _g1 = _hx_tmp_b;
				if(_hx_tmp_a == true) {
					let _hx_tmp;
					if(_g1 == null) {
						_hx_tmp = _g1;
						let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
						if(_hx_tmp1 == null) {
							return null;
						} else {
							let _g = _hx_tmp1[0];
							let _g1 = _hx_tmp1[1];
							if(((_g) instanceof types_Op) == true) {
								let __anon0__o = _g;
								let o = __anon0__o;
								return o;
							} else {
								return null;
							}
						}
					} else {
						_hx_tmp = _g1;
						let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
						if(_hx_tmp1 == null) {
							return null;
						} else {
							let _g = _hx_tmp1[0];
							let _g1 = _hx_tmp1[1];
							if(((_g) instanceof types_Op) == true) {
								let __anon0__o = _g;
								let o = __anon0__o;
								return o;
							} else {
								return null;
							}
						}
					}
				} else {
					return null;
				}
			}
		} else {
			return null;
		}
	}
	static groupParams(values,params) {
		let res = new Array(params.length);
		let _g = 0;
		let _g1 = params.length;
		while(_g < _g1) {
			let i = _g++;
			[res[i], values] = runtime_natives_Do.groupNextExprForParam(values,params[i]);
		}
		return [res,values];
	}
	static groupNextExpr(values) {
		if(values.values.length - values.offset >= 3) {
			let _g = runtime_natives_Do.checkForOp(new util__$Series__$Series(values.values,values.offset + 1));
			if(_g != null == true) {
				let __anon0__o = _g;
				let o = __anon0__o;
				if(o.get_params()[0].quoting != types_base_QuotingKind.QVal) {
					let o = __anon0__o;
					/*;
					let left = ;
					let values2 = ;
					*/ //;
					let [left, values2] = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[0]);
					let self = runtime_natives_Do.groupNextExprForParam(values2,o.get_params()[0]);
					return [runtime_natives_GroupedExpr.GOp(left,o,self[0]),self[1]];
				}
			}
		}
		values.offset++;
		let value = values.values[values.offset - 1];
		let _g;
		if(value != null) {
			_g = value;
		} else {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((_g) instanceof types_SetWord) == true) {
			let __anon0__s = _g;
			let s = __anon0__s;
			let self = runtime_natives_Do.groupNextExpr(values);
			return [runtime_natives_GroupedExpr.GSetWord(s,self[0]),self[1]];
		} else {
			_hx_tmp2 = ((_g) instanceof types_SetPath);
			if(_hx_tmp2 == true) {
				let __anon0__s = _g;
				let s = __anon0__s;
				let self = runtime_natives_Do.groupNextExpr(values);
				return [runtime_natives_GroupedExpr.GSetPath(s,self[0]),self[1]];
			} else {
				_hx_tmp1 = ((_g) instanceof types_Word) ? _g : null;
				let _hx_tmp_a = _hx_tmp1 != null;
				let _hx_tmp_b = _hx_tmp1;
				let _g1 = _hx_tmp_b;
				if(_hx_tmp_a == true) {
					let _hx_tmp2;
					if(_g1 == null) {
						_hx_tmp2 = _g1;
						let _hx_tmp3 = _hx_tmp2.get(true);
						if(js_Boot.__implements(_hx_tmp3,types_base_IFunction) == true) {
							let __anon0__fn = _hx_tmp3;
							let fn = __anon0__fn;
							let self = runtime_natives_Do.groupParams(values,fn.get_params());
							return [runtime_natives_GroupedExpr.GCall(fn,self[0],new Map([])),self[1]];
						} else if(_hx_tmp1 == null) {
							_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
							let _hx_tmp_a = _hx_tmp != null;
							let _hx_tmp_b = _hx_tmp;
							let _g1 = _hx_tmp_b;
							if(_hx_tmp_a == true) {
								let _hx_tmp;
								if(_g1 == null) {
									_hx_tmp = _g1;
									let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
									if(_hx_tmp1 == null) {
										let v = _g;
										let _g1 = runtime_natives_Do.checkForOp(values);
										let _hx_tmp;
										if(_g1 == null) {
											return [runtime_natives_GroupedExpr.GValue(v),values];
										} else {
											_hx_tmp = _g1;
											let o = _hx_tmp;
											values.offset++;
											let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
											return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
										}
									} else {
										let fn = _hx_tmp1[0];
										let rest = _hx_tmp1[1];
										let args = runtime_natives_Do.groupParams(values,fn.get_params());
										if(rest.values.length - rest.offset == 0) {
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
										} else {
											let refines = new Map();
											let dynamicRefines = new Map();
											values = args[1];
											let _g = 0;
											while(_g < rest.values.length - rest.offset) {
												let value = rest.values[rest.offset + _g];
												++_g;
												let _hx_tmp;
												if(((value) instanceof types_Word) == true) {
													let __anon0__w = value;
													let w = __anon0__w;
													let _g = fn.findRefine(w);
													if(_g == null) {
														throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
													} else {
														let _g1 = _g.name;
														let _g2 = _g.doc;
														let _g3 = _g.params;
														let n = _g1;
														if(refines.has(n)) {
															throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
														} else {
															let n = _g1;
															let params2 = _g3;
															let refine;
															/*;
															refine = */ //;
															[refine, values] = runtime_natives_Do.groupParams(values,params2);
															refines.set(n,refine);
														}
													}
												} else {
													_hx_tmp = ((value) instanceof types_GetWord);
													if(_hx_tmp == true) {
														let __anon0__w = value;
														let w = __anon0__w;
														let _g = fn.findRefine(w);
														if(_g == null) {
															throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
														} else {
															let _g1 = _g.name;
															let _g2 = _g.doc;
															let _g3 = _g.params;
															let n = _g1;
															if(refines.has(n)) {
																throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
															} else {
																let n = _g1;
																let params2 = _g3;
																let refine;
																/*;
																refine = */ //;
																[refine, values] = runtime_natives_Do.groupParams(values,params2);
																refines.set(n,refine);
																let value = runtime_natives_GroupedExpr.GNoEval(w.get());
																dynamicRefines.set(n,value);
															}
														}
													} else {
														throw haxe_Exception.thrown("Invalid refinement!");
													}
												}
											}
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
										}
									}
								} else {
									_hx_tmp = _g1;
									let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
									if(_hx_tmp1 == null) {
										let v = _g;
										let _g1 = runtime_natives_Do.checkForOp(values);
										let _hx_tmp;
										if(_g1 == null) {
											return [runtime_natives_GroupedExpr.GValue(v),values];
										} else {
											_hx_tmp = _g1;
											let o = _hx_tmp;
											values.offset++;
											let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
											return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
										}
									} else {
										let fn = _hx_tmp1[0];
										let rest = _hx_tmp1[1];
										let args = runtime_natives_Do.groupParams(values,fn.get_params());
										if(rest.values.length - rest.offset == 0) {
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
										} else {
											let refines = new Map();
											let dynamicRefines = new Map();
											values = args[1];
											let _g = 0;
											while(_g < rest.values.length - rest.offset) {
												let value = rest.values[rest.offset + _g];
												++_g;
												let _hx_tmp;
												if(((value) instanceof types_Word) == true) {
													let __anon0__w = value;
													let w = __anon0__w;
													let _g = fn.findRefine(w);
													if(_g == null) {
														throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
													} else {
														let _g1 = _g.name;
														let _g2 = _g.doc;
														let _g3 = _g.params;
														let n = _g1;
														if(refines.has(n)) {
															throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
														} else {
															let n = _g1;
															let params2 = _g3;
															let refine;
															/*;
															refine = */ //;
															[refine, values] = runtime_natives_Do.groupParams(values,params2);
															refines.set(n,refine);
														}
													}
												} else {
													_hx_tmp = ((value) instanceof types_GetWord);
													if(_hx_tmp == true) {
														let __anon0__w = value;
														let w = __anon0__w;
														let _g = fn.findRefine(w);
														if(_g == null) {
															throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
														} else {
															let _g1 = _g.name;
															let _g2 = _g.doc;
															let _g3 = _g.params;
															let n = _g1;
															if(refines.has(n)) {
																throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
															} else {
																let n = _g1;
																let params2 = _g3;
																let refine;
																/*;
																refine = */ //;
																[refine, values] = runtime_natives_Do.groupParams(values,params2);
																refines.set(n,refine);
																let value = runtime_natives_GroupedExpr.GNoEval(w.get());
																dynamicRefines.set(n,value);
															}
														}
													} else {
														throw haxe_Exception.thrown("Invalid refinement!");
													}
												}
											}
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
										}
									}
								}
							} else {
								let v = _g;
								let _g1 = runtime_natives_Do.checkForOp(values);
								let _hx_tmp;
								if(_g1 == null) {
									return [runtime_natives_GroupedExpr.GValue(v),values];
								} else {
									_hx_tmp = _g1;
									let o = _hx_tmp;
									values.offset++;
									let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
									return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
								}
							}
						} else {
							_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
							let _hx_tmp_a = _hx_tmp != null;
							let _hx_tmp_b = _hx_tmp;
							let _g1 = _hx_tmp_b;
							if(_hx_tmp_a == true) {
								let _hx_tmp;
								if(_g1 == null) {
									_hx_tmp = _g1;
									let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
									if(_hx_tmp1 == null) {
										let v = _g;
										let _g1 = runtime_natives_Do.checkForOp(values);
										let _hx_tmp;
										if(_g1 == null) {
											return [runtime_natives_GroupedExpr.GValue(v),values];
										} else {
											_hx_tmp = _g1;
											let o = _hx_tmp;
											values.offset++;
											let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
											return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
										}
									} else {
										let fn = _hx_tmp1[0];
										let rest = _hx_tmp1[1];
										let args = runtime_natives_Do.groupParams(values,fn.get_params());
										if(rest.values.length - rest.offset == 0) {
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
										} else {
											let refines = new Map();
											let dynamicRefines = new Map();
											values = args[1];
											let _g = 0;
											while(_g < rest.values.length - rest.offset) {
												let value = rest.values[rest.offset + _g];
												++_g;
												let _hx_tmp;
												if(((value) instanceof types_Word) == true) {
													let __anon0__w = value;
													let w = __anon0__w;
													let _g = fn.findRefine(w);
													if(_g == null) {
														throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
													} else {
														let _g1 = _g.name;
														let _g2 = _g.doc;
														let _g3 = _g.params;
														let n = _g1;
														if(refines.has(n)) {
															throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
														} else {
															let n = _g1;
															let params2 = _g3;
															let refine;
															/*;
															refine = */ //;
															[refine, values] = runtime_natives_Do.groupParams(values,params2);
															refines.set(n,refine);
														}
													}
												} else {
													_hx_tmp = ((value) instanceof types_GetWord);
													if(_hx_tmp == true) {
														let __anon0__w = value;
														let w = __anon0__w;
														let _g = fn.findRefine(w);
														if(_g == null) {
															throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
														} else {
															let _g1 = _g.name;
															let _g2 = _g.doc;
															let _g3 = _g.params;
															let n = _g1;
															if(refines.has(n)) {
																throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
															} else {
																let n = _g1;
																let params2 = _g3;
																let refine;
																/*;
																refine = */ //;
																[refine, values] = runtime_natives_Do.groupParams(values,params2);
																refines.set(n,refine);
																let value = runtime_natives_GroupedExpr.GNoEval(w.get());
																dynamicRefines.set(n,value);
															}
														}
													} else {
														throw haxe_Exception.thrown("Invalid refinement!");
													}
												}
											}
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
										}
									}
								} else {
									_hx_tmp = _g1;
									let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
									if(_hx_tmp1 == null) {
										let v = _g;
										let _g1 = runtime_natives_Do.checkForOp(values);
										let _hx_tmp;
										if(_g1 == null) {
											return [runtime_natives_GroupedExpr.GValue(v),values];
										} else {
											_hx_tmp = _g1;
											let o = _hx_tmp;
											values.offset++;
											let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
											return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
										}
									} else {
										let fn = _hx_tmp1[0];
										let rest = _hx_tmp1[1];
										let args = runtime_natives_Do.groupParams(values,fn.get_params());
										if(rest.values.length - rest.offset == 0) {
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
										} else {
											let refines = new Map();
											let dynamicRefines = new Map();
											values = args[1];
											let _g = 0;
											while(_g < rest.values.length - rest.offset) {
												let value = rest.values[rest.offset + _g];
												++_g;
												let _hx_tmp;
												if(((value) instanceof types_Word) == true) {
													let __anon0__w = value;
													let w = __anon0__w;
													let _g = fn.findRefine(w);
													if(_g == null) {
														throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
													} else {
														let _g1 = _g.name;
														let _g2 = _g.doc;
														let _g3 = _g.params;
														let n = _g1;
														if(refines.has(n)) {
															throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
														} else {
															let n = _g1;
															let params2 = _g3;
															let refine;
															/*;
															refine = */ //;
															[refine, values] = runtime_natives_Do.groupParams(values,params2);
															refines.set(n,refine);
														}
													}
												} else {
													_hx_tmp = ((value) instanceof types_GetWord);
													if(_hx_tmp == true) {
														let __anon0__w = value;
														let w = __anon0__w;
														let _g = fn.findRefine(w);
														if(_g == null) {
															throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
														} else {
															let _g1 = _g.name;
															let _g2 = _g.doc;
															let _g3 = _g.params;
															let n = _g1;
															if(refines.has(n)) {
																throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
															} else {
																let n = _g1;
																let params2 = _g3;
																let refine;
																/*;
																refine = */ //;
																[refine, values] = runtime_natives_Do.groupParams(values,params2);
																refines.set(n,refine);
																let value = runtime_natives_GroupedExpr.GNoEval(w.get());
																dynamicRefines.set(n,value);
															}
														}
													} else {
														throw haxe_Exception.thrown("Invalid refinement!");
													}
												}
											}
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
										}
									}
								}
							} else {
								let v = _g;
								let _g1 = runtime_natives_Do.checkForOp(values);
								let _hx_tmp;
								if(_g1 == null) {
									return [runtime_natives_GroupedExpr.GValue(v),values];
								} else {
									_hx_tmp = _g1;
									let o = _hx_tmp;
									values.offset++;
									let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
									return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
								}
							}
						}
					} else {
						_hx_tmp2 = _g1;
						let _hx_tmp3 = _hx_tmp2.get(true);
						if(js_Boot.__implements(_hx_tmp3,types_base_IFunction) == true) {
							let __anon0__fn = _hx_tmp3;
							let fn = __anon0__fn;
							let self = runtime_natives_Do.groupParams(values,fn.get_params());
							return [runtime_natives_GroupedExpr.GCall(fn,self[0],new Map([])),self[1]];
						} else if(_hx_tmp1 == null) {
							_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
							let _hx_tmp_a = _hx_tmp != null;
							let _hx_tmp_b = _hx_tmp;
							let _g1 = _hx_tmp_b;
							if(_hx_tmp_a == true) {
								let _hx_tmp;
								if(_g1 == null) {
									_hx_tmp = _g1;
									let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
									if(_hx_tmp1 == null) {
										let v = _g;
										let _g1 = runtime_natives_Do.checkForOp(values);
										let _hx_tmp;
										if(_g1 == null) {
											return [runtime_natives_GroupedExpr.GValue(v),values];
										} else {
											_hx_tmp = _g1;
											let o = _hx_tmp;
											values.offset++;
											let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
											return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
										}
									} else {
										let fn = _hx_tmp1[0];
										let rest = _hx_tmp1[1];
										let args = runtime_natives_Do.groupParams(values,fn.get_params());
										if(rest.values.length - rest.offset == 0) {
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
										} else {
											let refines = new Map();
											let dynamicRefines = new Map();
											values = args[1];
											let _g = 0;
											while(_g < rest.values.length - rest.offset) {
												let value = rest.values[rest.offset + _g];
												++_g;
												let _hx_tmp;
												if(((value) instanceof types_Word) == true) {
													let __anon0__w = value;
													let w = __anon0__w;
													let _g = fn.findRefine(w);
													if(_g == null) {
														throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
													} else {
														let _g1 = _g.name;
														let _g2 = _g.doc;
														let _g3 = _g.params;
														let n = _g1;
														if(refines.has(n)) {
															throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
														} else {
															let n = _g1;
															let params2 = _g3;
															let refine;
															/*;
															refine = */ //;
															[refine, values] = runtime_natives_Do.groupParams(values,params2);
															refines.set(n,refine);
														}
													}
												} else {
													_hx_tmp = ((value) instanceof types_GetWord);
													if(_hx_tmp == true) {
														let __anon0__w = value;
														let w = __anon0__w;
														let _g = fn.findRefine(w);
														if(_g == null) {
															throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
														} else {
															let _g1 = _g.name;
															let _g2 = _g.doc;
															let _g3 = _g.params;
															let n = _g1;
															if(refines.has(n)) {
																throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
															} else {
																let n = _g1;
																let params2 = _g3;
																let refine;
																/*;
																refine = */ //;
																[refine, values] = runtime_natives_Do.groupParams(values,params2);
																refines.set(n,refine);
																let value = runtime_natives_GroupedExpr.GNoEval(w.get());
																dynamicRefines.set(n,value);
															}
														}
													} else {
														throw haxe_Exception.thrown("Invalid refinement!");
													}
												}
											}
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
										}
									}
								} else {
									_hx_tmp = _g1;
									let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
									if(_hx_tmp1 == null) {
										let v = _g;
										let _g1 = runtime_natives_Do.checkForOp(values);
										let _hx_tmp;
										if(_g1 == null) {
											return [runtime_natives_GroupedExpr.GValue(v),values];
										} else {
											_hx_tmp = _g1;
											let o = _hx_tmp;
											values.offset++;
											let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
											return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
										}
									} else {
										let fn = _hx_tmp1[0];
										let rest = _hx_tmp1[1];
										let args = runtime_natives_Do.groupParams(values,fn.get_params());
										if(rest.values.length - rest.offset == 0) {
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
										} else {
											let refines = new Map();
											let dynamicRefines = new Map();
											values = args[1];
											let _g = 0;
											while(_g < rest.values.length - rest.offset) {
												let value = rest.values[rest.offset + _g];
												++_g;
												let _hx_tmp;
												if(((value) instanceof types_Word) == true) {
													let __anon0__w = value;
													let w = __anon0__w;
													let _g = fn.findRefine(w);
													if(_g == null) {
														throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
													} else {
														let _g1 = _g.name;
														let _g2 = _g.doc;
														let _g3 = _g.params;
														let n = _g1;
														if(refines.has(n)) {
															throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
														} else {
															let n = _g1;
															let params2 = _g3;
															let refine;
															/*;
															refine = */ //;
															[refine, values] = runtime_natives_Do.groupParams(values,params2);
															refines.set(n,refine);
														}
													}
												} else {
													_hx_tmp = ((value) instanceof types_GetWord);
													if(_hx_tmp == true) {
														let __anon0__w = value;
														let w = __anon0__w;
														let _g = fn.findRefine(w);
														if(_g == null) {
															throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
														} else {
															let _g1 = _g.name;
															let _g2 = _g.doc;
															let _g3 = _g.params;
															let n = _g1;
															if(refines.has(n)) {
																throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
															} else {
																let n = _g1;
																let params2 = _g3;
																let refine;
																/*;
																refine = */ //;
																[refine, values] = runtime_natives_Do.groupParams(values,params2);
																refines.set(n,refine);
																let value = runtime_natives_GroupedExpr.GNoEval(w.get());
																dynamicRefines.set(n,value);
															}
														}
													} else {
														throw haxe_Exception.thrown("Invalid refinement!");
													}
												}
											}
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
										}
									}
								}
							} else {
								let v = _g;
								let _g1 = runtime_natives_Do.checkForOp(values);
								let _hx_tmp;
								if(_g1 == null) {
									return [runtime_natives_GroupedExpr.GValue(v),values];
								} else {
									_hx_tmp = _g1;
									let o = _hx_tmp;
									values.offset++;
									let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
									return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
								}
							}
						} else {
							_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
							let _hx_tmp_a = _hx_tmp != null;
							let _hx_tmp_b = _hx_tmp;
							let _g1 = _hx_tmp_b;
							if(_hx_tmp_a == true) {
								let _hx_tmp;
								if(_g1 == null) {
									_hx_tmp = _g1;
									let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
									if(_hx_tmp1 == null) {
										let v = _g;
										let _g1 = runtime_natives_Do.checkForOp(values);
										let _hx_tmp;
										if(_g1 == null) {
											return [runtime_natives_GroupedExpr.GValue(v),values];
										} else {
											_hx_tmp = _g1;
											let o = _hx_tmp;
											values.offset++;
											let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
											return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
										}
									} else {
										let fn = _hx_tmp1[0];
										let rest = _hx_tmp1[1];
										let args = runtime_natives_Do.groupParams(values,fn.get_params());
										if(rest.values.length - rest.offset == 0) {
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
										} else {
											let refines = new Map();
											let dynamicRefines = new Map();
											values = args[1];
											let _g = 0;
											while(_g < rest.values.length - rest.offset) {
												let value = rest.values[rest.offset + _g];
												++_g;
												let _hx_tmp;
												if(((value) instanceof types_Word) == true) {
													let __anon0__w = value;
													let w = __anon0__w;
													let _g = fn.findRefine(w);
													if(_g == null) {
														throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
													} else {
														let _g1 = _g.name;
														let _g2 = _g.doc;
														let _g3 = _g.params;
														let n = _g1;
														if(refines.has(n)) {
															throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
														} else {
															let n = _g1;
															let params2 = _g3;
															let refine;
															/*;
															refine = */ //;
															[refine, values] = runtime_natives_Do.groupParams(values,params2);
															refines.set(n,refine);
														}
													}
												} else {
													_hx_tmp = ((value) instanceof types_GetWord);
													if(_hx_tmp == true) {
														let __anon0__w = value;
														let w = __anon0__w;
														let _g = fn.findRefine(w);
														if(_g == null) {
															throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
														} else {
															let _g1 = _g.name;
															let _g2 = _g.doc;
															let _g3 = _g.params;
															let n = _g1;
															if(refines.has(n)) {
																throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
															} else {
																let n = _g1;
																let params2 = _g3;
																let refine;
																/*;
																refine = */ //;
																[refine, values] = runtime_natives_Do.groupParams(values,params2);
																refines.set(n,refine);
																let value = runtime_natives_GroupedExpr.GNoEval(w.get());
																dynamicRefines.set(n,value);
															}
														}
													} else {
														throw haxe_Exception.thrown("Invalid refinement!");
													}
												}
											}
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
										}
									}
								} else {
									_hx_tmp = _g1;
									let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
									if(_hx_tmp1 == null) {
										let v = _g;
										let _g1 = runtime_natives_Do.checkForOp(values);
										let _hx_tmp;
										if(_g1 == null) {
											return [runtime_natives_GroupedExpr.GValue(v),values];
										} else {
											_hx_tmp = _g1;
											let o = _hx_tmp;
											values.offset++;
											let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
											return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
										}
									} else {
										let fn = _hx_tmp1[0];
										let rest = _hx_tmp1[1];
										let args = runtime_natives_Do.groupParams(values,fn.get_params());
										if(rest.values.length - rest.offset == 0) {
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
										} else {
											let refines = new Map();
											let dynamicRefines = new Map();
											values = args[1];
											let _g = 0;
											while(_g < rest.values.length - rest.offset) {
												let value = rest.values[rest.offset + _g];
												++_g;
												let _hx_tmp;
												if(((value) instanceof types_Word) == true) {
													let __anon0__w = value;
													let w = __anon0__w;
													let _g = fn.findRefine(w);
													if(_g == null) {
														throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
													} else {
														let _g1 = _g.name;
														let _g2 = _g.doc;
														let _g3 = _g.params;
														let n = _g1;
														if(refines.has(n)) {
															throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
														} else {
															let n = _g1;
															let params2 = _g3;
															let refine;
															/*;
															refine = */ //;
															[refine, values] = runtime_natives_Do.groupParams(values,params2);
															refines.set(n,refine);
														}
													}
												} else {
													_hx_tmp = ((value) instanceof types_GetWord);
													if(_hx_tmp == true) {
														let __anon0__w = value;
														let w = __anon0__w;
														let _g = fn.findRefine(w);
														if(_g == null) {
															throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
														} else {
															let _g1 = _g.name;
															let _g2 = _g.doc;
															let _g3 = _g.params;
															let n = _g1;
															if(refines.has(n)) {
																throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
															} else {
																let n = _g1;
																let params2 = _g3;
																let refine;
																/*;
																refine = */ //;
																[refine, values] = runtime_natives_Do.groupParams(values,params2);
																refines.set(n,refine);
																let value = runtime_natives_GroupedExpr.GNoEval(w.get());
																dynamicRefines.set(n,value);
															}
														}
													} else {
														throw haxe_Exception.thrown("Invalid refinement!");
													}
												}
											}
											return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
										}
									}
								}
							} else {
								let v = _g;
								let _g1 = runtime_natives_Do.checkForOp(values);
								let _hx_tmp;
								if(_g1 == null) {
									return [runtime_natives_GroupedExpr.GValue(v),values];
								} else {
									_hx_tmp = _g1;
									let o = _hx_tmp;
									values.offset++;
									let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
									return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
								}
							}
						}
					}
				} else if(_g1 == null) {
					if(_hx_tmp1 == null) {
						_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
						let _hx_tmp_a = _hx_tmp != null;
						let _hx_tmp_b = _hx_tmp;
						let _g1 = _hx_tmp_b;
						if(_hx_tmp_a == true) {
							let _hx_tmp;
							if(_g1 == null) {
								_hx_tmp = _g1;
								let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
								if(_hx_tmp1 == null) {
									let v = _g;
									let _g1 = runtime_natives_Do.checkForOp(values);
									let _hx_tmp;
									if(_g1 == null) {
										return [runtime_natives_GroupedExpr.GValue(v),values];
									} else {
										_hx_tmp = _g1;
										let o = _hx_tmp;
										values.offset++;
										let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
										return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
									}
								} else {
									let fn = _hx_tmp1[0];
									let rest = _hx_tmp1[1];
									let args = runtime_natives_Do.groupParams(values,fn.get_params());
									if(rest.values.length - rest.offset == 0) {
										return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
									} else {
										let refines = new Map();
										let dynamicRefines = new Map();
										values = args[1];
										let _g = 0;
										while(_g < rest.values.length - rest.offset) {
											let value = rest.values[rest.offset + _g];
											++_g;
											let _hx_tmp;
											if(((value) instanceof types_Word) == true) {
												let __anon0__w = value;
												let w = __anon0__w;
												let _g = fn.findRefine(w);
												if(_g == null) {
													throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
												} else {
													let _g1 = _g.name;
													let _g2 = _g.doc;
													let _g3 = _g.params;
													let n = _g1;
													if(refines.has(n)) {
														throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
													} else {
														let n = _g1;
														let params2 = _g3;
														let refine;
														/*;
														refine = */ //;
														[refine, values] = runtime_natives_Do.groupParams(values,params2);
														refines.set(n,refine);
													}
												}
											} else {
												_hx_tmp = ((value) instanceof types_GetWord);
												if(_hx_tmp == true) {
													let __anon0__w = value;
													let w = __anon0__w;
													let _g = fn.findRefine(w);
													if(_g == null) {
														throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
													} else {
														let _g1 = _g.name;
														let _g2 = _g.doc;
														let _g3 = _g.params;
														let n = _g1;
														if(refines.has(n)) {
															throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
														} else {
															let n = _g1;
															let params2 = _g3;
															let refine;
															/*;
															refine = */ //;
															[refine, values] = runtime_natives_Do.groupParams(values,params2);
															refines.set(n,refine);
															let value = runtime_natives_GroupedExpr.GNoEval(w.get());
															dynamicRefines.set(n,value);
														}
													}
												} else {
													throw haxe_Exception.thrown("Invalid refinement!");
												}
											}
										}
										return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
									}
								}
							} else {
								_hx_tmp = _g1;
								let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
								if(_hx_tmp1 == null) {
									let v = _g;
									let _g1 = runtime_natives_Do.checkForOp(values);
									let _hx_tmp;
									if(_g1 == null) {
										return [runtime_natives_GroupedExpr.GValue(v),values];
									} else {
										_hx_tmp = _g1;
										let o = _hx_tmp;
										values.offset++;
										let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
										return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
									}
								} else {
									let fn = _hx_tmp1[0];
									let rest = _hx_tmp1[1];
									let args = runtime_natives_Do.groupParams(values,fn.get_params());
									if(rest.values.length - rest.offset == 0) {
										return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
									} else {
										let refines = new Map();
										let dynamicRefines = new Map();
										values = args[1];
										let _g = 0;
										while(_g < rest.values.length - rest.offset) {
											let value = rest.values[rest.offset + _g];
											++_g;
											let _hx_tmp;
											if(((value) instanceof types_Word) == true) {
												let __anon0__w = value;
												let w = __anon0__w;
												let _g = fn.findRefine(w);
												if(_g == null) {
													throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
												} else {
													let _g1 = _g.name;
													let _g2 = _g.doc;
													let _g3 = _g.params;
													let n = _g1;
													if(refines.has(n)) {
														throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
													} else {
														let n = _g1;
														let params2 = _g3;
														let refine;
														/*;
														refine = */ //;
														[refine, values] = runtime_natives_Do.groupParams(values,params2);
														refines.set(n,refine);
													}
												}
											} else {
												_hx_tmp = ((value) instanceof types_GetWord);
												if(_hx_tmp == true) {
													let __anon0__w = value;
													let w = __anon0__w;
													let _g = fn.findRefine(w);
													if(_g == null) {
														throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
													} else {
														let _g1 = _g.name;
														let _g2 = _g.doc;
														let _g3 = _g.params;
														let n = _g1;
														if(refines.has(n)) {
															throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
														} else {
															let n = _g1;
															let params2 = _g3;
															let refine;
															/*;
															refine = */ //;
															[refine, values] = runtime_natives_Do.groupParams(values,params2);
															refines.set(n,refine);
															let value = runtime_natives_GroupedExpr.GNoEval(w.get());
															dynamicRefines.set(n,value);
														}
													}
												} else {
													throw haxe_Exception.thrown("Invalid refinement!");
												}
											}
										}
										return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
									}
								}
							}
						} else {
							let v = _g;
							let _g1 = runtime_natives_Do.checkForOp(values);
							let _hx_tmp;
							if(_g1 == null) {
								return [runtime_natives_GroupedExpr.GValue(v),values];
							} else {
								_hx_tmp = _g1;
								let o = _hx_tmp;
								values.offset++;
								let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
								return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
							}
						}
					} else {
						_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
						let _hx_tmp_a = _hx_tmp != null;
						let _hx_tmp_b = _hx_tmp;
						let _g1 = _hx_tmp_b;
						if(_hx_tmp_a == true) {
							let _hx_tmp;
							if(_g1 == null) {
								_hx_tmp = _g1;
								let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
								if(_hx_tmp1 == null) {
									let v = _g;
									let _g1 = runtime_natives_Do.checkForOp(values);
									let _hx_tmp;
									if(_g1 == null) {
										return [runtime_natives_GroupedExpr.GValue(v),values];
									} else {
										_hx_tmp = _g1;
										let o = _hx_tmp;
										values.offset++;
										let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
										return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
									}
								} else {
									let fn = _hx_tmp1[0];
									let rest = _hx_tmp1[1];
									let args = runtime_natives_Do.groupParams(values,fn.get_params());
									if(rest.values.length - rest.offset == 0) {
										return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
									} else {
										let refines = new Map();
										let dynamicRefines = new Map();
										values = args[1];
										let _g = 0;
										while(_g < rest.values.length - rest.offset) {
											let value = rest.values[rest.offset + _g];
											++_g;
											let _hx_tmp;
											if(((value) instanceof types_Word) == true) {
												let __anon0__w = value;
												let w = __anon0__w;
												let _g = fn.findRefine(w);
												if(_g == null) {
													throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
												} else {
													let _g1 = _g.name;
													let _g2 = _g.doc;
													let _g3 = _g.params;
													let n = _g1;
													if(refines.has(n)) {
														throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
													} else {
														let n = _g1;
														let params2 = _g3;
														let refine;
														/*;
														refine = */ //;
														[refine, values] = runtime_natives_Do.groupParams(values,params2);
														refines.set(n,refine);
													}
												}
											} else {
												_hx_tmp = ((value) instanceof types_GetWord);
												if(_hx_tmp == true) {
													let __anon0__w = value;
													let w = __anon0__w;
													let _g = fn.findRefine(w);
													if(_g == null) {
														throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
													} else {
														let _g1 = _g.name;
														let _g2 = _g.doc;
														let _g3 = _g.params;
														let n = _g1;
														if(refines.has(n)) {
															throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
														} else {
															let n = _g1;
															let params2 = _g3;
															let refine;
															/*;
															refine = */ //;
															[refine, values] = runtime_natives_Do.groupParams(values,params2);
															refines.set(n,refine);
															let value = runtime_natives_GroupedExpr.GNoEval(w.get());
															dynamicRefines.set(n,value);
														}
													}
												} else {
													throw haxe_Exception.thrown("Invalid refinement!");
												}
											}
										}
										return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
									}
								}
							} else {
								_hx_tmp = _g1;
								let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
								if(_hx_tmp1 == null) {
									let v = _g;
									let _g1 = runtime_natives_Do.checkForOp(values);
									let _hx_tmp;
									if(_g1 == null) {
										return [runtime_natives_GroupedExpr.GValue(v),values];
									} else {
										_hx_tmp = _g1;
										let o = _hx_tmp;
										values.offset++;
										let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
										return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
									}
								} else {
									let fn = _hx_tmp1[0];
									let rest = _hx_tmp1[1];
									let args = runtime_natives_Do.groupParams(values,fn.get_params());
									if(rest.values.length - rest.offset == 0) {
										return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
									} else {
										let refines = new Map();
										let dynamicRefines = new Map();
										values = args[1];
										let _g = 0;
										while(_g < rest.values.length - rest.offset) {
											let value = rest.values[rest.offset + _g];
											++_g;
											let _hx_tmp;
											if(((value) instanceof types_Word) == true) {
												let __anon0__w = value;
												let w = __anon0__w;
												let _g = fn.findRefine(w);
												if(_g == null) {
													throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
												} else {
													let _g1 = _g.name;
													let _g2 = _g.doc;
													let _g3 = _g.params;
													let n = _g1;
													if(refines.has(n)) {
														throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
													} else {
														let n = _g1;
														let params2 = _g3;
														let refine;
														/*;
														refine = */ //;
														[refine, values] = runtime_natives_Do.groupParams(values,params2);
														refines.set(n,refine);
													}
												}
											} else {
												_hx_tmp = ((value) instanceof types_GetWord);
												if(_hx_tmp == true) {
													let __anon0__w = value;
													let w = __anon0__w;
													let _g = fn.findRefine(w);
													if(_g == null) {
														throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
													} else {
														let _g1 = _g.name;
														let _g2 = _g.doc;
														let _g3 = _g.params;
														let n = _g1;
														if(refines.has(n)) {
															throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
														} else {
															let n = _g1;
															let params2 = _g3;
															let refine;
															/*;
															refine = */ //;
															[refine, values] = runtime_natives_Do.groupParams(values,params2);
															refines.set(n,refine);
															let value = runtime_natives_GroupedExpr.GNoEval(w.get());
															dynamicRefines.set(n,value);
														}
													}
												} else {
													throw haxe_Exception.thrown("Invalid refinement!");
												}
											}
										}
										return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
									}
								}
							}
						} else {
							let v = _g;
							let _g1 = runtime_natives_Do.checkForOp(values);
							let _hx_tmp;
							if(_g1 == null) {
								return [runtime_natives_GroupedExpr.GValue(v),values];
							} else {
								_hx_tmp = _g1;
								let o = _hx_tmp;
								values.offset++;
								let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
								return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
							}
						}
					}
				} else if(_hx_tmp1 == null) {
					_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
					let _hx_tmp_a = _hx_tmp != null;
					let _hx_tmp_b = _hx_tmp;
					let _g1 = _hx_tmp_b;
					if(_hx_tmp_a == true) {
						let _hx_tmp;
						if(_g1 == null) {
							_hx_tmp = _g1;
							let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
							if(_hx_tmp1 == null) {
								let v = _g;
								let _g1 = runtime_natives_Do.checkForOp(values);
								let _hx_tmp;
								if(_g1 == null) {
									return [runtime_natives_GroupedExpr.GValue(v),values];
								} else {
									_hx_tmp = _g1;
									let o = _hx_tmp;
									values.offset++;
									let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
									return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
								}
							} else {
								let fn = _hx_tmp1[0];
								let rest = _hx_tmp1[1];
								let args = runtime_natives_Do.groupParams(values,fn.get_params());
								if(rest.values.length - rest.offset == 0) {
									return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
								} else {
									let refines = new Map();
									let dynamicRefines = new Map();
									values = args[1];
									let _g = 0;
									while(_g < rest.values.length - rest.offset) {
										let value = rest.values[rest.offset + _g];
										++_g;
										let _hx_tmp;
										if(((value) instanceof types_Word) == true) {
											let __anon0__w = value;
											let w = __anon0__w;
											let _g = fn.findRefine(w);
											if(_g == null) {
												throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
											} else {
												let _g1 = _g.name;
												let _g2 = _g.doc;
												let _g3 = _g.params;
												let n = _g1;
												if(refines.has(n)) {
													throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
												} else {
													let n = _g1;
													let params2 = _g3;
													let refine;
													/*;
													refine = */ //;
													[refine, values] = runtime_natives_Do.groupParams(values,params2);
													refines.set(n,refine);
												}
											}
										} else {
											_hx_tmp = ((value) instanceof types_GetWord);
											if(_hx_tmp == true) {
												let __anon0__w = value;
												let w = __anon0__w;
												let _g = fn.findRefine(w);
												if(_g == null) {
													throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
												} else {
													let _g1 = _g.name;
													let _g2 = _g.doc;
													let _g3 = _g.params;
													let n = _g1;
													if(refines.has(n)) {
														throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
													} else {
														let n = _g1;
														let params2 = _g3;
														let refine;
														/*;
														refine = */ //;
														[refine, values] = runtime_natives_Do.groupParams(values,params2);
														refines.set(n,refine);
														let value = runtime_natives_GroupedExpr.GNoEval(w.get());
														dynamicRefines.set(n,value);
													}
												}
											} else {
												throw haxe_Exception.thrown("Invalid refinement!");
											}
										}
									}
									return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
								}
							}
						} else {
							_hx_tmp = _g1;
							let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
							if(_hx_tmp1 == null) {
								let v = _g;
								let _g1 = runtime_natives_Do.checkForOp(values);
								let _hx_tmp;
								if(_g1 == null) {
									return [runtime_natives_GroupedExpr.GValue(v),values];
								} else {
									_hx_tmp = _g1;
									let o = _hx_tmp;
									values.offset++;
									let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
									return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
								}
							} else {
								let fn = _hx_tmp1[0];
								let rest = _hx_tmp1[1];
								let args = runtime_natives_Do.groupParams(values,fn.get_params());
								if(rest.values.length - rest.offset == 0) {
									return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
								} else {
									let refines = new Map();
									let dynamicRefines = new Map();
									values = args[1];
									let _g = 0;
									while(_g < rest.values.length - rest.offset) {
										let value = rest.values[rest.offset + _g];
										++_g;
										let _hx_tmp;
										if(((value) instanceof types_Word) == true) {
											let __anon0__w = value;
											let w = __anon0__w;
											let _g = fn.findRefine(w);
											if(_g == null) {
												throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
											} else {
												let _g1 = _g.name;
												let _g2 = _g.doc;
												let _g3 = _g.params;
												let n = _g1;
												if(refines.has(n)) {
													throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
												} else {
													let n = _g1;
													let params2 = _g3;
													let refine;
													/*;
													refine = */ //;
													[refine, values] = runtime_natives_Do.groupParams(values,params2);
													refines.set(n,refine);
												}
											}
										} else {
											_hx_tmp = ((value) instanceof types_GetWord);
											if(_hx_tmp == true) {
												let __anon0__w = value;
												let w = __anon0__w;
												let _g = fn.findRefine(w);
												if(_g == null) {
													throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
												} else {
													let _g1 = _g.name;
													let _g2 = _g.doc;
													let _g3 = _g.params;
													let n = _g1;
													if(refines.has(n)) {
														throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
													} else {
														let n = _g1;
														let params2 = _g3;
														let refine;
														/*;
														refine = */ //;
														[refine, values] = runtime_natives_Do.groupParams(values,params2);
														refines.set(n,refine);
														let value = runtime_natives_GroupedExpr.GNoEval(w.get());
														dynamicRefines.set(n,value);
													}
												}
											} else {
												throw haxe_Exception.thrown("Invalid refinement!");
											}
										}
									}
									return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
								}
							}
						}
					} else {
						let v = _g;
						let _g1 = runtime_natives_Do.checkForOp(values);
						let _hx_tmp;
						if(_g1 == null) {
							return [runtime_natives_GroupedExpr.GValue(v),values];
						} else {
							_hx_tmp = _g1;
							let o = _hx_tmp;
							values.offset++;
							let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
							return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
						}
					}
				} else {
					_hx_tmp = ((_g) instanceof types_Path) ? _g : null;
					let _hx_tmp_a = _hx_tmp != null;
					let _hx_tmp_b = _hx_tmp;
					let _g1 = _hx_tmp_b;
					if(_hx_tmp_a == true) {
						let _hx_tmp;
						if(_g1 == null) {
							_hx_tmp = _g1;
							let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
							if(_hx_tmp1 == null) {
								let v = _g;
								let _g1 = runtime_natives_Do.checkForOp(values);
								let _hx_tmp;
								if(_g1 == null) {
									return [runtime_natives_GroupedExpr.GValue(v),values];
								} else {
									_hx_tmp = _g1;
									let o = _hx_tmp;
									values.offset++;
									let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
									return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
								}
							} else {
								let fn = _hx_tmp1[0];
								let rest = _hx_tmp1[1];
								let args = runtime_natives_Do.groupParams(values,fn.get_params());
								if(rest.values.length - rest.offset == 0) {
									return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
								} else {
									let refines = new Map();
									let dynamicRefines = new Map();
									values = args[1];
									let _g = 0;
									while(_g < rest.values.length - rest.offset) {
										let value = rest.values[rest.offset + _g];
										++_g;
										let _hx_tmp;
										if(((value) instanceof types_Word) == true) {
											let __anon0__w = value;
											let w = __anon0__w;
											let _g = fn.findRefine(w);
											if(_g == null) {
												throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
											} else {
												let _g1 = _g.name;
												let _g2 = _g.doc;
												let _g3 = _g.params;
												let n = _g1;
												if(refines.has(n)) {
													throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
												} else {
													let n = _g1;
													let params2 = _g3;
													let refine;
													/*;
													refine = */ //;
													[refine, values] = runtime_natives_Do.groupParams(values,params2);
													refines.set(n,refine);
												}
											}
										} else {
											_hx_tmp = ((value) instanceof types_GetWord);
											if(_hx_tmp == true) {
												let __anon0__w = value;
												let w = __anon0__w;
												let _g = fn.findRefine(w);
												if(_g == null) {
													throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
												} else {
													let _g1 = _g.name;
													let _g2 = _g.doc;
													let _g3 = _g.params;
													let n = _g1;
													if(refines.has(n)) {
														throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
													} else {
														let n = _g1;
														let params2 = _g3;
														let refine;
														/*;
														refine = */ //;
														[refine, values] = runtime_natives_Do.groupParams(values,params2);
														refines.set(n,refine);
														let value = runtime_natives_GroupedExpr.GNoEval(w.get());
														dynamicRefines.set(n,value);
													}
												}
											} else {
												throw haxe_Exception.thrown("Invalid refinement!");
											}
										}
									}
									return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
								}
							}
						} else {
							_hx_tmp = _g1;
							let _hx_tmp1 = runtime_natives_Do.doesBecomeFunction(_hx_tmp);
							if(_hx_tmp1 == null) {
								let v = _g;
								let _g1 = runtime_natives_Do.checkForOp(values);
								let _hx_tmp;
								if(_g1 == null) {
									return [runtime_natives_GroupedExpr.GValue(v),values];
								} else {
									_hx_tmp = _g1;
									let o = _hx_tmp;
									values.offset++;
									let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
									return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
								}
							} else {
								let fn = _hx_tmp1[0];
								let rest = _hx_tmp1[1];
								let args = runtime_natives_Do.groupParams(values,fn.get_params());
								if(rest.values.length - rest.offset == 0) {
									return [runtime_natives_GroupedExpr.GCall(fn,args[0],new Map([])),args[1]];
								} else {
									let refines = new Map();
									let dynamicRefines = new Map();
									values = args[1];
									let _g = 0;
									while(_g < rest.values.length - rest.offset) {
										let value = rest.values[rest.offset + _g];
										++_g;
										let _hx_tmp;
										if(((value) instanceof types_Word) == true) {
											let __anon0__w = value;
											let w = __anon0__w;
											let _g = fn.findRefine(w);
											if(_g == null) {
												throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
											} else {
												let _g1 = _g.name;
												let _g2 = _g.doc;
												let _g3 = _g.params;
												let n = _g1;
												if(refines.has(n)) {
													throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
												} else {
													let n = _g1;
													let params2 = _g3;
													let refine;
													/*;
													refine = */ //;
													[refine, values] = runtime_natives_Do.groupParams(values,params2);
													refines.set(n,refine);
												}
											}
										} else {
											_hx_tmp = ((value) instanceof types_GetWord);
											if(_hx_tmp == true) {
												let __anon0__w = value;
												let w = __anon0__w;
												let _g = fn.findRefine(w);
												if(_g == null) {
													throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
												} else {
													let _g1 = _g.name;
													let _g2 = _g.doc;
													let _g3 = _g.params;
													let n = _g1;
													if(refines.has(n)) {
														throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
													} else {
														let n = _g1;
														let params2 = _g3;
														let refine;
														/*;
														refine = */ //;
														[refine, values] = runtime_natives_Do.groupParams(values,params2);
														refines.set(n,refine);
														let value = runtime_natives_GroupedExpr.GNoEval(w.get());
														dynamicRefines.set(n,value);
													}
												}
											} else {
												throw haxe_Exception.thrown("Invalid refinement!");
											}
										}
									}
									return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines),values];
								}
							}
						}
					} else {
						let v = _g;
						let _g1 = runtime_natives_Do.checkForOp(values);
						let _hx_tmp;
						if(_g1 == null) {
							return [runtime_natives_GroupedExpr.GValue(v),values];
						} else {
							_hx_tmp = _g1;
							let o = _hx_tmp;
							values.offset++;
							let self = runtime_natives_Do.groupNextExprForParam(values,o.get_params()[1]);
							return [runtime_natives_GroupedExpr.GOp(runtime_natives_GroupedExpr.GValue(v),o,self[0]),self[1]];
						}
					}
				}
			}
		}
	}
	static groupFnApply(fn,path,values,all,safer) {
		let args = runtime_natives_Do.groupParams(values,fn.get_params());
		if(all) {
			if(path != null) {
				throw haxe_Exception.thrown("bad");
			}
			values = args[1];
			let refines = new Map();
			let dynamicRefines = new Map();
			let _g = 0;
			let _g1 = fn.get_refines();
			while(_g < _g1.length) {
				let refine = _g1[_g];
				++_g;
				let refineFlag;
				/*;
				refineFlag = */ //;
				[refineFlag, values] = runtime_natives_Do.groupNextExpr(values);
				let refineArgs;
				/*;
				refineArgs = */ //;
				[refineArgs, values] = runtime_natives_Do.groupParams(values,refine.params);
				refines.set(refine.name,refineArgs);
				dynamicRefines.set(refine.name,refineFlag);
			}
			return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines,safer),values];
		} else {
			let refines = new Map();
			let dynamicRefines = new Map();
			values = args[1];
			if(path == null) {
				while(values.values.length - values.offset > 0) {
					values.offset++;
					let _g = values.values[values.offset - 1];
					if(((_g) instanceof types_Refinement) == true) {
						let __anon0__r = _g;
						let r = __anon0__r;
						let refine;
						let tmp = fn.findRefine(r);
						if(tmp != null) {
							refine = tmp;
						} else {
							throw haxe_Exception.thrown("bad");
						}
						let flag;
						/*;
						flag = */ //;
						[flag, values] = runtime_natives_Do.groupNextExpr(values);
						let refineArgs;
						/*;
						refineArgs = */ //;
						[refineArgs, values] = runtime_natives_Do.groupParams(values,refine.params);
						refines.set(r.symbol.name,refineArgs);
						dynamicRefines.set(r.symbol.name,flag);
					} else {
						throw haxe_Exception.thrown("bad");
					}
				}
			} else {
				let _gthis = path;
				let _this = path.values.slice(path.index);
				let result = new Array(_this.length);
				let _g = 0;
				let _g1 = _this.length;
				while(_g < _g1) {
					let i = _g++;
					result[i] = _gthis.wrap(_this[i]);
				}
				let _g_current = 0;
				let _g_array = result;
				while(_g_current < _g_array.length) {
					let value = _g_array[_g_current++];
					let _hx_tmp;
					if(((value) instanceof types_Word) == true) {
						let __anon0__w = value;
						let w = __anon0__w;
						let _g = fn.findRefine(w);
						if(_g == null) {
							throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
						} else {
							let _g1 = _g.name;
							let _g2 = _g.doc;
							let _g3 = _g.params;
							let n = _g1;
							if(refines.has(n)) {
								throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
							} else {
								let n = _g1;
								let params2 = _g3;
								let refine;
								/*;
								refine = */ //;
								[refine, values] = runtime_natives_Do.groupParams(values,params2);
								refines.set(n,refine);
							}
						}
					} else {
						_hx_tmp = ((value) instanceof types_GetWord);
						if(_hx_tmp == true) {
							let __anon0__w = value;
							let w = __anon0__w;
							let _g = fn.findRefine(w);
							if(_g == null) {
								throw haxe_Exception.thrown("Unknown refinement `/" + w.symbol.name + "`!");
							} else {
								let _g1 = _g.name;
								let _g2 = _g.doc;
								let _g3 = _g.params;
								let n = _g1;
								if(refines.has(n)) {
									throw haxe_Exception.thrown("Duplicate refinement `/" + w.symbol.name + "`!");
								} else {
									let n = _g1;
									let params2 = _g3;
									let wValue;
									/*;
									wValue = */ //;
									[wValue, values] = runtime_natives_Do.groupNextExpr(values);
									let refine;
									/*;
									refine = */ //;
									[refine, values] = runtime_natives_Do.groupParams(values,params2);
									refines.set(n,refine);
									dynamicRefines.set(n,wValue);
								}
							}
						} else {
							throw haxe_Exception.thrown("Invalid refinement!");
						}
					}
				}
			}
			return [runtime_natives_GroupedExpr.GCall(fn,args[0],refines,dynamicRefines,safer),values];
		}
	}
	static groupNextExprForParam(values,param) {
		switch(param.quoting[1]) {
		case 0:
			return runtime_natives_Do.groupNextExpr(values);
		case 1:
			if(values.offset >= values.values.length) {
				return [runtime_natives_GroupedExpr.GUnset,values];
			} else {
				values.offset++;
				let value = values.values[values.offset - 1];
				let value1;
				if(value != null) {
					value1 = value;
				} else {
					throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
				}
				return [runtime_natives_GroupedExpr.GNoEval(value1),values];
			}
			break;
		case 2:
			let value;
			values.offset++;
			let value1 = values.values[values.offset - 1];
			let _g;
			if(value1 != null) {
				_g = value1;
			} else {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			let _hx_tmp;
			let _hx_tmp1;
			if(((_g) instanceof types_Paren) == true) {
				let __anon0__v = _g;
				let v = __anon0__v;
				value = runtime_natives_GroupedExpr.GValue(v);
			} else {
				_hx_tmp1 = ((_g) instanceof types_GetWord);
				if(_hx_tmp1 == true) {
					let __anon0__v = _g;
					let v = __anon0__v;
					value = runtime_natives_GroupedExpr.GValue(v);
				} else {
					_hx_tmp = ((_g) instanceof types_GetPath);
					if(_hx_tmp == true) {
						let __anon0__v = _g;
						let v = __anon0__v;
						value = runtime_natives_GroupedExpr.GValue(v);
					} else {
						let v = _g;
						value = runtime_natives_GroupedExpr.GNoEval(v);
					}
				}
			}
			return [value,values];
		}
	}
	static evalPath(path,setValue,isGet,isCase) {
		let pItem_values = path.values;
		let pItem_offset = path.index;
		if(pItem_offset >= pItem_values.length) {
			throw haxe_Exception.thrown("empty path");
		}
		let item_values = pItem_values;
		let item_offset = pItem_offset + 1;
		let idx = 0;
		let w;
		let _g = pItem_values[pItem_offset];
		if(((_g) instanceof types_Word) == true) {
			let __anon0__v = _g;
			let v = __anon0__v;
			w = v;
		} else {
			throw haxe_Exception.thrown("word first");
		}
		let parent = w.get(true);
		let gparent = null;
		if(parent == types_Unset.UNSET) {
			throw haxe_Exception.thrown("unset path");
		}
		if(w.context != types_base_Context.GLOBAL) {
			let _g = w.context.value;
			if(((_g) instanceof types_Function) == true) {
				let __anon0__f = _g;
				let f = __anon0__f;
				gparent = f;
			}
		}
		let prevValue = null;
		while(item_offset < item_values.length) {
			let value;
			let _g = item_values[item_offset];
			let _hx_tmp;
			if(((_g) instanceof types_GetWord) == true) {
				let __anon0__w = _g;
				let w = __anon0__w;
				value = w.get();
			} else {
				_hx_tmp = ((_g) instanceof types_Paren);
				if(_hx_tmp == true) {
					let __anon0__p = _g;
					let p = __anon0__p;
					value = runtime_natives_Do.evalValues(new util__$Series__$Series(p.values,p.index));
				} else {
					let v = _g;
					value = v;
				}
			}
			if(value == types_Unset.UNSET) {
				throw haxe_Exception.thrown("invalid path");
			}
			let prev = parent;
			let isTail = item_offset == item_values.length - 1;
			let arg = isTail ? setValue : null;
			parent = runtime_actions_EvalPath.call(parent,value,arg,path,gparent,pItem_values[pItem_offset],idx,isCase,isGet,isTail);
			if(setValue != null && item_offset + 1 == item_values.length - 1) {
				prevValue = value;
			}
			if(setValue != null && isTail && parent != arg) {
				if(prevValue == null) {
					w.set(parent);
				} else {
					runtime_actions_EvalPath.call(gparent,prevValue,parent,path,gparent,pItem_values[pItem_offset + (-1)],idx - 1,isCase,isGet,isTail);
				}
				parent = arg;
				break;
			}
			pItem_offset = item_offset;
			pItem_values = item_values;
			gparent = prev;
			++item_offset;
			++idx;
		}
		return parent;
	}
	static evalGroupedExpr(expr) {
		switch(expr[1]) {
		case 0:
			return runtime_natives_Do.evalValue(expr[2]);
		case 1:
			return expr[2];
		case 2:
			let _g = expr[2];
			let _g1 = expr[3];
			let _hx_tmp;
			if(_g1[1] == 6) {
				throw haxe_Exception.thrown("" + _g.symbol.name + " needs a value!");
			} else {
				_hx_tmp = runtime_natives_Do.evalGroupedExpr(_g1);
				if(_hx_tmp == types_Unset.UNSET) {
					throw haxe_Exception.thrown("" + _g.symbol.name + " needs a value!");
				} else {
					_g.set(_hx_tmp);
					return _hx_tmp;
				}
			}
			break;
		case 3:
			return runtime_natives_Do.evalPath(expr[2],runtime_natives_Do.evalGroupedExpr(expr[3]),false,false);
		case 4:
			return runtime_Eval.callAnyFunction(expr[3],[runtime_natives_Do.evalGroupedExpr(expr[2]),runtime_natives_Do.evalGroupedExpr(expr[4])],null);
		case 5:
			let _g2 = expr[2];
			let _g3 = expr[3];
			let _g4 = expr[4];
			let _g5 = expr[5];
			let _g6 = expr[6];
			let result = new Array(_g3.length);
			let _g7 = 0;
			let _g8 = _g3.length;
			while(_g7 < _g8) {
				let i = _g7++;
				result[i] = runtime_natives_Do.evalGroupedExpr(_g3[i]);
			}
			let res = new Map();
			let jsIterator = _g4.entries();
			let _g_lastStep = jsIterator.next();
			while(!_g_lastStep.done) {
				let v = _g_lastStep.value;
				_g_lastStep = jsIterator.next();
				let k = v[0];
				let v1 = v[1];
				let rx = /-([a-z])/g;
				let name = k.replace(rx,function(_,l) {
					return l.toUpperCase();
				});
				if(_g5?.has(name)) {
					if(!runtime_natives_Do.evalGroupedExpr(_g5.get(name)).isTruthy()) {
						if(!_g6) {
							v1.forEach(function(a) {
								runtime_natives_Do.evalGroupedExpr(a);
							});
						}
						continue;
					}
				}
				let result = new Array(v1.length);
				let _g = 0;
				let _g1 = v1.length;
				while(_g < _g1) {
					let i = _g++;
					result[i] = runtime_natives_Do.evalGroupedExpr(v1[i]);
				}
				res.set(name,result);
			}
			return runtime_Eval.callAnyFunction(_g2,result,res);
		case 6:
			throw haxe_Exception.thrown("Unexpected unset!");
		}
	}
	static evalValue(value) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		let _hx_tmp4;
		let _hx_tmp5;
		if(((value) instanceof types_Paren) == true) {
			let __anon0__p = value;
			let p = __anon0__p;
			return runtime_natives_Do.evalValues(new util__$Series__$Series(p.values,p.index));
		} else {
			_hx_tmp5 = ((value) instanceof types_Path);
			if(_hx_tmp5 == true) {
				let __anon0__p = value;
				let p = __anon0__p;
				return runtime_natives_Do.evalPath(p,null,false,false);
			} else {
				_hx_tmp4 = ((value) instanceof types_GetPath);
				if(_hx_tmp4 == true) {
					let __anon0__p = value;
					let p = __anon0__p;
					return runtime_natives_Do.evalPath(p,null,true,false);
				} else {
					_hx_tmp3 = ((value) instanceof types_LitPath);
					if(_hx_tmp3 == true) {
						let __anon0__l = value;
						let l = __anon0__l;
						return new types_Path(l.values,l.index);
					} else {
						_hx_tmp2 = ((value) instanceof types_Word);
						if(_hx_tmp2 == true) {
							let __anon0__w = value;
							let w = __anon0__w;
							return w.get();
						} else {
							_hx_tmp1 = ((value) instanceof types_GetWord);
							if(_hx_tmp1 == true) {
								let __anon0__g = value;
								let g = __anon0__g;
								return g.get(true);
							} else {
								_hx_tmp = ((value) instanceof types_LitWord);
								if(_hx_tmp == true) {
									let __anon0__l = value;
									let l = __anon0__l;
									return new types_Word(l.symbol);
								} else {
									return value;
								}
							}
						}
					}
				}
			}
		}
	}
	static evalValues(values) {
		let result = types_Unset.UNSET;
		while(values.offset < values.values.length) {
			let expr;
			/*;
			expr = */ //;
			[expr, values] = runtime_natives_Do.groupNextExpr(values);
			result = runtime_natives_Do.evalGroupedExpr(expr);
		}
		return result;
	}
	static doNextValue(values) {
		if(values.values.length - values.offset == 0) {
			return [types_Unset.UNSET,values];
		} else {
			let self = runtime_natives_Do.groupNextExpr(values);
			return [runtime_natives_Do.evalGroupedExpr(self[0]),self[1]];
		}
	}
	static call(value,options) {
		let _g = options.args;
		let _g1 = options.next;
		if(options.expand == true) {
			throw haxe_Exception.thrown("NYI");
		} else if(_g != null == true) {
			throw haxe_Exception.thrown("NYI");
		} else if(_g1 == null) {
			let _hx_tmp;
			let _hx_tmp1;
			let _hx_tmp2;
			let _hx_tmp3;
			if(((value) instanceof types_Block) == true) {
				let __anon0__body = value;
				let body = __anon0__body;
				return runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index));
			} else {
				_hx_tmp3 = ((value) instanceof types_Paren);
				if(_hx_tmp3 == true) {
					let __anon0__body = value;
					let body = __anon0__body;
					return runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index));
				} else {
					_hx_tmp2 = ((value) instanceof types_String);
					if(_hx_tmp2 == true) {
						let __anon0__s = value;
						let s = __anon0__s;
						let series = runtime_natives_Transcode.call(s,runtime_natives_Transcode.defaultOptions);
						return runtime_natives_Do.evalValues(new util__$Series__$Series(series.values,series.index));
					} else {
						_hx_tmp1 = ((value) instanceof types_File);
						if(_hx_tmp1 == true) {
							let __anon0__file = value;
							let file = __anon0__file;
							if(Util.IS_NODE) {
								let f = file.toJs();
								if(f.startsWith("/c/") || f.startsWith("/C/")) {
									f = "C:/" + f.substr(3);
								}
								let series = runtime_natives_Transcode._call(Util.FS.readFileSync(f).toString());
								return runtime_natives_Do.evalValues(new util__$Series__$Series(series.values,series.index));
							} else {
								throw haxe_Exception.thrown("Not available on web!");
							}
						} else {
							_hx_tmp = ((value) instanceof types_Url);
							if(_hx_tmp == true) {
								let __anon0__url = value;
								let url = __anon0__url;
								let series = runtime_natives_Transcode._call(Util.readUrl(url.toJs()));
								return runtime_natives_Do.evalValues(new util__$Series__$Series(series.values,series.index));
							} else {
								return runtime_natives_Do.evalValue(value);
							}
						}
					}
				}
			}
		} else {
			let word = _g1.position;
			let _hx_tmp;
			let _hx_tmp1;
			let _hx_tmp2;
			let _hx_tmp3;
			if(((value) instanceof types_Block) == true) {
				let __anon0__b = value;
				let b = __anon0__b;
				/*;
				let v = ;
				let rest = ;
				*/ //;
				let [v, rest] = runtime_natives_Do.doNextValue(new util__$Series__$Series(b.values,b.index));
				word.set(b.fastSkipHead(rest.offset));
				return v;
			} else {
				_hx_tmp3 = ((value) instanceof types_Paren);
				if(_hx_tmp3 == true) {
					let __anon0__b = value;
					let b = __anon0__b;
					/*;
					let v = ;
					let rest = ;
					*/ //;
					let [v, rest] = runtime_natives_Do.doNextValue(new util__$Series__$Series(b.values,b.index));
					word.set(b.fastSkipHead(rest.offset));
					return v;
				} else {
					_hx_tmp2 = ((value) instanceof types_String);
					if(_hx_tmp2 == true) {
						let __anon0__s = value;
						let s = __anon0__s;
						let values = runtime_natives_Transcode.call(s,runtime_natives_Transcode.defaultOptions);
						/*;
						let v = ;
						let rest = ;
						*/ //;
						let [v, rest] = runtime_natives_Do.doNextValue(new util__$Series__$Series(values.values,values.index));
						word.set(values.fastSkipHead(rest.offset));
						return v;
					} else {
						_hx_tmp1 = ((value) instanceof types_File);
						if(_hx_tmp1 == true) {
							throw haxe_Exception.thrown("NYI");
						} else {
							_hx_tmp = ((value) instanceof types_Url);
							if(_hx_tmp == true) {
								throw haxe_Exception.thrown("NYI");
							} else {
								return runtime_natives_Do.evalValue(value);
							}
						}
					}
				}
			}
		}
	}
}
runtime_natives_Do.__name__ = true;
class types_Unset extends Value {
	constructor() {
		super();
	}
	isUnset() {
		return true;
	}
	get_TYPE_KIND() {
		return 1;
	}
}
types_Unset.__name__ = true;
types_Unset.__super__ = Value;
Object.assign(types_Unset.prototype, {
	__class__: types_Unset
});
class types_base__$BlockLike extends types_base__$SeriesOf {
	constructor(values,index) {
		super(values,index);
	}
	wrap(value) {
		return value;
	}
	unwrap(value) {
		return value;
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_base__$BlockLike);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_base__$BlockLike);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_base__$BlockLike);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_base__$BlockLike);
	}
	head() {
		return js_Boot.__cast(super.head() , types_base__$BlockLike);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_base__$BlockLike);
	}
}
types_base__$BlockLike.__name__ = true;
types_base__$BlockLike.__super__ = types_base__$SeriesOf;
Object.assign(types_base__$BlockLike.prototype, {
	__class__: types_base__$BlockLike
});
class types_base__$Path extends types_base__$BlockLike {
	constructor(values,index) {
		super(values,index);
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_base__$Path);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_base__$Path);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_base__$Path);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_base__$Path);
	}
	head() {
		return js_Boot.__cast(super.head() , types_base__$Path);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_base__$Path);
	}
}
types_base__$Path.__name__ = true;
types_base__$Path.__super__ = types_base__$BlockLike;
Object.assign(types_base__$Path.prototype, {
	__class__: types_base__$Path
});
class types_Path extends types_base__$Path {
	constructor(values,index) {
		super(values,index);
	}
	clone(values,index) {
		return new types_Path(values,index);
	}
	get_TYPE_KIND() {
		return 22;
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_Path);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_Path);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_Path);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_Path);
	}
	head() {
		return js_Boot.__cast(super.head() , types_Path);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_Path);
	}
}
types_Path.__name__ = true;
types_Path.__super__ = types_base__$Path;
Object.assign(types_Path.prototype, {
	__class__: types_Path
});
class types_base_IFunction {
}
types_base_IFunction.__name__ = true;
types_base_IFunction.__isInterface__ = true;
types_base_IFunction.__interfaces__ = [types_base_IValue];
Object.assign(types_base_IFunction.prototype, {
	__class__: types_base_IFunction
});
class types_Op extends Value {
	constructor(fn) {
		super();
		if(fn.get_arity() != 2) {
			throw haxe_Exception.thrown("op! must take 2 paramuments");
		} else {
			this.fn = fn;
		}
	}
	get_origSpec() {
		return this.fn.get_origSpec();
	}
	get_params() {
		return this.fn.get_params();
	}
	get_refines() {
		return [];
	}
	findRefine(w) {
		return this.get_refines().find(function(ref) {
			return w.symbol.equalsString(ref.name);
		});
	}
	get_TYPE_KIND() {
		return 20;
	}
}
types_Op.__name__ = true;
types_Op.__interfaces__ = [types_base_IFunction];
types_Op.__super__ = Value;
Object.assign(types_Op.prototype, {
	__class__: types_Op
});
var types_base_QuotingKind = { __ename__:true,__constructs__:["QVal","QGet","QLit"] };
types_base_QuotingKind.QVal = ["QVal",0];
types_base_QuotingKind.QVal.toString = $estr;
types_base_QuotingKind.QVal.__enum__ = types_base_QuotingKind;
types_base_QuotingKind.QGet = ["QGet",1];
types_base_QuotingKind.QGet.toString = $estr;
types_base_QuotingKind.QGet.__enum__ = types_base_QuotingKind;
types_base_QuotingKind.QLit = ["QLit",2];
types_base_QuotingKind.QLit.toString = $estr;
types_base_QuotingKind.QLit.__enum__ = types_base_QuotingKind;
var runtime_natives_GroupedExpr = { __ename__:true,__constructs__:["GValue","GNoEval","GSetWord","GSetPath","GOp","GCall","GUnset"] };
runtime_natives_GroupedExpr.GValue = function(v) { var $x = ["GValue",0,v]; $x.__enum__ = runtime_natives_GroupedExpr; $x.toString = $estr; return $x; }
runtime_natives_GroupedExpr.GNoEval = function(v) { var $x = ["GNoEval",1,v]; $x.__enum__ = runtime_natives_GroupedExpr; $x.toString = $estr; return $x; }
runtime_natives_GroupedExpr.GSetWord = function(s,e) { var $x = ["GSetWord",2,s,e]; $x.__enum__ = runtime_natives_GroupedExpr; $x.toString = $estr; return $x; }
runtime_natives_GroupedExpr.GSetPath = function(s,e) { var $x = ["GSetPath",3,s,e]; $x.__enum__ = runtime_natives_GroupedExpr; $x.toString = $estr; return $x; }
runtime_natives_GroupedExpr.GOp = function(l,op,r) { var $x = ["GOp",4,l,op,r]; $x.__enum__ = runtime_natives_GroupedExpr; $x.toString = $estr; return $x; }
runtime_natives_GroupedExpr.GCall = function(f,args,refines,dynamicRefines,safer) { var $x = ["GCall",5,f,args,refines,dynamicRefines,safer]; $x.__enum__ = runtime_natives_GroupedExpr; $x.toString = $estr; return $x; }
runtime_natives_GroupedExpr.GUnset = ["GUnset",6];
runtime_natives_GroupedExpr.GUnset.toString = $estr;
runtime_natives_GroupedExpr.GUnset.__enum__ = runtime_natives_GroupedExpr;
class types_GetPath extends types_base__$Path {
	constructor(values,index) {
		super(values,index);
	}
	clone(values,index) {
		return new types_GetPath(values,index);
	}
	get_TYPE_KIND() {
		return 25;
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_GetPath);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_GetPath);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_GetPath);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_GetPath);
	}
	head() {
		return js_Boot.__cast(super.head() , types_GetPath);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_GetPath);
	}
}
types_GetPath.__name__ = true;
types_GetPath.__super__ = types_base__$Path;
Object.assign(types_GetPath.prototype, {
	__class__: types_GetPath
});
class types_base__$Block extends types_base__$BlockLike {
	constructor(values,index,newlines) {
		super(values,index);
		this.newlines = newlines;
	}
	clone(values,index) {
		return this.cloneBlock(values,index,this.newlines);
	}
	at(index) {
		return this.cloneBlock(this.values,Math.max(0, Math.min((this.index + (index <= 0 ? index : index - 1)), this.values.length)),this.newlines);
	}
	skip(index) {
		return this.cloneBlock(this.values,Math.max(0, Math.min((this.index + index), this.values.length)),this.newlines);
	}
	fastSkipHead(index) {
		return this.cloneBlock(this.values,index,this.newlines);
	}
	copy() {
		let _gthis = this;
		let tmp = this.values.slice(this.index);
		let tmp1 = this.newlines;
		return this.cloneBlock(tmp,0,tmp1 != null ? util__$Set__$Set.map(util__$Set__$Set.filter(tmp1,function(nl) {
			return nl >= _gthis.index;
		}),function(nl) {
			return nl - _gthis.index;
		}) : null);
	}
	head() {
		return this.cloneBlock(this.values,0,this.newlines);
	}
	tail() {
		return this.cloneBlock(this.values,this.values.length,this.newlines);
	}
	addNewline(index) {
		let _g = this.newlines;
		if(_g == null) {
			this.newlines = new Set([index]);
		} else {
			_g.add(index);
		}
	}
	removeNewline(index) {
		let tmp = this.newlines;
		if(tmp != null) {
			tmp.delete(index);
		}
	}
	hasNewline(index) {
		let tmp = this.newlines;
		let tmp1 = tmp != null ? tmp.has(index) : null;
		if(tmp1 != null) {
			return tmp1;
		} else {
			return false;
		}
	}
}
types_base__$Block.__name__ = true;
types_base__$Block.__super__ = types_base__$BlockLike;
Object.assign(types_base__$Block.prototype, {
	__class__: types_base__$Block
});
class types_Paren extends types_base__$Block {
	constructor(values,index,newlines) {
		super(values,index,newlines);
	}
	cloneBlock(values,index,newlines) {
		return new types_Paren(values,index,newlines);
	}
	get_TYPE_KIND() {
		return 5;
	}
	clone(values,index) {
		return js_Boot.__cast(super.clone(values,index) , types_Paren);
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_Paren);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_Paren);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_Paren);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_Paren);
	}
	head() {
		return js_Boot.__cast(super.head() , types_Paren);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_Paren);
	}
}
types_Paren.__name__ = true;
types_Paren.__super__ = types_base__$Block;
Object.assign(types_Paren.prototype, {
	__class__: types_Paren
});
class types_SetPath extends types_base__$Path {
	constructor(values,index) {
		super(values,index);
	}
	clone(values,index) {
		return new types_SetPath(values,index);
	}
	get_TYPE_KIND() {
		return 24;
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_SetPath);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_SetPath);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_SetPath);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_SetPath);
	}
	head() {
		return js_Boot.__cast(super.head() , types_SetPath);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_SetPath);
	}
}
types_SetPath.__name__ = true;
types_SetPath.__super__ = types_base__$Path;
Object.assign(types_SetPath.prototype, {
	__class__: types_SetPath
});
class types_LitPath extends types_base__$Path {
	constructor(values,index) {
		super(values,index);
	}
	clone(values,index) {
		return new types_LitPath(values,index);
	}
	get_TYPE_KIND() {
		return 23;
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_LitPath);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_LitPath);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_LitPath);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_LitPath);
	}
	head() {
		return js_Boot.__cast(super.head() , types_LitPath);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_LitPath);
	}
}
types_LitPath.__name__ = true;
types_LitPath.__super__ = types_base__$Path;
Object.assign(types_LitPath.prototype, {
	__class__: types_LitPath
});
class types_base__$Function extends Value {
	constructor(origSpec,doc,params,refines,retSpec) {
		super();
		this.set_origSpec(origSpec);
		this.set_doc(doc);
		this.set_params(params);
		this.set_refines(refines);
		this.set_retSpec(retSpec);
	}
	get_origSpec() {
		return this._origSpec;
	}
	set_origSpec(v) {
		return this._origSpec = v;
	}
	get_doc() {
		return this._doc;
	}
	set_doc(v) {
		return this._doc = v;
	}
	get_params() {
		return this._params;
	}
	set_params(v) {
		return this._params = v;
	}
	get_refines() {
		return this._refines;
	}
	set_refines(v) {
		return this._refines = v;
	}
	get_retSpec() {
		return this._retSpec;
	}
	set_retSpec(v) {
		return this._retSpec = v;
	}
	get_arity() {
		return this._params.length;
	}
	findRefine(w) {
		return this.get_refines().find(function(ref) {
			return w.symbol.equalsString(ref.name);
		});
	}
}
types_base__$Function.__name__ = true;
types_base__$Function.__interfaces__ = [types_base_IFunction];
types_base__$Function.__super__ = Value;
Object.assign(types_base__$Function.prototype, {
	__class__: types_base__$Function
});
class types_Function extends types_base__$Function {
	constructor(ctx,origSpec,doc,params,refines,retSpec,body) {
		super(origSpec,doc,params,refines,retSpec);
		this.ctx = ctx != null ? ctx : new types_base_Context();
		this.ctx.value = this;
		let _g = 0;
		while(_g < params.length) this.ctx.add(params[_g++].name,types_None.NONE);
		let _g1 = 0;
		while(_g1 < refines.length) {
			let refine = refines[_g1];
			++_g1;
			this.ctx.add(refine.name,types_Logic.FALSE);
			let _g = 0;
			let _g2 = refine.params;
			while(_g < _g2.length) this.ctx.add(_g2[_g++].name,types_None.NONE);
		}
		this.body = body;
		if(ctx == null) {
			this.ctx.bind(this.body,false);
		}
	}
	get_TYPE_KIND() {
		return 21;
	}
}
types_Function.__name__ = true;
types_Function.__super__ = types_base__$Function;
Object.assign(types_Function.prototype, {
	__class__: types_Function
});
class types_Action extends types_base__$Function {
	constructor(origSpec,doc,params,refines,retSpec,fn) {
		super(origSpec,doc,params,refines,retSpec);
		this.fn = fn;
	}
	get_TYPE_KIND() {
		return 19;
	}
}
types_Action.__name__ = true;
types_Action.__super__ = types_base__$Function;
Object.assign(types_Action.prototype, {
	__class__: types_Action
});
class types_Native extends types_base__$Function {
	constructor(origSpec,doc,params,refines,retSpec,fn) {
		super(origSpec,doc,params,refines,retSpec);
		this.fn = fn;
	}
	get_TYPE_KIND() {
		return 18;
	}
}
types_Native.__name__ = true;
types_Native.__super__ = types_base__$Function;
Object.assign(types_Native.prototype, {
	__class__: types_Native
});
class types_Block extends types_base__$Block {
	constructor(values,index,newlines) {
		super(values,index,newlines);
	}
	cloneBlock(values,index,newlines) {
		return new types_Block(values,index,newlines);
	}
	get_TYPE_KIND() {
		return 4;
	}
	clone(values,index) {
		return js_Boot.__cast(super.clone(values,index) , types_Block);
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_Block);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_Block);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_Block);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_Block);
	}
	head() {
		return js_Boot.__cast(super.head() , types_Block);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_Block);
	}
}
types_Block.__name__ = true;
types_Block.__super__ = types_base__$Block;
Object.assign(types_Block.prototype, {
	__class__: types_Block
});
class types_base__$Number extends Value {
}
types_base__$Number.__name__ = true;
types_base__$Number.__super__ = Value;
Object.assign(types_base__$Number.prototype, {
	__class__: types_base__$Number
});
class types_Object extends Value {
	constructor(ctx,classID,dontCopy) {
		if(dontCopy == null) {
			dontCopy = false;
		}
		super();
		this.ctx = ctx == null ? new types_base_Context() : dontCopy ? ctx : new types_base_Context(ctx.symbols,ctx.values);
		this.ctx.value = this;
		this.classID = classID != null ? classID : ++types_Object.maxID;
	}
	getPath(access,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let _hx_tmp = ((access) instanceof types_Word) ? access : null;
		if(_hx_tmp == null) {
			return haxe_ds_Option.None;
		} else {
			let _g = _hx_tmp.get_TYPE_KIND();
			let _g1 = _hx_tmp.context;
			let _g2 = _hx_tmp.symbol;
			let _g3 = _hx_tmp.index;
			let _g4 = types_base_Symbol.INDEXES.get(_g2.name);
			let n = _g2.name;
			if(this.ctx.contains(n,ignoreCase)) {
				return haxe_ds_Option.Some(this.ctx.get(n,ignoreCase));
			} else {
				return haxe_ds_Option.None;
			}
		}
	}
	setPath(access,newValue,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let _hx_tmp = ((access) instanceof types_Word) ? access : null;
		if(_hx_tmp == null) {
			return false;
		} else {
			let _g = _hx_tmp.get_TYPE_KIND();
			let _g1 = _hx_tmp.context;
			let _g2 = _hx_tmp.symbol;
			let _g3 = _hx_tmp.index;
			let _g4 = types_base_Symbol.INDEXES.get(_g2.name);
			let n = _g2.name;
			if(this.ctx.contains(n,ignoreCase)) {
				this.ctx.set(n,newValue,ignoreCase);
				return true;
			} else {
				return false;
			}
		}
	}
	get_TYPE_KIND() {
		return 29;
	}
}
types_Object.__name__ = true;
types_Object.__interfaces__ = [types_base_ISetPath,types_base_IGetPath];
types_Object.__super__ = Value;
Object.assign(types_Object.prototype, {
	__class__: types_Object
});
class types_base__$Integer extends types_base__$Number {
	constructor(int) {
		super();
		this.int = int;
	}
	asFloat() {
		return this.int;
	}
	asInt() {
		return this.int;
	}
}
types_base__$Integer.__name__ = true;
types_base__$Integer.__super__ = types_base__$Number;
Object.assign(types_base__$Integer.prototype, {
	__class__: types_base__$Integer
});
class types_Integer extends types_base__$Integer {
	constructor(int) {
		super(int);
	}
	get_TYPE_KIND() {
		return 10;
	}
}
types_Integer.__name__ = true;
types_Integer.__super__ = types_base__$Integer;
Object.assign(types_Integer.prototype, {
	__class__: types_Integer
});
class types_Bitset extends Value {
	constructor(bytes,negated) {
		super();
		this.bytes = bytes;
		this.negated = negated;
	}
	setBit(bit) {
		this.bytes.b[bit >> 3] |= 128 >> (bit & 7);
	}
	clearBit(bit) {
		this.bytes.b[bit >> 3] &= ~(128 >> (bit & 7));
	}
	testBit(bit) {
		return (this.bytes.b[bit >> 3] & 128 >> (bit & 7)) != 0;
	}
	get_TYPE_KIND() {
		return 26;
	}
	static alloc(size,negated) {
		if(negated == null) {
			negated = false;
		}
		return new types_Bitset(new haxe_io_Bytes(new ArrayBuffer(size)),negated);
	}
	static fromIntegers(integers,negated) {
		if(negated == null) {
			negated = false;
		}
		let _g = [];
		let integer = $getIterator(integers);
		while(integer.hasNext()) _g.push(integer.next().int);
		return types_Bitset._fromOrds(new Set(_g),negated);
	}
	static _fromOrds(ords,negated) {
		let maxBit = ords.size == 0 ? 0 : Math.max(...ords);
		let out = types_Bitset.alloc((maxBit >> 3) + 1,negated);
		let jsIterator = ords.values();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			out.bytes.b[v >> 3] += 128 >> (v & 7);
		}
		return out;
	}
}
types_Bitset.__name__ = true;
types_Bitset.__super__ = Value;
Object.assign(types_Bitset.prototype, {
	__class__: types_Bitset
});
class types_base__$Float extends types_base__$Number {
	constructor(float) {
		super();
		this.float = float;
	}
	asFloat() {
		return this.float;
	}
	asInt() {
		return this.float | 0;
	}
}
types_base__$Float.__name__ = true;
types_base__$Float.__super__ = types_base__$Number;
Object.assign(types_base__$Float.prototype, {
	__class__: types_base__$Float
});
class types_Float extends types_base__$Float {
	constructor(float) {
		super(float);
	}
	make(value) {
		return new types_Float(value);
	}
	get_TYPE_KIND() {
		return 11;
	}
}
types_Float.__name__ = true;
types_Float.__super__ = types_base__$Float;
Object.assign(types_Float.prototype, {
	__class__: types_Float
});
class types_Logic extends Value {
	constructor(cond) {
		super();
		this.cond = cond;
	}
	isTruthy() {
		return this.cond;
	}
	get_TYPE_KIND() {
		return 3;
	}
}
types_Logic.__name__ = true;
types_Logic.__super__ = Value;
Object.assign(types_Logic.prototype, {
	__class__: types_Logic
});
class runtime_natives_All {
	static call(conds) {
		let result = types_None.NONE;
		let tokens = new util__$Series__$Series(conds.values,conds.index);
		while(tokens.offset < tokens.values.length) {
			let _g = runtime_natives_Do.doNextValue(tokens);
			let _g1 = _g[0];
			let _g2 = _g[1];
			if(_g1.isTruthy() == false) {
				return types_None.NONE;
			} else {
				result = _g1;
				tokens = _g2;
			}
		}
		return result;
	}
}
runtime_natives_All.__name__ = true;
class runtime_natives_Any {
	static call(conds) {
		let tokens = new util__$Series__$Series(conds.values,conds.index);
		while(tokens.offset < tokens.values.length) {
			let _g = runtime_natives_Do.doNextValue(tokens);
			let _g1 = _g[0];
			let _g2 = _g[1];
			if(_g1.isTruthy()) {
				return _g1;
			} else {
				tokens = _g2;
			}
		}
		return types_None.NONE;
	}
}
runtime_natives_Any.__name__ = true;
class types_Refinement extends types_base__$Word {
	constructor(symbol,context,index) {
		super(symbol,context,index);
	}
	copyIn(context,index) {
		return new types_Refinement(this.symbol,context,index);
	}
	copyFrom(word) {
		return new types_Refinement(word.symbol,word.context,word.index);
	}
	get_TYPE_KIND() {
		return 16;
	}
}
types_Refinement.__name__ = true;
types_Refinement.__super__ = types_base__$Word;
Object.assign(types_Refinement.prototype, {
	__class__: types_Refinement
});
class runtime_natives_Apply {
	static call(func,args,options) {
		let path = null;
		let fun = null;
		let name = null;
		let _hx_tmp;
		let _hx_tmp1;
		if(((func) instanceof types_Path) == true) {
			let __anon0__wp = func;
			let wp = __anon0__wp;
			let _hx_tmp;
			if(((wp) instanceof types_Path) == true) {
				let __anon0__p = wp;
				let p = __anon0__p;
				path = p;
				name = js_Boot.__cast(path.values[path.index] , types_Word);
			} else {
				_hx_tmp = ((wp) instanceof types_base__$Word);
				if(_hx_tmp == true) {
					let __anon0__w = wp;
					let w = __anon0__w;
					name = w;
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
			let _g = name.get();
			if(js_Boot.__implements(_g,types_base_IFunction) == true) {
				let __anon0__value = _g;
				let value = __anon0__value;
				fun = value;
			} else {
				throw haxe_Exception.thrown("bad");
			}
		} else {
			_hx_tmp1 = ((func) instanceof types_base__$Word);
			if(_hx_tmp1 == true) {
				let __anon0__wp = func;
				let wp = __anon0__wp;
				let _hx_tmp;
				if(((wp) instanceof types_Path) == true) {
					let __anon0__p = wp;
					let p = __anon0__p;
					path = p;
					name = js_Boot.__cast(path.values[path.index] , types_Word);
				} else {
					_hx_tmp = ((wp) instanceof types_base__$Word);
					if(_hx_tmp == true) {
						let __anon0__w = wp;
						let w = __anon0__w;
						name = w;
					} else {
						throw haxe_Exception.thrown("bad");
					}
				}
				let _g = name.get();
				if(js_Boot.__implements(_g,types_base_IFunction) == true) {
					let __anon0__value = _g;
					let value = __anon0__value;
					fun = value;
				} else {
					throw haxe_Exception.thrown("bad");
				}
			} else {
				_hx_tmp = js_Boot.__implements(func,types_base_IFunction);
				if(_hx_tmp == true) {
					let __anon0__f = func;
					let f = __anon0__f;
					fun = f;
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
		}
		return runtime_natives_Do.evalGroupedExpr(runtime_natives_Do.groupFnApply(fun,path != null ? path.skip(1) : null,new util__$Series__$Series(args.values,args.index),options.all,options.safer)[0]);
	}
}
runtime_natives_Apply.__name__ = true;
class types_File extends types_base__$String {
	constructor(values,index) {
		super(values,index);
	}
	clone(values,index) {
		return new types_File(values,index);
	}
	get_TYPE_KIND() {
		return 7;
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_File);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_File);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_File);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_File);
	}
	head() {
		return js_Boot.__cast(super.head() , types_File);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_File);
	}
}
types_File.__name__ = true;
types_File.__super__ = types_base__$String;
Object.assign(types_File.prototype, {
	__class__: types_File
});
class types_Url extends types_base__$String {
	constructor(values,index) {
		super(values,index);
	}
	clone(values,index) {
		return new types_Url(values,index);
	}
	get_TYPE_KIND() {
		return 8;
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_Url);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_Url);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_Url);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_Url);
	}
	head() {
		return js_Boot.__cast(super.head() , types_Url);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_Url);
	}
}
types_Url.__name__ = true;
types_Url.__super__ = types_base__$String;
Object.assign(types_Url.prototype, {
	__class__: types_Url
});
class types_Tag extends types_base__$String {
	constructor(values,index) {
		super(values,index);
	}
	clone(values,index) {
		return new types_Tag(values,index);
	}
	get_TYPE_KIND() {
		return 39;
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_Tag);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_Tag);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_Tag);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_Tag);
	}
	head() {
		return js_Boot.__cast(super.head() , types_Tag);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_Tag);
	}
	static fromString(str) {
		return new types_Tag(types_base__$String.codesFromRed(str));
	}
}
types_Tag.__name__ = true;
types_Tag.__super__ = types_base__$String;
Object.assign(types_Tag.prototype, {
	__class__: types_Tag
});
class types_Email extends types_base__$String {
	constructor(values,index) {
		super(values,index);
	}
	clone(values,index) {
		return new types_Email(values,index);
	}
	getPath(access,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let _hx_tmp = ((access) instanceof types_Word) ? access : null;
		let _hx_tmp_a = _hx_tmp != null;
		let _hx_tmp_b = _hx_tmp;
		let _g = _hx_tmp_b;
		if(_hx_tmp_a == true) {
			let _hx_tmp;
			if(_g == null) {
				let _hx_tmp1;
				_hx_tmp = _g;
				let _hx_tmp2 = _hx_tmp;
				if(_hx_tmp2.symbol.equalsString("user",ignoreCase) == true) {
					return haxe_ds_Option.Some(new types_String(this.values.slice(0,this.values.indexOf(64))));
				} else {
					_hx_tmp1 = _hx_tmp2.symbol.equalsString("host",ignoreCase);
					if(_hx_tmp1 == true) {
						return haxe_ds_Option.Some(new types_String(this.values.slice(this.values.indexOf(64) + 1)));
					} else {
						return super.getPath(access);
					}
				}
			} else {
				let _hx_tmp1;
				_hx_tmp = _g;
				let _hx_tmp2 = _hx_tmp;
				if(_hx_tmp2.symbol.equalsString("user",ignoreCase) == true) {
					return haxe_ds_Option.Some(new types_String(this.values.slice(0,this.values.indexOf(64))));
				} else {
					_hx_tmp1 = _hx_tmp2.symbol.equalsString("host",ignoreCase);
					if(_hx_tmp1 == true) {
						return haxe_ds_Option.Some(new types_String(this.values.slice(this.values.indexOf(64) + 1)));
					} else {
						return super.getPath(access);
					}
				}
			}
		} else {
			return super.getPath(access);
		}
	}
	get_TYPE_KIND() {
		return 40;
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_Email);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_Email);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_Email);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_Email);
	}
	head() {
		return js_Boot.__cast(super.head() , types_Email);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_Email);
	}
}
types_Email.__name__ = true;
types_Email.__interfaces__ = [types_base_IGetPath];
types_Email.__super__ = types_base__$String;
Object.assign(types_Email.prototype, {
	__class__: types_Email
});
class types_Ref extends types_base__$String {
	constructor(values,index) {
		super(values,index);
	}
	clone(values,index) {
		return new types_Ref(values,index);
	}
	get_TYPE_KIND() {
		return 43;
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_Ref);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_Ref);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_Ref);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_Ref);
	}
	head() {
		return js_Boot.__cast(super.head() , types_Ref);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_Ref);
	}
}
types_Ref.__name__ = true;
types_Ref.__super__ = types_base__$String;
Object.assign(types_Ref.prototype, {
	__class__: types_Ref
});
class runtime_natives_As {
	static call(type,spec) {
		let kind;
		let _hx_tmp = ((type) instanceof types_Datatype) ? type : null;
		if(_hx_tmp == null) {
			kind = type.get_TYPE_KIND();
		} else {
			let _g = _hx_tmp.get_TYPE_KIND();
			let _g1 = _hx_tmp.name;
			let k = _hx_tmp.kind;
			kind = k;
		}
		if(kind == spec.get_TYPE_KIND()) {
			return spec;
		}
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		if(((spec) instanceof types_base__$String) == true) {
			let __anon0__str = spec;
			let str = __anon0__str;
			let _g = runtime_natives_As.STRING_TYPES.h[kind];
			let _hx_tmp;
			if(_g == null) {
				throw haxe_Exception.thrown("incompatible type!");
			} else {
				_hx_tmp = _g;
				let cls = _hx_tmp;
				return new cls(str.values, str.index);
			}
		} else {
			_hx_tmp3 = ((spec) instanceof types_Block);
			if(_hx_tmp3 == true) {
				let __anon0__block = spec;
				let block = __anon0__block;
				let _g = runtime_natives_As.BLOCK_TYPES.h[kind];
				let _hx_tmp;
				if(_g == null) {
					throw haxe_Exception.thrown("incompatible type!");
				} else {
					_hx_tmp = _g;
					let cls = _hx_tmp;
					return new cls(block.values, block.index, block.newlines);
				}
			} else {
				_hx_tmp2 = ((spec) instanceof types_Paren);
				if(_hx_tmp2 == true) {
					let __anon0__block = spec;
					let block = __anon0__block;
					let _g = runtime_natives_As.BLOCK_TYPES.h[kind];
					let _hx_tmp;
					if(_g == null) {
						throw haxe_Exception.thrown("incompatible type!");
					} else {
						_hx_tmp = _g;
						let cls = _hx_tmp;
						return new cls(block.values, block.index, block.newlines);
					}
				} else {
					_hx_tmp1 = ((spec) instanceof types_base__$Path);
					if(_hx_tmp1 == true) {
						let __anon0__path = spec;
						let path = __anon0__path;
						let _g = runtime_natives_As.BLOCK_TYPES.h[kind];
						let _hx_tmp;
						if(_g == null) {
							throw haxe_Exception.thrown("incompatible type!");
						} else {
							_hx_tmp = _g;
							let cls = _hx_tmp;
							return new cls(path.values, path.index);
						}
					} else {
						throw haxe_Exception.thrown("incompatible type!");
					}
				}
			}
		}
	}
}
runtime_natives_As.__name__ = true;
class util_Dec64 {
	static toUnsignedZA1BigInt(i) {
		if((i < 0)) {
			return (256n + i);
		} else {
			return i;
		}
	}
	static toUnsignedZA1Int(i) {
		if(i < 0) {
			return 256 + i;
		} else {
			return i;
		}
	}
	static toSignedZA1BigInt(i) {
		if((i > 127n)) {
			return (i - 256n);
		} else {
			return i;
		}
	}
	static ofZA2IntZ_Int(coef,exp) {
		return ((BigInt(coef) << 8n) | BigInt(util_Dec64.toUnsignedZA1Int(exp)));
	}
	static ofZA2BigIntZ_Int(coef,exp) {
		return ((coef << 8n) | BigInt(util_Dec64.toUnsignedZA1Int(exp)));
	}
	static ofZA2BigIntZ_BigInt(coef,exp) {
		return ((coef << 8n) | util_Dec64.toUnsignedZA1BigInt(exp));
	}
	static make(coef,exp) {
		let x = coef;
		let e = exp;
		if((coef == 0) || exp <= -148) {
			return util_Dec64.ZERO;
		}
		while(e < 127) {
			let signmask = (x >> 63n);
			let xAbs = (x ^ signmask);
			if((xAbs >= 3602879701896396800n)) {
				x = ((x ^ signmask) - signmask);
				x = (((x * -3689348814741910323n) >> 64n) >> 3n);
				x = ((x ^ signmask) - signmask);
				++e;
			} else {
				let deficit = +((xAbs > 36028797018963967n)) + +((xAbs > 360287970189639679n));
				deficit = Math.max(-127 - e,deficit);
				if(deficit == 0) {
					if((x != 0)) {
						return util_Dec64.ofZA2BigIntZ_Int(x,e);
					} else {
						return util_Dec64.ZERO;
					}
				}
				if(deficit >= 20) {
					return util_Dec64.ZERO;
				}
				let scale = util_Dec64.POWER[deficit];
				if((x > 0)) {
					x = ((x + (scale >> 1n)) / scale);
				} else {
					x = ((x - (scale >> 1n)) / scale);
				}
				e += deficit;
			}
		}
		haxe_Log.trace(x,{ fileName : "src/util/Dec64.hx", lineNumber : 137, className : "util._Dec64.Dec64_Impl_", methodName : "make", customParams : [e]});
		if(e >= 148) {
			return util_Dec64.NAN;
		}
		let xAbs = (x < 0) ? -x : x;
		let lsb = (xAbs == 0) ? 63 : util_MathTools._clz64(x) - 1;
		let log10Scale = lsb > 0 ? lsb * 77 >> 8 : 0;
		log10Scale = Math.min(e - 127,log10Scale);
		x *= util_Dec64.POWER[log10Scale];
		e -= log10Scale;
		while(e > 127) {
			x *= 10n;
			if((x > util_Dec64.MAX64)) {
				return util_Dec64.NAN;
			}
			--e;
		}
		if((x <= util_Dec64.MAX64)) {
			return util_Dec64.ofZA2BigIntZ_Int(x,e);
		} else {
			return util_Dec64.ZERO;
		}
	}
	static fromDouble(d) {
		return util_Dec64.fromString(d.toString());
	}
	static fromString(str) {
		if(str == "") {
			return util_Dec64.NAN;
		}
		let c = str.charCodeAt(0);
		let at;
		let sign;
		let coefficient = 0;
		let digits = 0;
		let exponent = 0;
		let leading = true;
		let ok = true;
		let point = 0;
		if(c == 45) {
			c = str.charCodeAt(1);
			at = 1;
			sign = -1;
		} else {
			at = 0;
			sign = 1;
		}
		while(at < str.length) {
			if(c != 39) {
				if(c == 48) {
					ok = true;
					if(leading) {
						exponent -= point;
					} else {
						++digits;
						if(digits > 18) {
							exponent += 1 - point;
						} else {
							coefficient *= 10;
							exponent -= point;
						}
					}
				} else if(c >= 49 && c <= 57) {
					ok = true;
					leading = false;
					++digits;
					if(digits > 18) {
						exponent += 1 - point;
					} else {
						coefficient = coefficient * 10 + (c - 48);
						exponent -= point;
					}
				} else if(c == 46 || c == 44) {
					if(point == 1) {
						return util_Dec64.NAN;
					}
					point = 1;
				} else if(c == 101 || c == 69) {
					ok = false;
					let exp = 0;
					let expSign = 0;
					c = str.charCodeAt((++at));
					if(c == 45) {
						expSign = -1;
						c = str.charCodeAt((++at));
					} else {
						c = str.charCodeAt((++at));
					}
					while(at < str.length) if(c >= 48 && c <= 57) {
						ok = true;
						exp = exp * 10 + (c - 48);
						if(exp < 0) {
							return util_Dec64.NAN;
						}
					} else {
						return util_Dec64.NAN;
					}
					str.charCodeAt((++at));
					if(ok) {
						return util_Dec64.make(BigInt(sign * coefficient),expSign * exp + exponent);
					}
					return util_Dec64.NAN;
				}
			}
			c = str.charCodeAt((++at));
		}
		return util_Dec64.make(BigInt(sign * coefficient),exponent);
	}
	static toDouble(this1) {
		return parseFloat(util_Dec64.toString(util_Dec64.normal(this1)));
	}
	static toString(this1) {
		if(((this1 >> 8n) == 0)) {
			return "0";
		}
		let d = util_Dec64.normal(this1);
		let dCoef = (d >> 8n);
		let dExp = util_Dec64.toSignedZA1BigInt((d & 255n));
		let result = ((dCoef < 0) ? -dCoef : dCoef).toString();
		if((dExp > 0)) {
			result += "0".repeat(Number(dExp));
		} else if((dExp < 0)) {
			if((dExp == -128)) {
				return "NaN";
			}
			if((((dExp < 0) ? -dExp : dExp) == result.length)) {
				result = "0" + result;
			} else if((((dExp < 0) ? -dExp : dExp) > result.length)) {
				result = "0" + result;
				result = "0".repeat((1 + Math.abs(Number(dExp)) - result.length)) + result;
			}
			let i = result.length + Number(dExp);
			result = result.substr(0,i) + "." + result.substr(i);
		}
		if((dCoef < 0)) {
			result = "-" + result;
		}
		return result;
	}
	static toFixed(this1,digits) {
		let d = util_Dec64.normal(this1);
		let dCoef = (d >> 8n);
		let dExp = util_Dec64.toSignedZA1BigInt((d & 255n));
		let result = ((dCoef < 0) ? -dCoef : dCoef).toString();
		if((dExp > 0)) {
			result += "0".repeat(Number(dExp));
		} else if((dExp < 0)) {
			if((dExp == -128)) {
				return "NaN";
			}
			if((((dExp < 0) ? -dExp : dExp) == result.length)) {
				result = "0" + result;
			} else if((((dExp < 0) ? -dExp : dExp) > result.length)) {
				result = "0" + result;
				result = "0".repeat((1 + Math.abs(Number(dExp)) - result.length)) + result;
			}
			let i = result.length + Number(dExp);
			let end = result.substr(i,digits);
			if(end.length < digits) {
				end += "0".repeat((digits - end.length));
			}
			result = result.substr(0,i) + "." + end;
		} else {
			result += "." + "0".repeat(digits);
		}
		if((dCoef < 0)) {
			result = "-" + result;
		}
		return result;
	}
	static isInteger(this1) {
		let x = (this1 >> 8n);
		let e = util_Dec64.toSignedZA1BigInt((this1 & 255n));
		if((e >= 0) || (x == 0) && (e != -128)) {
			return true;
		}
		if((e < -17)) {
			return false;
		}
		return ((x % util_Dec64.POWER[-Number(e)]) == 0);
	}
	static isZero(this1) {
		if((util_Dec64.toSignedZA1BigInt((this1 & 255n)) == -128)) {
			return false;
		}
		return ((this1 >> 8n) == 0);
	}
	static addSlow(cx,ex,cy,ey) {
		let r0 = cy;
		let r1 = cx;
		let e0 = ey;
		let e1 = ex;
		if(ex > ey) {
			[r0, r1] = [r1, r0];
			[e0, e1] = [e1, e0];
		}
		let e0_0 = e0;
		if(e1 == -128) {
			return util_Dec64.NAN;
		}
		if((r0 == 0)) {
			e0 = e1;
		}
		if(e0 > e1) {
			let r0Abs = (r0 < 0) ? -r0 : r0;
			let lsb = (r0Abs == 0) ? 63 : util_MathTools._clz64(r0Abs) - 1;
			let log10Scale = lsb > 0 ? lsb * 77 >> 8 : 0;
			log10Scale = Math.min(e0 - e1,log10Scale);
			r0 *= util_Dec64.POWER[log10Scale];
			e0 -= log10Scale;
			while(e0 > e1) {
				r0 *= 10n;
				if((r0 > util_Dec64.MAX64)) {
					let ediff = e0 - e1;
					if(ediff > 10) {
						return util_Dec64.make(r0,e0_0);
					}
					r1 /= util_Dec64.POWER[ediff];
					if((r1 == 0)) {
						return util_Dec64.make(r0,e0_0);
					}
					return util_Dec64.make((r0 + r1),e0);
				}
				--e0;
			}
		}
		return util_Dec64.make((r0 + r1),e0);
	}
	static add(this1,other) {
		let xExp = util_Dec64.toSignedZA1BigInt((this1 & 255n));
		let yExp = util_Dec64.toSignedZA1BigInt((other & 255n));
		if(((xExp | yExp) == 0)) {
			let res = ((this1 >> 8n) + (other >> 8n));
			if((res < util_Dec64.MAX64)) {
				return util_Dec64.ofZA2BigIntZ_Int(res,0);
			} else {
				return util_Dec64.make(((this1 >> 8n) + (other >> 8n)),0);
			}
		} else if(((xExp ^ yExp) == 0)) {
			if((xExp == -128)) {
				return util_Dec64.NAN;
			}
			let xCoef = (this1 >> 8n);
			let yCoef = (other >> 8n);
			let r = (xCoef + yCoef);
			if((r < util_Dec64.MAX64)) {
				if((r == 0)) {
					return util_Dec64.ZERO;
				} else {
					return util_Dec64.normal(util_Dec64.make(r,Number(xExp)));
				}
			} else {
				return util_Dec64.normal(util_Dec64.make((xCoef + yCoef),Number(xExp)));
			}
		} else {
			return util_Dec64.normal(util_Dec64.addSlow((this1 >> 8n),Number(xExp),(other >> 8n),Number(yExp)));
		}
	}
	static sub(this1,other) {
		let xExp = util_Dec64.toSignedZA1BigInt((this1 & 255n));
		let yExp = util_Dec64.toSignedZA1BigInt((other & 255n));
		if(((xExp | yExp) == 0)) {
			let res = (this1 - other);
			if((res < util_Dec64.MAX64)) {
				return res;
			} else {
				return util_Dec64.make(((this1 >> 8n) - (other >> 8n)),0);
			}
		} else if(((xExp ^ yExp) == 0)) {
			if((xExp == -128)) {
				return util_Dec64.NAN;
			}
			let xCoef = (this1 >> 8n);
			let yCoef = (other >> 8n);
			let r = (xCoef - yCoef);
			if((r < util_Dec64.MAX64)) {
				if((r == 0)) {
					return util_Dec64.ZERO;
				} else {
					return util_Dec64.normal(util_Dec64.ofZA2BigIntZ_BigInt(r,xExp));
				}
			} else {
				return util_Dec64.normal(util_Dec64.make((xCoef - yCoef),Number(xExp)));
			}
		} else {
			return util_Dec64.normal(util_Dec64.addSlow((this1 >> 8n),Number(xExp),-(other >> 8n),Number(yExp)));
		}
	}
	static mul(this1,other) {
		let ex = Number(util_Dec64.toSignedZA1BigInt((this1 & 255n)));
		let ey = Number(util_Dec64.toSignedZA1BigInt((other & 255n)));
		let cx = (this1 >> 8n);
		let cy = (other >> 8n);
		if((cx == 0) && ex != -128 || (cy == 0) && ey != -128) {
			return util_Dec64.ZERO;
		}
		if(ex == -128 && ey == -128) {
			return util_Dec64.NAN;
		}
		let rBig = (cx * cy);
		let rHigh = (rBig >> 64n);
		let e = ex + ey;
		if((rHigh == (rBig >> 63n))) {
			return util_Dec64.normal(util_Dec64.make(rBig,e));
		}
		let rHighAbs = (rHigh < 0) ? -rHigh : rHigh;
		let deltaEr = (rHighAbs == 0) ? 1 : (63 - util_MathTools._clz64(rHighAbs)) * 77 >> 8;
		let r2 = (rBig / util_Dec64.POWER[deltaEr]);
		return util_Dec64.normal(util_Dec64.make(r2,e + deltaEr));
	}
	static divide(this1,other) {
		let ex = Number(util_Dec64.toSignedZA1BigInt((this1 & 255n)));
		let ey = Number(util_Dec64.toSignedZA1BigInt((other & 255n)));
		let cx = (this1 >> 8n);
		let cy = (other >> 8n);
		if((cx == 0) && ex != -128) {
			return [0,0n,0];
		}
		if(ex == -128 || ey == -128 || (cy == 0)) {
			return [-1,0n,-128];
		}
		let b = BigInt(Math.min(util_MathTools._ctz64(cx),util_MathTools._ctz64(cy)));
		cx >>= b;
		cy >>= b;
		let yAbs = (cy < 0) ? -cy : cy;
		let yAbsInt = Number(yAbs);
		let scale = 0;
		if((yAbs <= 50)) {
			scale = util_Dec64.FAST_TAB1[yAbsInt - 1];
			if(scale != 0) {
				return [1,(cx * BigInt((cy < 0) ? -scale : scale)),ex - ey - util_Dec64.FAST_TAB2[yAbsInt - 1]];
			}
		}
		let yLog2 = 63 - util_MathTools._clz64(yAbs);
		let prescaleLog10 = 0;
		while(true) {
			let xAbs = (cx < 0) ? -cx : cx;
			let xLog2 = 63 - util_MathTools._clz64(xAbs);
			prescaleLog10 = (yLog2 + 58 - xLog2) * 77 >> 8;
			if(prescaleLog10 <= 18) {
				break;
			}
			prescaleLog10 = (58 - xLog2) * 77 >> 8;
			cx *= util_Dec64.POWER[prescaleLog10];
			ex -= prescaleLog10;
		}
		return [1,((cx * util_Dec64.POWER[prescaleLog10]) / cy),ex - ey - prescaleLog10];
	}
	static div(this1,other) {
		/*;
		let status = ;
		let q = ;
		let qexp = ;
		*/ //;
		let [status, q, qexp] = util_Dec64.divide(this1,other);
		if(status == 0) {
			return util_Dec64.ZERO;
		} else if(status == -1) {
			return util_Dec64.NAN;
		} else {
			return util_Dec64.normal(util_Dec64.make(q,qexp));
		}
	}
	static toInt(this1,roundDir) {
		let e = Number(util_Dec64.toSignedZA1BigInt((this1 & 255n)));
		let c = (this1 >> 8n);
		if(e == -128) {
			return util_Dec64.NAN;
		}
		e = -e;
		let rem;
		if(e < 17) {
			let p = util_Dec64.POWER[e];
			let cScaled = (c / p);
			rem = (c - (cScaled * p));
			if((rem == 0)) {
				return (cScaled << 8n);
			}
			c = cScaled;
		} else {
			rem = c;
			c = 0n;
		}
		let delta = +(((rem ^ BigInt(roundDir)) >= 0)) * roundDir;
		return ((c + BigInt(delta)) << 8n);
	}
	static intDiv(this1,other) {
		let ex = util_Dec64.toSignedZA1BigInt((this1 & 255n));
		let ey = util_Dec64.toSignedZA1BigInt((other & 255n));
		if((ex == ey)) {
			let cx = (this1 >> 8n);
			let cy = (other >> 8n);
			if((cx == 0) && (ex != -128)) {
				return util_Dec64.ZERO;
			}
			if((ex == -128) || (ey == -128) || (cy == 0)) {
				return util_Dec64.NAN;
			}
			let delta = ((cx ^ cy) >= 0) ? 0n : (cy > 0) ? 1n : -1n;
			return (((cx + delta) / cy) << 8n);
		} else {
			return util_Dec64.toInt(util_Dec64.div(this1,other),-1);
		}
	}
	static mod(this1,other) {
		let ex = util_Dec64.toSignedZA1BigInt((this1 & 255n));
		let ey = util_Dec64.toSignedZA1BigInt((other & 255n));
		if((ex == ey)) {
			let cx = (this1 >> 8n);
			let cy = (other >> 8n);
			if((cx == 0) && (ex != -128)) {
				return util_Dec64.ZERO;
			}
			if((ex == -128) || (ey == -128) || (cy == 0)) {
				return util_Dec64.NAN;
			}
			let rem = (cx % cy);
			return util_Dec64.ofZA2BigIntZ_BigInt((rem == 0) ? rem : (rem + (((cx ^ cy) < 0) ? cy : 0n)),ex);
		} else {
			return util_Dec64.sub(this1,util_Dec64.mul(util_Dec64.intDiv(this1,other),other));
		}
	}
	static neg(this1) {
		let e = Number(util_Dec64.toSignedZA1BigInt((this1 & 255n)));
		if(e == -128) {
			return util_Dec64.NAN;
		}
		let r = -(this1 >> 8n);
		if((r != 0)) {
			return util_Dec64.ofZA2BigIntZ_Int(r,e);
		} else {
			return util_Dec64.ZERO;
		}
	}
	static abs(this1) {
		if((util_Dec64.toSignedZA1BigInt((this1 & 255n)) == -128)) {
			return util_Dec64.NAN;
		}
		let c = (this1 >> 8n);
		if((c < 0)) {
			return util_Dec64.neg(this1);
		} else if((c == 0)) {
			return util_Dec64.ZERO;
		} else {
			return this1;
		}
	}
	static sign(this1) {
		return Math.sign(Number((this1 >> 8n)));
	}
	static normal(this1) {
		let e = Number(util_Dec64.toSignedZA1BigInt((this1 & 255n)));
		if(e == -128) {
			return util_Dec64.NAN;
		}
		if(e == 0) {
			return this1;
		}
		let c = (this1 >> 8n);
		if((c == 0)) {
			return util_Dec64.ZERO;
		}
		if(e < 0) {
			do {
				let tmp = (c / 10n);
				if((c != (tmp * 10n))) {
					break;
				}
				c = tmp;
				++e;
			} while(e < 0);
			return util_Dec64.ofZA2BigIntZ_Int(c,e);
		} else {
			c <<= 8n;
			do {
				c *= 10n;
				if((c < util_Dec64.MAX64)) {
					c = c;
					break;
				}
				--e;
			} while(e > 0);
			return (c | BigInt(e));
		}
	}
}
class types_Money extends Value {
	constructor(m,region) {
		super();
		this.m = m;
		this.region = region;
	}
	get_TYPE_KIND() {
		return 42;
	}
}
types_Money.__name__ = true;
types_Money.__super__ = Value;
Object.assign(types_Money.prototype, {
	__class__: types_Money
});
class util_MathTools {
	static _away(value) {
		let d = Math.ceil(Math.abs(value));
		if(value < 0) {
			return 0 - d;
		} else {
			return d;
		}
	}
	static _ldexp(x,exp) {
		let steps = Math.min(3, Math.ceil(Math.abs(exp) / 1023));
		let result = x;
		let _g = 0;
		while(_g < steps) result *= Math.pow(2,Math.floor((exp + _g++) / steps));
		return result;
	}
	static _frexp(arg) {
		if(arg != 0 && isFinite(arg)) {
			let absArg = Math.abs(arg);
			let exp = Math.max(-1023, (Math.floor(Math.log2(absArg)) + 1));
			let x = absArg * Math.pow(2,-exp);
			while(x < 0.5) {
				x *= 2;
				--exp;
			}
			while(x >= 1) {
				x *= 0.5;
				++exp;
			}
			if(arg < 0) {
				x = -x;
			}
			return [x,exp];
		} else {
			return [arg,0];
		}
	}
	static _ctz64(x) {
		let c = 0;
		while(((x & 1n) != 1)) {
			x >>= 1n;
			++c;
		}
		return c;
	}
	static _clz64(x) {
		let high = Number((x >> 64n)) | 0;
		let res = high == 0 ? 32 : Math.clz32(high);
		let low = Number(x) | 0;
		if(res == 32) {
			return res + Math.clz32(low);
		} else {
			return res;
		}
	}
}
util_MathTools.__name__ = true;
class runtime_natives_AsMoney {
	static call(currency,amount) {
		let _hx_tmp;
		if(((amount) instanceof types_Integer) == true) {
			let __anon0__i = amount;
			let i = __anon0__i;
			return runtime_actions_datatypes_MoneyActions.fromInteger(i,currency);
		} else {
			_hx_tmp = ((amount) instanceof types_Float);
			if(_hx_tmp == true) {
				let __anon0__f = amount;
				let f = __anon0__f;
				return runtime_actions_datatypes_MoneyActions.fromFloat(f,currency);
			} else {
				throw haxe_Exception.thrown("bad");
			}
		}
	}
}
runtime_natives_AsMoney.__name__ = true;
class types_Pair extends Value {
	constructor(x,y) {
		super();
		this.x = x;
		this.y = y;
	}
	getPath(access,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let _hx_tmp = ((access) instanceof types_Word) ? access : null;
		let _hx_tmp_a = _hx_tmp != null;
		let _hx_tmp_b = _hx_tmp;
		let _g = _hx_tmp_b;
		if(_hx_tmp_a == true) {
			let _hx_tmp;
			if(_g == null) {
				let _hx_tmp1;
				_hx_tmp = _g;
				let _hx_tmp2 = _hx_tmp;
				if(_hx_tmp2.symbol.equalsString("x",ignoreCase) == true) {
					return haxe_ds_Option.Some(new types_Integer(this.x));
				} else {
					_hx_tmp1 = _hx_tmp2.symbol.equalsString("y",ignoreCase);
					if(_hx_tmp1 == true) {
						return haxe_ds_Option.Some(new types_Integer(this.y));
					} else {
						return haxe_ds_Option.None;
					}
				}
			} else {
				let _hx_tmp1;
				_hx_tmp = _g;
				let _hx_tmp2 = _hx_tmp;
				if(_hx_tmp2.symbol.equalsString("x",ignoreCase) == true) {
					return haxe_ds_Option.Some(new types_Integer(this.x));
				} else {
					_hx_tmp1 = _hx_tmp2.symbol.equalsString("y",ignoreCase);
					if(_hx_tmp1 == true) {
						return haxe_ds_Option.Some(new types_Integer(this.y));
					} else {
						return haxe_ds_Option.None;
					}
				}
			}
		} else {
			return haxe_ds_Option.None;
		}
	}
	get_TYPE_KIND() {
		return 33;
	}
}
types_Pair.__name__ = true;
types_Pair.__interfaces__ = [types_base_IGetPath];
types_Pair.__super__ = Value;
Object.assign(types_Pair.prototype, {
	__class__: types_Pair
});
class runtime_natives_AsPair {
	static call(x,y) {
		return new types_Pair(x.asInt(),y.asInt());
	}
}
runtime_natives_AsPair.__name__ = true;
class types_Typeset extends Value {
	constructor(types) {
		super();
		this.types = types;
	}
	matchesTypeOfValue(value) {
		let _g = [];
		let jsIterator = this.types.values();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			_g.push(v);
		}
		return Lambda.exists(_g,function(t) {
			return t.matchesTypeOfValue(value);
		});
	}
	get_TYPE_KIND() {
		return 30;
	}
	static ofAny(types) {
		let res = new Set([]);
		let type = $getIterator(types);
		while(type.hasNext()) {
			let type1 = type.next();
			let _hx_tmp;
			if(((type1) instanceof types_Datatype) == true) {
				let __anon0__dt = type1;
				let dt = __anon0__dt;
				res.add(dt);
			} else {
				_hx_tmp = ((type1) instanceof types_Typeset);
				if(_hx_tmp == true) {
					let __anon0__ts = type1;
					let ts = __anon0__ts;
					let jsIterator = ts.types.values();
					let type__jsIterator = jsIterator;
					let type__lastStep = jsIterator.next();
					while(!type__lastStep.done) {
						let v = type__lastStep.value;
						type__lastStep = type__jsIterator.next();
						let type_ = v;
						res.add(type_);
					}
				}
			}
		}
		return new types_Typeset(res);
	}
}
types_Typeset.__name__ = true;
types_Typeset.__interfaces__ = [types_base_IDatatype];
types_Typeset.__super__ = Value;
Object.assign(types_Typeset.prototype, {
	__class__: types_Typeset
});
class runtime_natives_Bind {
	static bindWords(block,ctx) {
		let _g = 0;
		let _g1 = block.values.length;
		while(_g < _g1) {
			let i = _g++;
			let _g1 = block.values[i];
			let _hx_tmp;
			if(((_g1) instanceof types_base__$Word) == true) {
				let __anon0__word = _g1;
				let word = __anon0__word;
				block.values[i] = word.copyIn(ctx,ctx.addWord(word));
			} else {
				_hx_tmp = ((_g1) instanceof types_base__$Block);
				if(_hx_tmp == true) {
					let __anon0__blk = _g1;
					let blk = __anon0__blk;
					runtime_natives_Bind.bindWords(blk,ctx);
				}
			}
		}
	}
	static call(word,context,options) {
		let ctx;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((context) instanceof types_base__$AnyWord) == true) {
			let __anon0__word = context;
			let word = __anon0__word;
			ctx = word.context;
		} else {
			_hx_tmp2 = ((context) instanceof types_Object);
			if(_hx_tmp2 == true) {
				let __anon0__obj = context;
				let obj = __anon0__obj;
				ctx = obj.ctx;
			} else {
				_hx_tmp1 = ((context) instanceof types_base_Context);
				if(_hx_tmp1 == true) {
					let __anon0__ctx_ = context;
					let ctx_ = __anon0__ctx_;
					ctx = ctx_;
				} else {
					_hx_tmp = ((context) instanceof types_Function);
					if(_hx_tmp == true) {
						let __anon0__func = context;
						let func = __anon0__func;
						ctx = func.ctx;
					} else {
						throw haxe_Exception.thrown("error!");
					}
				}
			}
		}
		return runtime_natives_Bind._call(word,ctx,options);
	}
	static _call(word,ctx,options) {
		let _hx_tmp;
		if(((word) instanceof types_base__$AnyWord) == true) {
			let __anon0__w = word;
			let w = __anon0__w;
			return w.copyIn(ctx,ctx.addWord(w));
		} else {
			_hx_tmp = ((word) instanceof types_Block);
			if(_hx_tmp == true) {
				let __anon0__b = word;
				let b = __anon0__b;
				if(options.copy) {
					b = runtime_actions_Copy.call(b,{ deep : true, types : { kind : runtime_natives_Bind.copyTypeset}});
				}
				runtime_natives_Bind.bindWords(b,ctx);
				return b;
			} else {
				throw haxe_Exception.thrown("error!");
			}
		}
	}
}
runtime_natives_Bind.__name__ = true;
class types_Error extends types_Object {
	constructor(code,type,id,arg1,arg2,arg3,near,where,stack) {
		let _g = [];
		let _g1 = 0;
		let _g2 = ["code","type","id","arg1","arg2","arg3","near","where","stack"];
		while(_g1 < _g2.length) _g.push(new types_Word(types_base_Symbol.make(_g2[_g1++])));
		super(new types_base_Context(_g,[code,type,id,arg1,arg2,arg3,near,where,stack]),1,true);
	}
	get_type() {
		return (js_Boot.__cast(this.ctx.values[1] , types_Word)).symbol.name.toLowerCase();
	}
	get_id() {
		return (js_Boot.__cast(this.ctx.values[2] , types_Word)).symbol.name.toLowerCase();
	}
	get_arg1() {
		return this.ctx.values[3];
	}
	description() {
		return "" + this.get_type() + ": " + this.get_id();
	}
	isBreak() {
		if(this.get_type() == "throw") {
			return this.get_id() == "break";
		} else {
			return false;
		}
	}
	isContinue() {
		if(this.get_type() == "throw") {
			return this.get_id() == "continue";
		} else {
			return false;
		}
	}
	isReturn() {
		if(this.get_type() == "throw") {
			return this.get_id() == "return";
		} else {
			return false;
		}
	}
	isThrow() {
		if(this.get_type() == "throw") {
			return this.get_id() == "throw";
		} else {
			return false;
		}
	}
	isSpecial() {
		if(this.get_type() == "throw") {
			if(!(this.get_id() == "break" || this.get_id() == "continue" || this.get_id() == "return")) {
				return this.get_id() == "throw";
			} else {
				return true;
			}
		} else {
			return false;
		}
	}
	get_TYPE_KIND() {
		return 31;
	}
	static _create(spec) {
		let opt = spec.code;
		let opt1;
		switch(opt[1]) {
		case 0:
			opt1 = haxe_ds_Option.Some(new types_Integer(opt[2]));
			break;
		case 1:
			opt1 = haxe_ds_Option.None;
			break;
		}
		let tmp;
		switch(opt1[1]) {
		case 0:
			tmp = opt1[2];
			break;
		case 1:
			tmp = types_None.NONE;
			break;
		}
		let tmp1 = new types_Word(types_base_Symbol.make(spec.type));
		let tmp2 = new types_Word(types_base_Symbol.make(spec.id));
		let opt2 = spec.arg1;
		let tmp3;
		switch(opt2[1]) {
		case 0:
			tmp3 = opt2[2];
			break;
		case 1:
			tmp3 = types_None.NONE;
			break;
		}
		let opt3 = spec.arg2;
		let tmp4;
		switch(opt3[1]) {
		case 0:
			tmp4 = opt3[2];
			break;
		case 1:
			tmp4 = types_None.NONE;
			break;
		}
		let opt4 = spec.arg3;
		let tmp5;
		switch(opt4[1]) {
		case 0:
			tmp5 = opt4[2];
			break;
		case 1:
			tmp5 = types_None.NONE;
			break;
		}
		let opt5 = spec.near;
		let opt6;
		switch(opt5[1]) {
		case 0:
			let _g = [];
			let v = $getIterator(opt5[2]);
			while(v.hasNext()) _g.push(v.next());
			opt6 = haxe_ds_Option.Some(new types_Block(_g));
			break;
		case 1:
			opt6 = haxe_ds_Option.None;
			break;
		}
		let tmp6;
		switch(opt6[1]) {
		case 0:
			tmp6 = opt6[2];
			break;
		case 1:
			tmp6 = types_None.NONE;
			break;
		}
		let opt7 = spec.where;
		let tmp7;
		switch(opt7[1]) {
		case 0:
			tmp7 = opt7[2];
			break;
		case 1:
			tmp7 = types_None.NONE;
			break;
		}
		let opt8 = spec.stack;
		let opt9;
		switch(opt8[1]) {
		case 0:
			opt9 = haxe_ds_Option.Some(new types_Integer(opt8[2]));
			break;
		case 1:
			opt9 = haxe_ds_Option.None;
			break;
		}
		let tmp8;
		switch(opt9[1]) {
		case 0:
			tmp8 = opt9[2];
			break;
		case 1:
			tmp8 = types_None.NONE;
			break;
		}
		return new types_Error(tmp,tmp1,tmp2,tmp3,tmp4,tmp5,tmp6,tmp7,tmp8);
	}
	static create(spec) {
		let value = spec.code;
		let value1 = spec.arg1;
		let value2 = spec.arg2;
		let value3 = spec.arg3;
		let value4 = spec.near;
		let value5 = spec.where;
		let value6 = spec.stack;
		return types_Error._create({ code : value == null ? haxe_ds_Option.None : haxe_ds_Option.Some(value), type : spec.type, id : spec.id, arg1 : value1 == null ? haxe_ds_Option.None : haxe_ds_Option.Some(value1), arg2 : value2 == null ? haxe_ds_Option.None : haxe_ds_Option.Some(value2), arg3 : value3 == null ? haxe_ds_Option.None : haxe_ds_Option.Some(value3), near : value4 == null ? haxe_ds_Option.None : haxe_ds_Option.Some(value4), where : value5 == null ? haxe_ds_Option.None : haxe_ds_Option.Some(value5), stack : value6 == null ? haxe_ds_Option.None : haxe_ds_Option.Some(value6)});
	}
}
types_Error.__name__ = true;
types_Error.__super__ = types_Object;
Object.assign(types_Error.prototype, {
	__class__: types_Error
});
class runtime_natives_Break {
	static call(options) {
		let _g = options._return;
		throw new runtime_RedError(types_Error.create({ code : 0, type : "throw", id : "break", arg1 : _g == null ? null : _g.value}));
	}
}
runtime_natives_Break.__name__ = true;
class runtime_natives_Case {
	static call(cases,options) {
		let all = options.all;
		let res = types_None.NONE;
		let tokens = new util__$Series__$Series(cases.values,cases.index);
		if(all) {
			let trueAtLeastOnce = false;
			while(tokens.offset < tokens.values.length) {
				let cond;
				/*;
				cond = */ //;
				[cond, tokens] = runtime_natives_Do.doNextValue(tokens);
				if(cond.isTruthy()) {
					if(tokens.offset >= tokens.values.length) {
						if(trueAtLeastOnce) {
							return cond;
						} else {
							return types_None.NONE;
						}
					}
					let _g = tokens.values[tokens.offset];
					if(((_g) instanceof types_Block) == true) {
						let __anon0__b = _g;
						let b = __anon0__b;
						let ret = tokens;
						tokens = new util__$Series__$Series(tokens.values,tokens.offset + 1);
						res = runtime_natives_Do.evalValues(new util__$Series__$Series(b.values,b.index));
					} else {
						let value;
						/*;
						value = */ //;
						[value, tokens] = runtime_natives_Do.doNextValue(tokens);
						res = value;
					}
					if(!trueAtLeastOnce) {
						trueAtLeastOnce = true;
					}
				} else if(tokens.offset >= tokens.values.length) {
					return res;
				} else {
					let ret = tokens;
					tokens = new util__$Series__$Series(tokens.values,tokens.offset + 1);
				}
			}
		} else {
			while(tokens.offset < tokens.values.length) {
				let cond;
				/*;
				cond = */ //;
				[cond, tokens] = runtime_natives_Do.doNextValue(tokens);
				if(cond.isTruthy()) {
					if(tokens.offset >= tokens.values.length) {
						return types_None.NONE;
					}
					let _g = tokens.values[tokens.offset];
					if(((_g) instanceof types_Block) == true) {
						let __anon0__b = _g;
						let b = __anon0__b;
						let ret = tokens;
						tokens = new util__$Series__$Series(tokens.values,tokens.offset + 1);
						res = runtime_natives_Do.evalValues(new util__$Series__$Series(b.values,b.index));
					} else {
						let value;
						/*;
						value = */ //;
						[value, tokens] = runtime_natives_Do.doNextValue(tokens);
						res = value;
					}
					return res;
				} else if(tokens.offset >= tokens.values.length) {
					return types_None.NONE;
				} else {
					let ret = tokens;
					tokens = new util__$Series__$Series(tokens.values,tokens.offset + 1);
				}
			}
		}
		return res;
	}
}
runtime_natives_Case.__name__ = true;
function runtime_natives_CaseFolding_charToUpper(char) {
	let code = char.int;
	if(code < 127) {
		return char.toUpperCase();
	} else {
		return types_Char.fromCode(String.fromCodePoint(code).toUpperCase().charCodeAt(0));
	}
}
function runtime_natives_CaseFolding_charToLower(char) {
	let code = char.int;
	if(code < 127) {
		return char.toLowerCase();
	} else {
		return types_Char.fromCode(String.fromCodePoint(code).toLowerCase().charCodeAt(0));
	}
}
function runtime_natives_CaseFolding_changeCharCase(char,isUpper) {
	if(isUpper) {
		let code = char.int;
		if(code < 127) {
			return char.toUpperCase();
		} else {
			return types_Char.fromCode(String.fromCodePoint(code).toUpperCase().charCodeAt(0));
		}
	} else {
		let code = char.int;
		if(code < 127) {
			return char.toLowerCase();
		} else {
			return types_Char.fromCode(String.fromCodePoint(code).toLowerCase().charCodeAt(0));
		}
	}
}
function runtime_natives_CaseFolding_changeStringCase(str,isUpper,length) {
	if(isUpper) {
		let _g = 0;
		while(_g < length) {
			let i = _g++;
			let value = runtime_natives_CaseFolding_charToUpper(str.wrap(str.values[str.index + i]));
			str.values[str.index + i] = str.unwrap(value);
		}
	} else {
		let _g = 0;
		while(_g < length) {
			let i = _g++;
			let value = runtime_natives_CaseFolding_charToLower(str.wrap(str.values[str.index + i]));
			str.values[str.index + i] = str.unwrap(value);
		}
	}
}
function runtime_natives_CaseFolding_changeCase(value,isUpper,limit) {
	let _hx_tmp;
	if(((value) instanceof types_Char) == true) {
		let __anon0__char = value;
		let char = __anon0__char;
		return runtime_natives_CaseFolding_changeCharCase(char,isUpper);
	} else {
		_hx_tmp = ((value) instanceof types_base__$String);
		if(_hx_tmp == true) {
			let __anon0__str = value;
			let str = __anon0__str;
			let length;
			let _hx_tmp;
			if(limit == null) {
				length = str.values.length - str.index;
			} else {
				_hx_tmp = limit;
				let l = _hx_tmp;
				let _hx_tmp1;
				if(((l) instanceof types_base__$Number) == true) {
					let __anon0__num = l;
					let num = __anon0__num;
					let len = num.asInt();
					length = Math.max(0, Math.min(len, (str.values.length - str.index)));
				} else {
					_hx_tmp1 = ((l) instanceof types_base__$String);
					if(_hx_tmp1 == true) {
						let __anon0__str2 = l;
						let str2 = __anon0__str2;
						if(str.values == str2.values) {
							length = str2.index < str.index ? 0 : str2.index - str.index;
						} else {
							throw haxe_Exception.thrown("error!");
						}
					} else {
						throw haxe_Exception.thrown("error!");
					}
				}
			}
			runtime_natives_CaseFolding_changeStringCase(str,isUpper,length);
			return str;
		} else {
			throw haxe_Exception.thrown("error!");
		}
	}
}
class types_Char extends types_base__$Integer {
	constructor(code) {
		super(code);
	}
	toUpperCase() {
		if(97 <= this.int && this.int <= 122) {
			return types_Char.fromCode(this.int - 32);
		} else {
			return this;
		}
	}
	toLowerCase() {
		if(65 <= this.int && this.int <= 90) {
			return types_Char.fromCode(this.int + 32);
		} else {
			return this;
		}
	}
	get_TYPE_KIND() {
		return 9;
	}
	static fromCode(code) {
		let tmp = types_Char.chars.get(code);
		if(tmp != null) {
			return tmp;
		} else {
			let value = new types_Char(code);
			types_Char.chars.set(code,value);
			return value;
		}
	}
	static fromRed(str) {
		let tmp;
		if(str.charCodeAt(0) == 94) {
			let _g = str.substr(1).toUpperCase();
			switch(_g) {
			case "\"":
				tmp = 34;
				break;
			case "(BACK)":
				tmp = 8;
				break;
			case "(DEL)":case "~":
				tmp = 127;
				break;
			case "(ESC)":case "[":
				tmp = 27;
				break;
			case "(LINE)":case "/":
				tmp = 10;
				break;
			case "(NULL)":case "@":
				tmp = 0;
				break;
			case "(PAGE)":
				tmp = 12;
				break;
			case "(TAB)":case "-":
				tmp = 9;
				break;
			case "\\":
				tmp = 28;
				break;
			case "]":
				tmp = 29;
				break;
			case "^":
				tmp = 94;
				break;
			case "_":
				tmp = 31;
				break;
			default:
				if(_g.length == 1 && "A" <= _g && _g <= "Z") {
					tmp = _g.charCodeAt(0) - 64;
				} else {
					let rx = new EReg("^\\(([A-F\\d]+)\\)$","i");
					if(rx.match(_g)) {
						tmp = Util.mustParseInt("0x" + rx.matched(0));
					} else {
						throw haxe_Exception.thrown("Invalid char! literal #\"^" + _g + "\"!");
					}
				}
			}
		} else if(str.length == 1) {
			tmp = str.charCodeAt(0);
		} else {
			throw haxe_Exception.thrown("Invalid char! literal #\"" + str + "\"!");
		}
		return types_Char.fromCode(tmp);
	}
}
types_Char.__name__ = true;
types_Char.__super__ = types_base__$Integer;
Object.assign(types_Char.prototype, {
	__class__: types_Char
});
class runtime_natives_Uppercase {
	static call(value,options) {
		let tmp = options.part;
		return runtime_natives_CaseFolding_changeCase(value,true,tmp != null ? tmp.limit : null);
	}
}
runtime_natives_Uppercase.__name__ = true;
class runtime_natives_Lowercase {
	static call(value,options) {
		let tmp = options.part;
		return runtime_natives_CaseFolding_changeCase(value,false,tmp != null ? tmp.limit : null);
	}
}
runtime_natives_Lowercase.__name__ = true;
class runtime_natives_Catch {
	static call(block,options) {
		try {
			return runtime_natives_Do.evalValues(new util__$Series__$Series(block.values,block.index));
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g);
			if(((_g1) instanceof runtime_RedError)) {
				let e = _g1;
				if(e.error.isThrow()) {
					let _g = options.name;
					let _hx_tmp;
					if(_g == null) {
						return e.error.get_arg1();
					} else {
						_hx_tmp = _g;
						let nameOpt = _hx_tmp;
						let _g1 = e.name;
						let _hx_tmp1;
						if(_g1 == null) {
							throw e;
						} else {
							_hx_tmp1 = _g1;
							let ename = _hx_tmp1;
							let _g = nameOpt.word;
							let _hx_tmp;
							if(((_g) instanceof types_Word) == true) {
								let __anon0__name = _g;
								let name = __anon0__name;
								if(name.symbol.equalsSymbol(ename.symbol)) {
									return e.error.get_arg1();
								} else {
									throw e;
								}
							} else {
								_hx_tmp = ((_g) instanceof types_Block);
								if(_hx_tmp == true) {
									let __anon0__b = _g;
									let b = __anon0__b;
									let _gthis = b;
									let _this = b.values.slice(b.index);
									let result = new Array(_this.length);
									let _g1 = 0;
									let _g2 = _this.length;
									while(_g1 < _g2) {
										let i = _g1++;
										result[i] = _gthis.wrap(_this[i]);
									}
									let _g_current = 0;
									let _g_array = result;
									while(_g_current < _g_array.length) {
										let v = _g_array[_g_current++];
										if(((v) instanceof types_Word) == true) {
											let __anon0__name = v;
											let name = __anon0__name;
											if(name.symbol.equalsSymbol(ename.symbol)) {
												return e.error.get_arg1();
											}
										} else {
											throw haxe_Exception.thrown("Invalid type!");
										}
									}
									throw e;
								} else {
									throw haxe_Exception.thrown("Invalid type!");
								}
							}
						}
					}
				} else {
					throw e;
				}
			} else {
				throw _g;
			}
		}
	}
}
runtime_natives_Catch.__name__ = true;
class runtime_natives_Equal_$q {
	static call(value1,value2) {
		return runtime_Actions.compare(value1,value2,0);
	}
}
runtime_natives_Equal_$q.__name__ = true;
class runtime_natives_NotEqual_$q {
	static call(value1,value2) {
		return runtime_Actions.compare(value1,value2,1);
	}
}
runtime_natives_NotEqual_$q.__name__ = true;
class runtime_natives_StrictEqual_$q {
	static call(value1,value2) {
		return runtime_Actions.compare(value1,value2,2);
	}
}
runtime_natives_StrictEqual_$q.__name__ = true;
class runtime_natives_Lesser_$q {
	static call(value1,value2) {
		return runtime_Actions.compare(value1,value2,3);
	}
}
runtime_natives_Lesser_$q.__name__ = true;
class runtime_natives_LesserOrEqual_$q {
	static call(value1,value2) {
		return runtime_Actions.compare(value1,value2,4);
	}
}
runtime_natives_LesserOrEqual_$q.__name__ = true;
class runtime_natives_Greater_$q {
	static call(value1,value2) {
		return runtime_Actions.compare(value1,value2,5);
	}
}
runtime_natives_Greater_$q.__name__ = true;
class runtime_natives_GreaterOrEqual_$q {
	static call(value1,value2) {
		return runtime_Actions.compare(value1,value2,6);
	}
}
runtime_natives_GreaterOrEqual_$q.__name__ = true;
class runtime_natives_Same_$q {
	static call(value1,value2) {
		if(value1.get_TYPE_KIND() != value2.get_TYPE_KIND()) {
			return types_Logic.FALSE;
		} else {
			return runtime_Actions.compare(value1,value2,9);
		}
	}
}
runtime_natives_Same_$q.__name__ = true;
class runtime_natives_Complement_$q {
	static call(bitset) {
		if(bitset.negated) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
}
runtime_natives_Complement_$q.__name__ = true;
class runtime_natives_Compose {
	static call(block,options) {
		let _g = options.deep;
		let _g1 = options.only;
		if(options.into != null == true) {
			throw haxe_Exception.thrown("NYI!");
		}
		let values = [];
		if(options.only) {
			let _gthis = block;
			let _this = block.values.slice(block.index);
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = _gthis.wrap(_this[i]);
			}
			let _g_current = 0;
			let _g_array = result;
			while(_g_current < _g_array.length) {
				let value = _g_array[_g_current++];
				let _hx_tmp;
				if(((value) instanceof types_Paren) == true) {
					let __anon0__p = value;
					let p = __anon0__p;
					values.push(runtime_natives_Do.evalValues(new util__$Series__$Series(p.values,p.index)));
				} else {
					_hx_tmp = ((value) instanceof types_Block);
					if(_hx_tmp == true) {
						let __anon0__b = value;
						if(options.deep) {
							let b = __anon0__b;
							values.push(runtime_natives_Compose.call(b,options));
						} else {
							values.push(value);
						}
					} else {
						values.push(value);
					}
				}
			}
		} else {
			let _gthis = block;
			let _this = block.values.slice(block.index);
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = _gthis.wrap(_this[i]);
			}
			let _g_current = 0;
			let _g_array = result;
			while(_g_current < _g_array.length) {
				let value = _g_array[_g_current++];
				let _hx_tmp;
				if(((value) instanceof types_Paren) == true) {
					let __anon0__p = value;
					let p = __anon0__p;
					let _g = runtime_natives_Do.evalValues(new util__$Series__$Series(p.values,p.index));
					if(((_g) instanceof types_Block) == true) {
						let __anon0__b = _g;
						let b = __anon0__b;
						let _gthis = b;
						let _this = b.values.slice(b.index);
						let result = new Array(_this.length);
						let _g1 = 0;
						let _g2 = _this.length;
						while(_g1 < _g2) {
							let i = _g1++;
							result[i] = _gthis.wrap(_this[i]);
						}
						let _g_current = 0;
						let _g_array = result;
						while(_g_current < _g_array.length) {
							let v = _g_array[_g_current++];
							values.push(v);
						}
					} else {
						let v = _g;
						values.push(v);
					}
				} else {
					_hx_tmp = ((value) instanceof types_Block);
					if(_hx_tmp == true) {
						let __anon0__b = value;
						if(options.deep) {
							let b = __anon0__b;
							values.push(runtime_natives_Compose.call(b,options));
						} else {
							values.push(value);
						}
					} else {
						values.push(value);
					}
				}
			}
		}
		return new types_Block(values);
	}
}
runtime_natives_Compose.__name__ = true;
class runtime_natives_Construct {
	static call(block,options) {
		let evalLogic = !options.only;
		let obj;
		let _g = options.with;
		let _hx_tmp;
		if(_g == null) {
			obj = new types_Object();
		} else {
			_hx_tmp = _g;
			let w = _hx_tmp;
			let obj1 = w.object;
			obj = new types_Object(obj1.ctx,obj1.classID);
		}
		let i = block.index;
		let values = block.values;
		let len = values.length;
		while(i < len) {
			let _g = values[i];
			let _hx_tmp = ((_g) instanceof types_SetWord) ? _g : null;
			if(_hx_tmp != null) {
				let _g = _hx_tmp.get_TYPE_KIND();
				let _g1 = _hx_tmp.context;
				let _g2 = _hx_tmp.symbol;
				let _g3 = _hx_tmp.index;
				let _g4 = types_base_Symbol.INDEXES.get(_g2.name);
				let field = _g2.name;
				++i;
				let value = values[i];
				if(evalLogic) {
					let _hx_tmp = ((value) instanceof types_Word) ? value : null;
					if(_hx_tmp != null) {
						let _g = _hx_tmp.get_TYPE_KIND();
						let _g1 = _hx_tmp.context;
						let _g2 = _hx_tmp.symbol;
						let _g3 = _hx_tmp.index;
						let _g4 = types_base_Symbol.INDEXES.get(_g2.name);
						let name = _g2.name;
						switch(name.toLowerCase()) {
						case "false":case "no":case "off":
							value = types_Logic.FALSE;
							break;
						case "on":case "true":case "yes":
							value = types_Logic.TRUE;
							break;
						default:
						}
					}
				}
				obj.ctx.addOrSet(field,value,true);
			}
			++i;
		}
		return obj;
	}
}
runtime_natives_Construct.__name__ = true;
class runtime_natives_Context_$q {
	static call(word) {
		let tmp = word.context.value;
		if(tmp != null) {
			return tmp;
		} else {
			return types_None.NONE;
		}
	}
}
runtime_natives_Context_$q.__name__ = true;
class runtime_natives_Continue {
	static call() {
		throw new runtime_RedError(types_Error.create({ code : 3, type : "throw", id : "continue"}));
	}
}
runtime_natives_Continue.__name__ = true;
class runtime_natives_Dehex {
	static call(value) {
		return types_String.fromString(decodeURIComponent(value.toJs()));
	}
}
runtime_natives_Dehex.__name__ = true;
class runtime_natives_Does {
	static call(body) {
		return new types_Function(null,new types_Block([]),null,[],[],null,body.copy());
	}
}
runtime_natives_Does.__name__ = true;
class runtime_natives_Either {
	static call(cond,trueBlk,falseBlk) {
		return runtime_natives_Do.evalValues(cond.isTruthy() ? new util__$Series__$Series(trueBlk.values,trueBlk.index) : new util__$Series__$Series(falseBlk.values,falseBlk.index));
	}
}
runtime_natives_Either.__name__ = true;
class runtime_natives_Enhex {
	static call(value) {
		return types_String.fromString(encodeURIComponent(value.toJs()));
	}
}
runtime_natives_Enhex.__name__ = true;
class runtime_natives_Exit {
	static call() {
		throw new runtime_RedError(types_Error.create({ code : 1, type : "throw", id : "return"}));
	}
}
runtime_natives_Exit.__name__ = true;
class types_Map extends Value {
	constructor(values) {
		super();
		this.values = values;
	}
	find(key,cmp) {
		if(cmp == null) {
			cmp = 0;
		}
		key = types_Map.preprocessKey(key);
		let _g = this.values.findIndex(function(k,i) {
			if(i % 2 == 0) {
				return runtime_Actions.compare(k,key,cmp).cond;
			} else {
				return false;
			}
		});
		if(_g == -1) {
			return null;
		} else {
			return _g;
		}
	}
	get(key,cmp) {
		if(cmp == null) {
			cmp = 0;
		}
		key = types_Map.preprocessKey(key);
		let _g = this.values.findIndex(function(k,i) {
			if(i % 2 == 0) {
				return runtime_Actions.compare(k,key,cmp).cond;
			} else {
				return false;
			}
		});
		if(_g == -1) {
			return null;
		} else {
			return this.values[_g + 1];
		}
	}
	set(key,value,cmp) {
		if(cmp == null) {
			cmp = 0;
		}
		key = types_Map.preprocessKey(key);
		let _g = this.values.findIndex(function(k,i) {
			if(i % 2 == 0) {
				return runtime_Actions.compare(k,key,cmp).cond;
			} else {
				return false;
			}
		});
		if(_g == -1) {
			this.values.push(key);
			this.values.push(value);
		} else {
			this.values[_g + 1] = value;
		}
	}
	get_TYPE_KIND() {
		return 36;
	}
	static preprocessKey(key) {
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		let _hx_tmp4;
		if(((key) instanceof types_SetWord) == true) {
			return key;
		} else {
			_hx_tmp4 = ((key) instanceof types_Word);
			if(_hx_tmp4 == true) {
				let __anon0__w = key;
				let w = __anon0__w;
				return new types_SetWord(w.symbol);
			} else {
				_hx_tmp3 = ((key) instanceof types_LitWord);
				if(_hx_tmp3 == true) {
					let __anon0__w = key;
					let w = __anon0__w;
					return new types_SetWord(w.symbol);
				} else {
					_hx_tmp2 = ((key) instanceof types_GetWord);
					if(_hx_tmp2 == true) {
						let __anon0__w = key;
						let w = __anon0__w;
						return new types_SetWord(w.symbol);
					} else {
						_hx_tmp1 = ((key) instanceof types_Binary);
						if(_hx_tmp1 == true) {
							let __anon0__b = key;
							let b = __anon0__b;
							return b.copy();
						} else {
							_hx_tmp = ((key) instanceof types_base__$String);
							if(_hx_tmp == true) {
								let __anon0__s = key;
								let s = __anon0__s;
								return s.copy();
							} else {
								switch(key.get_TYPE_KIND()) {
								case 9:case 10:case 11:case 16:case 17:case 27:case 28:case 33:case 34:case 35:case 38:case 41:case 42:
									return key;
								default:
									throw haxe_Exception.thrown("Invalid key value!");
								}
							}
						}
					}
				}
			}
		}
	}
}
types_Map.__name__ = true;
types_Map.__super__ = Value;
Object.assign(types_Map.prototype, {
	__class__: types_Map
});
class types_Hash extends types_base__$Block {
	constructor(values,index,newlines) {
		super(values,index,newlines);
	}
	cloneBlock(values,index,newlines) {
		return new types_Hash(values,index,newlines);
	}
	get_TYPE_KIND() {
		return 32;
	}
	clone(values,index) {
		return js_Boot.__cast(super.clone(values,index) , types_Hash);
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_Hash);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_Hash);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_Hash);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_Hash);
	}
	head() {
		return js_Boot.__cast(super.head() , types_Hash);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_Hash);
	}
}
types_Hash.__name__ = true;
types_Hash.__super__ = types_base__$Block;
Object.assign(types_Hash.prototype, {
	__class__: types_Hash
});
class runtime_natives_Extend {
	static call(obj,spec,options) {
		let ignoreCase = !options._case;
		let op = options._case ? 2 : 0;
		let _hx_tmp;
		if(((obj) instanceof types_Map) == true) {
			let __anon0__map = obj;
			let map = __anon0__map;
			let _hx_tmp;
			let _hx_tmp1;
			if(((spec) instanceof types_Block) == true) {
				let __anon0__b = spec;
				let b = __anon0__b;
				let length = b.values.length - b.index & -2;
				let _g = 0;
				let _g1 = length;
				while(_g < _g1) {
					let i = _g++;
					if(i % 2 == 0) {
						map.set(b.wrap(b.values[b.index + i]),b.wrap(b.values[b.index + (i + 1)]));
					}
				}
			} else {
				_hx_tmp1 = ((spec) instanceof types_Hash);
				if(_hx_tmp1 == true) {
					let __anon0__b = spec;
					let b = __anon0__b;
					let length = b.values.length - b.index & -2;
					let _g = 0;
					let _g1 = length;
					while(_g < _g1) {
						let i = _g++;
						if(i % 2 == 0) {
							map.set(b.wrap(b.values[b.index + i]),b.wrap(b.values[b.index + (i + 1)]));
						}
					}
				} else {
					_hx_tmp = ((spec) instanceof types_Map);
					if(_hx_tmp == true) {
						let __anon0__m = spec;
						let m = __anon0__m;
						let i = 0;
						while(i < m.values.length) {
							map.set(m.values[i],m.values[i + 1],op);
							i += 2;
						}
					} else {
						throw haxe_Exception.thrown("Invalid value!");
					}
				}
			}
		} else {
			_hx_tmp = ((obj) instanceof types_Object);
			if(_hx_tmp == true) {
				let __anon0__obj = obj;
				let obj1 = __anon0__obj;
				throw haxe_Exception.thrown("NYI!");
			} else {
				throw haxe_Exception.thrown("Invalid value!");
			}
		}
		return obj;
	}
}
runtime_natives_Extend.__name__ = true;
class runtime_natives_Forall {
	static call(word,body) {
		let saved = word.get();
		let series = js_Boot.__cast(saved , types_base__$SeriesOf);
		while(!series.isTail()) {
			try {
				runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index));
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g);
				if(((_g1) instanceof runtime_RedError)) {
					let e = _g1;
					if(e.error.isContinue()) {
						continue;
					} else if(e.error.isBreak()) {
						word.set(saved);
						return e.error.ctx.get("arg1",true);
					} else {
						word.set(saved);
						throw e;
					}
				} else {
					throw _g;
				}
			}
			series = series.skip(1);
			word.set(series);
		}
		word.set(saved);
		return types_None.NONE;
	}
}
runtime_natives_Forall.__name__ = true;
class runtime_natives_Foreach {
	static call(word,series,body) {
		let words;
		let _hx_tmp;
		if(((word) instanceof types_Word) == true) {
			let __anon0__word = word;
			let word1 = __anon0__word;
			words = [word1];
		} else {
			_hx_tmp = ((word) instanceof types_Block);
			if(_hx_tmp == true) {
				let __anon0__block = word;
				let block = __anon0__block;
				if(block.values.length - block.index == 0) {
					throw haxe_Exception.thrown("block length must not be zero!");
				} else {
					let _g = [];
					let _gthis = block;
					let _this = block.values.slice(block.index);
					let result = new Array(_this.length);
					let _g1 = 0;
					let _g2 = _this.length;
					while(_g1 < _g2) {
						let i = _g1++;
						result[i] = _gthis.wrap(_this[i]);
					}
					let _g_current = 0;
					let _g_array = result;
					while(_g_current < _g_array.length) {
						let value = _g_array[_g_current++];
						_g.push(js_Boot.__cast(value , types_Word));
					}
					words = _g;
				}
			} else {
				throw haxe_Exception.thrown("error!");
			}
		}
		switch(words.length) {
		case 1:
			if(js_Boot.__implements(series,types_base_ISeriesOf) == true) {
				let word = words[0];
				let __anon0__series = series;
				let series1 = __anon0__series;
				let value = series1.iterator();
				while(value.hasNext()) {
					let value1 = value.next();
					word.set(value1);
					try {
						runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index));
					} catch( _g ) {
						let _g1 = haxe_Exception.caught(_g);
						if(((_g1) instanceof runtime_RedError)) {
							let e = _g1;
							if(e.error.isContinue()) {
								continue;
							} else if(e.error.isBreak()) {
								let ignoreCase = true;
								if(ignoreCase == null) {
									ignoreCase = true;
								}
								return e.error.ctx.get("arg1",ignoreCase);
							} else {
								throw e;
							}
						} else {
							throw _g;
						}
					}
				}
			} else {
				throw haxe_Exception.thrown("error!");
			}
			break;
		case 2:
			let _hx_tmp1;
			if(((series) instanceof types_Map) == true) {
				let key = words[0];
				let value = words[1];
				let __anon0__map = series;
				let map = __anon0__map;
				let i = 0;
				while(i < map.values.length) {
					key.set(map.values[i]);
					value.set(map.values[i + 1]);
					try {
						runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index));
					} catch( _g ) {
						let _g1 = haxe_Exception.caught(_g);
						if(((_g1) instanceof runtime_RedError)) {
							let e = _g1;
							if(e.error.isContinue()) {
								continue;
							} else if(e.error.isBreak()) {
								let ignoreCase = true;
								if(ignoreCase == null) {
									ignoreCase = true;
								}
								return e.error.ctx.get("arg1",ignoreCase);
							} else {
								throw e;
							}
						} else {
							throw _g;
						}
					}
					i += 2;
				}
			} else {
				_hx_tmp1 = js_Boot.__implements(series,types_base_ISeriesOf);
				if(_hx_tmp1 == true) {
					let __anon0__series = series;
					if(words.length > 0) {
						let series = __anon0__series;
						while(!series.isTail()) {
							let _g = 0;
							while(_g < words.length) {
								let word = words[_g];
								++_g;
								let tmp = series.pick(0);
								word.set(tmp != null ? tmp : types_None.NONE);
								series = series.skip(1);
							}
							try {
								runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index));
							} catch( _g ) {
								let _g1 = haxe_Exception.caught(_g);
								if(((_g1) instanceof runtime_RedError)) {
									let e = _g1;
									if(e.error.isContinue()) {
										continue;
									} else if(e.error.isBreak()) {
										let ignoreCase = true;
										if(ignoreCase == null) {
											ignoreCase = true;
										}
										return e.error.ctx.get("arg1",ignoreCase);
									} else {
										throw e;
									}
								} else {
									throw _g;
								}
							}
						}
					} else {
						throw haxe_Exception.thrown("error!");
					}
				} else {
					throw haxe_Exception.thrown("error!");
				}
			}
			break;
		default:
			if(js_Boot.__implements(series,types_base_ISeriesOf) == true) {
				let __anon0__series = series;
				if(words.length > 0) {
					let series = __anon0__series;
					while(!series.isTail()) {
						let _g = 0;
						while(_g < words.length) {
							let word = words[_g];
							++_g;
							let tmp = series.pick(0);
							word.set(tmp != null ? tmp : types_None.NONE);
							series = series.skip(1);
						}
						try {
							runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index));
						} catch( _g ) {
							let _g1 = haxe_Exception.caught(_g);
							if(((_g1) instanceof runtime_RedError)) {
								let e = _g1;
								if(e.error.isContinue()) {
									continue;
								} else if(e.error.isBreak()) {
									let ignoreCase = true;
									if(ignoreCase == null) {
										ignoreCase = true;
									}
									return e.error.ctx.get("arg1",ignoreCase);
								} else {
									throw e;
								}
							} else {
								throw _g;
							}
						}
					}
				} else {
					throw haxe_Exception.thrown("error!");
				}
			} else {
				throw haxe_Exception.thrown("error!");
			}
		}
		return types_None.NONE;
	}
}
runtime_natives_Foreach.__name__ = true;
class runtime_natives_Forever {
	static call(body) {
		while(true) try {
			runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index));
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g);
			if(((_g1) instanceof runtime_RedError)) {
				let e = _g1;
				if(e.error.isContinue()) {
					continue;
				} else if(e.error.isBreak()) {
					return e.error.ctx.get("arg1",true);
				} else {
					throw e;
				}
			} else {
				throw _g;
			}
		}
	}
}
runtime_natives_Forever.__name__ = true;
class types_base__$Param {
	constructor(name,quoting,spec,doc) {
		this.doc = null;
		this.spec = null;
		this.name = name;
		this.quoting = quoting;
		if(spec != null) {
			this.spec = spec;
		}
		if(doc != null) {
			this.doc = doc;
		}
	}
}
types_base__$Param.__name__ = true;
Object.assign(types_base__$Param.prototype, {
	__class__: types_base__$Param
});
class types_base__$Refine {
	constructor(name,doc,params) {
		this.params = [];
		this.doc = null;
		this.name = name;
		if(doc != null) {
			this.doc = doc;
		}
		if(params != null) {
			this.params = params;
		}
	}
}
types_base__$Refine.__name__ = true;
Object.assign(types_base__$Refine.prototype, {
	__class__: types_base__$Refine
});
class runtime_natives_Func {
	static parseSpec(spec) {
		let res = { doc : null, params : [], refines : [], ret : null};
		spec = spec.copy();
		let _g = spec.pick(0);
		if(((_g) instanceof types_String) == true) {
			let __anon0__s = _g;
			let s = __anon0__s;
			spec.index++;
			res.doc = s.toJs();
		}
		let params = res.params;
		while(true) {
			let _g = spec.pick(0);
			let _hx_tmp;
			let _hx_tmp1;
			if(((_g) instanceof types_Word) == true) {
				let __anon0__w = _g;
				let w = __anon0__w;
				spec.index++;
				let _g1 = w.symbol.name;
				let _g2;
				switch(w.get_TYPE_KIND()) {
				case 12:
					_g2 = types_base_QuotingKind.QVal;
					break;
				case 15:
					_g2 = types_base_QuotingKind.QGet;
					break;
				default:
					_g2 = types_base_QuotingKind.QLit;
				}
				let _g3;
				let _g4 = spec.pick(0);
				if(((_g4) instanceof types_Block) == true) {
					let __anon0__b = _g4;
					let b = __anon0__b;
					spec.index++;
					_g3 = b.copy();
				} else {
					_g3 = null;
				}
				let _g5 = spec.pick(0);
				let tmp;
				if(((_g5) instanceof types_String) == true) {
					let __anon0__s = _g5;
					let s = __anon0__s;
					spec.index++;
					tmp = s.toJs();
				} else {
					tmp = null;
				}
				params.push(new types_base__$Param(_g1,_g2,_g3,tmp));
			} else {
				_hx_tmp1 = ((_g) instanceof types_GetWord);
				if(_hx_tmp1 == true) {
					let __anon0__w = _g;
					let w = __anon0__w;
					spec.index++;
					let _g1 = w.symbol.name;
					let _g2;
					switch(w.get_TYPE_KIND()) {
					case 12:
						_g2 = types_base_QuotingKind.QVal;
						break;
					case 15:
						_g2 = types_base_QuotingKind.QGet;
						break;
					default:
						_g2 = types_base_QuotingKind.QLit;
					}
					let _g3;
					let _g4 = spec.pick(0);
					if(((_g4) instanceof types_Block) == true) {
						let __anon0__b = _g4;
						let b = __anon0__b;
						spec.index++;
						_g3 = b.copy();
					} else {
						_g3 = null;
					}
					let _g5 = spec.pick(0);
					let tmp;
					if(((_g5) instanceof types_String) == true) {
						let __anon0__s = _g5;
						let s = __anon0__s;
						spec.index++;
						tmp = s.toJs();
					} else {
						tmp = null;
					}
					params.push(new types_base__$Param(_g1,_g2,_g3,tmp));
				} else {
					_hx_tmp = ((_g) instanceof types_LitWord);
					if(_hx_tmp == true) {
						let __anon0__w = _g;
						let w = __anon0__w;
						spec.index++;
						let _g1 = w.symbol.name;
						let _g2;
						switch(w.get_TYPE_KIND()) {
						case 12:
							_g2 = types_base_QuotingKind.QVal;
							break;
						case 15:
							_g2 = types_base_QuotingKind.QGet;
							break;
						default:
							_g2 = types_base_QuotingKind.QLit;
						}
						let _g3;
						let _g4 = spec.pick(0);
						if(((_g4) instanceof types_Block) == true) {
							let __anon0__b = _g4;
							let b = __anon0__b;
							spec.index++;
							_g3 = b.copy();
						} else {
							_g3 = null;
						}
						let _g5 = spec.pick(0);
						let tmp;
						if(((_g5) instanceof types_String) == true) {
							let __anon0__s = _g5;
							let s = __anon0__s;
							spec.index++;
							tmp = s.toJs();
						} else {
							tmp = null;
						}
						params.push(new types_base__$Param(_g1,_g2,_g3,tmp));
					} else {
						break;
					}
				}
			}
		}
		let _g1 = spec.pick(0);
		let _hx_tmp;
		if(_g1 == null) {
			let _hx_tmp_b;
			let _hx_tmp_a;
			_hx_tmp = ((_g1) instanceof types_SetWord) ? _g1 : null;
			_hx_tmp_a = _hx_tmp != null;
			_hx_tmp_b = _hx_tmp;
			let _g = _hx_tmp_b;
			if(_hx_tmp_a == true) {
				let _hx_tmp;
				if(_g == null) {
					let _hx_tmp1;
					_hx_tmp = _g;
					_hx_tmp1 = _hx_tmp;
					if(_hx_tmp1.symbol.equalsString("return") == true) {
						spec.index++;
						let _g = spec.pick(0);
						if(((_g) instanceof types_Block) == true) {
							let __anon0__b = _g;
							let b = __anon0__b;
							spec.index++;
							res.ret = b.copy();
						} else {
							throw haxe_Exception.thrown("Missing return spec!");
						}
					}
				} else {
					let _hx_tmp1;
					_hx_tmp = _g;
					_hx_tmp1 = _hx_tmp;
					if(_hx_tmp1.symbol.equalsString("return") == true) {
						spec.index++;
						let _g = spec.pick(0);
						if(((_g) instanceof types_Block) == true) {
							let __anon0__b = _g;
							let b = __anon0__b;
							spec.index++;
							res.ret = b.copy();
						} else {
							throw haxe_Exception.thrown("Missing return spec!");
						}
					}
				}
			}
		} else {
			let _hx_tmp_b;
			let _hx_tmp_a;
			_hx_tmp = ((_g1) instanceof types_SetWord) ? _g1 : null;
			_hx_tmp_a = _hx_tmp != null;
			_hx_tmp_b = _hx_tmp;
			let _g = _hx_tmp_b;
			if(_hx_tmp_a == true) {
				let _hx_tmp;
				if(_g == null) {
					let _hx_tmp1;
					_hx_tmp = _g;
					_hx_tmp1 = _hx_tmp;
					if(_hx_tmp1.symbol.equalsString("return") == true) {
						spec.index++;
						let _g = spec.pick(0);
						if(((_g) instanceof types_Block) == true) {
							let __anon0__b = _g;
							let b = __anon0__b;
							spec.index++;
							res.ret = b.copy();
						} else {
							throw haxe_Exception.thrown("Missing return spec!");
						}
					}
				} else {
					let _hx_tmp1;
					_hx_tmp = _g;
					_hx_tmp1 = _hx_tmp;
					if(_hx_tmp1.symbol.equalsString("return") == true) {
						spec.index++;
						let _g = spec.pick(0);
						if(((_g) instanceof types_Block) == true) {
							let __anon0__b = _g;
							let b = __anon0__b;
							spec.index++;
							res.ret = b.copy();
						} else {
							throw haxe_Exception.thrown("Missing return spec!");
						}
					}
				}
			}
		}
		while(true) {
			let _g = spec.pick(0);
			if(((_g) instanceof types_Refinement) == true) {
				let __anon0__r = _g;
				let r = __anon0__r;
				spec.index++;
				let _g1 = r.symbol.name;
				let _g2 = spec.pick(0);
				let refine;
				if(((_g2) instanceof types_String) == true) {
					let __anon0__s = _g2;
					let s = __anon0__s;
					spec.index++;
					refine = s.toJs();
				} else {
					refine = null;
				}
				let refine1 = new types_base__$Refine(_g1,refine,null);
				let params = refine1.params;
				while(true) {
					let _g = spec.pick(0);
					let _hx_tmp;
					let _hx_tmp1;
					if(((_g) instanceof types_Word) == true) {
						let __anon0__w = _g;
						let w = __anon0__w;
						spec.index++;
						let _g1 = w.symbol.name;
						let _g2;
						switch(w.get_TYPE_KIND()) {
						case 12:
							_g2 = types_base_QuotingKind.QVal;
							break;
						case 15:
							_g2 = types_base_QuotingKind.QGet;
							break;
						default:
							_g2 = types_base_QuotingKind.QLit;
						}
						let _g3;
						let _g4 = spec.pick(0);
						if(((_g4) instanceof types_Block) == true) {
							let __anon0__b = _g4;
							let b = __anon0__b;
							spec.index++;
							_g3 = b.copy();
						} else {
							_g3 = null;
						}
						let _g5 = spec.pick(0);
						let tmp;
						if(((_g5) instanceof types_String) == true) {
							let __anon0__s = _g5;
							let s = __anon0__s;
							spec.index++;
							tmp = s.toJs();
						} else {
							tmp = null;
						}
						params.push(new types_base__$Param(_g1,_g2,_g3,tmp));
					} else {
						_hx_tmp1 = ((_g) instanceof types_GetWord);
						if(_hx_tmp1 == true) {
							let __anon0__w = _g;
							let w = __anon0__w;
							spec.index++;
							let _g1 = w.symbol.name;
							let _g2;
							switch(w.get_TYPE_KIND()) {
							case 12:
								_g2 = types_base_QuotingKind.QVal;
								break;
							case 15:
								_g2 = types_base_QuotingKind.QGet;
								break;
							default:
								_g2 = types_base_QuotingKind.QLit;
							}
							let _g3;
							let _g4 = spec.pick(0);
							if(((_g4) instanceof types_Block) == true) {
								let __anon0__b = _g4;
								let b = __anon0__b;
								spec.index++;
								_g3 = b.copy();
							} else {
								_g3 = null;
							}
							let _g5 = spec.pick(0);
							let tmp;
							if(((_g5) instanceof types_String) == true) {
								let __anon0__s = _g5;
								let s = __anon0__s;
								spec.index++;
								tmp = s.toJs();
							} else {
								tmp = null;
							}
							params.push(new types_base__$Param(_g1,_g2,_g3,tmp));
						} else {
							_hx_tmp = ((_g) instanceof types_LitWord);
							if(_hx_tmp == true) {
								let __anon0__w = _g;
								let w = __anon0__w;
								spec.index++;
								let _g1 = w.symbol.name;
								let _g2;
								switch(w.get_TYPE_KIND()) {
								case 12:
									_g2 = types_base_QuotingKind.QVal;
									break;
								case 15:
									_g2 = types_base_QuotingKind.QGet;
									break;
								default:
									_g2 = types_base_QuotingKind.QLit;
								}
								let _g3;
								let _g4 = spec.pick(0);
								if(((_g4) instanceof types_Block) == true) {
									let __anon0__b = _g4;
									let b = __anon0__b;
									spec.index++;
									_g3 = b.copy();
								} else {
									_g3 = null;
								}
								let _g5 = spec.pick(0);
								let tmp;
								if(((_g5) instanceof types_String) == true) {
									let __anon0__s = _g5;
									let s = __anon0__s;
									spec.index++;
									tmp = s.toJs();
								} else {
									tmp = null;
								}
								params.push(new types_base__$Param(_g1,_g2,_g3,tmp));
							} else {
								break;
							}
						}
					}
				}
				res.refines.push(refine1);
			} else {
				break;
			}
		}
		if(res.ret == null) {
			let _g = spec.pick(0);
			let _hx_tmp;
			if(_g == null) {
				let _hx_tmp_b;
				let _hx_tmp_a;
				_hx_tmp = ((_g) instanceof types_SetWord) ? _g : null;
				_hx_tmp_a = _hx_tmp != null;
				_hx_tmp_b = _hx_tmp;
				let _g1 = _hx_tmp_b;
				if(_hx_tmp_a == true) {
					let _hx_tmp;
					if(_g1 == null) {
						let _hx_tmp1;
						_hx_tmp = _g1;
						_hx_tmp1 = _hx_tmp;
						if(_hx_tmp1.symbol.equalsString("return") == true) {
							spec.index++;
							let _g = spec.pick(0);
							if(((_g) instanceof types_Block) == true) {
								let __anon0__b = _g;
								let b = __anon0__b;
								spec.index++;
								res.ret = b.copy();
							} else {
								throw haxe_Exception.thrown("Missing return spec!");
							}
						}
					} else {
						let _hx_tmp1;
						_hx_tmp = _g1;
						_hx_tmp1 = _hx_tmp;
						if(_hx_tmp1.symbol.equalsString("return") == true) {
							spec.index++;
							let _g = spec.pick(0);
							if(((_g) instanceof types_Block) == true) {
								let __anon0__b = _g;
								let b = __anon0__b;
								spec.index++;
								res.ret = b.copy();
							} else {
								throw haxe_Exception.thrown("Missing return spec!");
							}
						}
					}
				}
			} else {
				let _hx_tmp_b;
				let _hx_tmp_a;
				_hx_tmp = ((_g) instanceof types_SetWord) ? _g : null;
				_hx_tmp_a = _hx_tmp != null;
				_hx_tmp_b = _hx_tmp;
				let _g1 = _hx_tmp_b;
				if(_hx_tmp_a == true) {
					let _hx_tmp;
					if(_g1 == null) {
						let _hx_tmp1;
						_hx_tmp = _g1;
						_hx_tmp1 = _hx_tmp;
						if(_hx_tmp1.symbol.equalsString("return") == true) {
							spec.index++;
							let _g = spec.pick(0);
							if(((_g) instanceof types_Block) == true) {
								let __anon0__b = _g;
								let b = __anon0__b;
								spec.index++;
								res.ret = b.copy();
							} else {
								throw haxe_Exception.thrown("Missing return spec!");
							}
						}
					} else {
						let _hx_tmp1;
						_hx_tmp = _g1;
						_hx_tmp1 = _hx_tmp;
						if(_hx_tmp1.symbol.equalsString("return") == true) {
							spec.index++;
							let _g = spec.pick(0);
							if(((_g) instanceof types_Block) == true) {
								let __anon0__b = _g;
								let b = __anon0__b;
								spec.index++;
								res.ret = b.copy();
							} else {
								throw haxe_Exception.thrown("Missing return spec!");
							}
						}
					}
				}
			}
		}
		if(spec.values.length - spec.index != 0) {
			throw haxe_Exception.thrown("Invalid function spec!");
		}
		return res;
	}
	static call(spec,body) {
		let _g = runtime_natives_Func.parseSpec(spec);
		return new types_Function(null,spec,_g.doc,_g.params,_g.refines,_g.ret,body.copy());
	}
}
runtime_natives_Func.__name__ = true;
class runtime_natives_Get {
	static _getPath(value,path,ignoreCase) {
		while(true) if(path.values.length - path.index == 0) {
			return value;
		} else if(js_Boot.__implements(value,types_base_IGetPath)) {
			let value1 = path.pick(0);
			if(value1 == null) {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			let opt = (js_Boot.__cast(value , types_base_IGetPath)).getPath(((value1) instanceof types_Word) ? value1 : runtime_natives_Do.evalValue(value1),ignoreCase);
			let _gtmp;
			switch(opt[1]) {
			case 0:
				_gtmp = opt[2];
				break;
			case 1:
				throw haxe_Exception.thrown("Value was empty!");
			}
			value = _gtmp;
			path = path.skip(1);
			continue;
		} else {
			throw haxe_Exception.thrown("error!");
		}
	}
	static _tryGetPath(value,path,ignoreCase) {
		if(path.values.length - path.index == 0) {
			return haxe_ds_Option.Some(value);
		} else if(js_Boot.__implements(value,types_base_IGetPath)) {
			let _g = path.pick(0);
			let access = _g == null ? null : ((_g) instanceof types_Word) ? _g : runtime_natives_Do.evalValue(_g);
			let opt;
			let _hx_tmp;
			if(access == null) {
				opt = null;
			} else {
				_hx_tmp = access;
				opt = (js_Boot.__cast(value , types_base_IGetPath)).getPath(_hx_tmp,ignoreCase);
			}
			switch(opt[1]) {
			case 0:
				return runtime_natives_Get._tryGetPath(opt[2],path.skip(1),ignoreCase);
			case 1:
				return haxe_ds_Option.None;
			}
		} else {
			throw haxe_Exception.thrown("error!");
		}
	}
	static getPath(path,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let value = path.pick(0);
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return runtime_natives_Get._getPath(runtime_natives_Do.evalValue(value),path.skip(1),ignoreCase);
	}
	static tryGetPath(path,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let value = path.pick(0);
		if(value == null) {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		return runtime_natives_Get._tryGetPath(runtime_natives_Do.evalValue(value),path.skip(1),ignoreCase);
	}
	static call(word,options) {
		let _hx_tmp;
		let _hx_tmp1;
		if(((word) instanceof types_base__$AnyWord) == true) {
			let __anon0__s = word;
			let s = __anon0__s;
			if(options.any && options._case) {
				if(s.context.contains(s.symbol.name,false)) {
					return s.context.get(s.symbol.name,false);
				} else {
					return types_Unset.UNSET;
				}
			} else if(!options.any && options._case) {
				let _g = s.context.get(s.symbol.name,false);
				if(_g == types_Unset.UNSET) {
					throw haxe_Exception.thrown("Word `" + s.symbol.name + "` doesn't exist!");
				} else {
					let value = _g;
					return value;
				}
			} else {
				return s.get(options.any);
			}
		} else {
			_hx_tmp1 = ((word) instanceof types_base__$Path);
			if(_hx_tmp1 == true) {
				let __anon0__p = word;
				let p = __anon0__p;
				if(options.any) {
					let opt = runtime_natives_Get.tryGetPath(p,options._case);
					switch(opt[1]) {
					case 0:
						let v = opt[2];
						return v;
					case 1:
						return types_Unset.UNSET;
					}
				} else {
					return runtime_natives_Get.getPath(p,options._case);
				}
			} else {
				_hx_tmp = ((word) instanceof types_Object);
				if(_hx_tmp == true) {
					let __anon0__o = word;
					let o = __anon0__o;
					return new types_Block(o.ctx.values.slice());
				} else {
					throw haxe_Exception.thrown("Invalid type!");
				}
			}
		}
	}
}
runtime_natives_Get.__name__ = true;
class runtime_natives_Has {
	static call(locals,body) {
		locals = locals.copy();
		locals.values.unshift(new types_Refinement(runtime_Words.LOCAL));
		return runtime_natives_Func.call(locals,body);
	}
}
runtime_natives_Has.__name__ = true;
class runtime_natives_If {
	static call(cond,body) {
		if(cond.isTruthy()) {
			return runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index));
		} else {
			return types_None.NONE;
		}
	}
}
runtime_natives_If.__name__ = true;
class runtime_natives_In {
	static call(object,word) {
		let _g = object.ctx.offsetOfSymbol(word.symbol);
		if(_g == -1) {
			return types_None.NONE;
		} else {
			return word.copyFrom(object.ctx.symbols[_g]);
		}
	}
}
runtime_natives_In.__name__ = true;
class runtime_natives_Log2 {
	static call(value) {
		return new types_Float(Math.log2(value.asFloat()));
	}
}
runtime_natives_Log2.__name__ = true;
class runtime_natives_Log10 {
	static call(value) {
		return new types_Float(Math.log10(value.asFloat()));
	}
}
runtime_natives_Log10.__name__ = true;
class runtime_natives_LogE {
	static call(value) {
		return new types_Float(Math.log(value.asFloat()));
	}
}
runtime_natives_LogE.__name__ = true;
class runtime_natives_Exp {
	static call(value) {
		return new types_Float(Math.exp(value.asFloat()));
	}
}
runtime_natives_Exp.__name__ = true;
class runtime_natives_SquareRoot {
	static call(value) {
		return new types_Float(Math.sqrt(value.asFloat()));
	}
}
runtime_natives_SquareRoot.__name__ = true;
class runtime_natives_Loop {
	static call(times,body) {
		let n;
		let _hx_tmp;
		let _hx_tmp1 = ((times) instanceof types_base__$Integer) ? times : null;
		if(_hx_tmp1 == null) {
			_hx_tmp = ((times) instanceof types_base__$Float) ? times : null;
			let _g = _hx_tmp.get_TYPE_KIND();
			let f = _hx_tmp.float;
			n = f | 0;
		} else {
			let _g = _hx_tmp1.get_TYPE_KIND();
			let i = _hx_tmp1.int;
			n = i;
		}
		let _g = 0;
		let _g1 = n;
		while(_g < _g1) {
			let _ = _g++;
			try {
				runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index));
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g);
				if(((_g1) instanceof runtime_RedError)) {
					let e = _g1;
					if(e.error.isContinue()) {
						continue;
					} else if(e.error.isBreak()) {
						let ignoreCase = true;
						if(ignoreCase == null) {
							ignoreCase = true;
						}
						return e.error.ctx.get("arg1",ignoreCase);
					} else {
						throw e;
					}
				} else {
					throw _g;
				}
			}
		}
		return types_None.NONE;
	}
}
runtime_natives_Loop.__name__ = true;
function runtime_natives_MinMax_minmax(value1,value2,isMax) {
	let _hx_tmp;
	let _hx_tmp1 = ((value1) instanceof types_Pair) ? value1 : null;
	if(_hx_tmp1 == null) {
		_hx_tmp = ((value1) instanceof types_Tuple) ? value1 : null;
		if(_hx_tmp != null) {
			let _g = _hx_tmp.get_TYPE_KIND();
			let values1 = _hx_tmp.values;
			let res = values1.slice();
			let _hx_tmp1;
			let _hx_tmp2 = ((value2) instanceof types_Tuple) ? value2 : null;
			if(_hx_tmp2 == null) {
				_hx_tmp1 = ((value2) instanceof types_base__$Number);
				if(_hx_tmp1 == true) {
					let __anon0__num = value2;
					let num = __anon0__num;
					let n = num.asInt();
					let b = Math.max(0, Math.min(n, 255));
					if(isMax) {
						let _g = 0;
						let _g1 = res.length;
						while(_g < _g1) {
							let i = _g++;
							let v = res[i];
							if(v < b) {
								res[i] = b;
							}
						}
					} else {
						let _g = 0;
						let _g1 = res.length;
						while(_g < _g1) {
							let i = _g++;
							let v = res[i];
							if(v > b) {
								res[i] = b;
							}
						}
					}
					return new types_Tuple(res);
				}
			} else {
				let _g = _hx_tmp2.get_TYPE_KIND();
				let values2 = _hx_tmp2.values;
				if(res.length == values2.length) {
					if(isMax) {
						let _g = 0;
						let _g1 = res.length;
						while(_g < _g1) {
							let i = _g++;
							let v1 = res[i];
							let v2 = values2[i];
							if(v1 < v2) {
								res[i] = v2;
							}
						}
					} else {
						let _g = 0;
						let _g1 = res.length;
						while(_g < _g1) {
							let i = _g++;
							let v1 = res[i];
							let v2 = values2[i];
							if(v1 > v2) {
								res[i] = v2;
							}
						}
					}
					return new types_Tuple(res);
				} else {
					_hx_tmp1 = ((value2) instanceof types_base__$Number);
					if(_hx_tmp1 == true) {
						let __anon0__num = value2;
						let num = __anon0__num;
						let n = num.asInt();
						let b = Math.max(0, Math.min(n, 255));
						if(isMax) {
							let _g = 0;
							let _g1 = res.length;
							while(_g < _g1) {
								let i = _g++;
								let v = res[i];
								if(v < b) {
									res[i] = b;
								}
							}
						} else {
							let _g = 0;
							let _g1 = res.length;
							while(_g < _g1) {
								let i = _g++;
								let v = res[i];
								if(v > b) {
									res[i] = b;
								}
							}
						}
						return new types_Tuple(res);
					}
				}
			}
		}
	} else {
		let _g = _hx_tmp1.get_TYPE_KIND();
		let x1 = _hx_tmp1.x;
		let y1 = _hx_tmp1.y;
		let res = new types_Pair(x1,y1);
		let _hx_tmp;
		let _hx_tmp2 = ((value2) instanceof types_Pair) ? value2 : null;
		if(_hx_tmp2 == null) {
			_hx_tmp = ((value2) instanceof types_base__$Number);
			if(_hx_tmp == true) {
				let __anon0__num = value2;
				let num = __anon0__num;
				let i = num.asInt();
				if(isMax) {
					if(x1 < i) {
						res.x = i;
					}
					if(y1 < i) {
						res.y = i;
					}
				} else {
					if(x1 > i) {
						res.x = i;
					}
					if(y1 > i) {
						res.y = i;
					}
				}
				return res;
			}
		} else {
			let _g = _hx_tmp2.get_TYPE_KIND();
			let x2 = _hx_tmp2.x;
			let y2 = _hx_tmp2.y;
			if(isMax) {
				if(x1 < x2) {
					res.x = x2;
				}
				if(y1 < y2) {
					res.y = y2;
				}
			} else {
				if(x1 > x2) {
					res.x = x2;
				}
				if(y1 > y2) {
					res.y = y2;
				}
			}
			return res;
		}
	}
	if(runtime_Actions.compare(value1,value2,3).cond == isMax) {
		return value2;
	} else {
		return value1;
	}
}
class types_Tuple extends Value {
	constructor(values) {
		super();
		if(values.length < 3 || values.length > 12) {
			throw haxe_Exception.thrown("Invalid tuple!");
		} else {
			this.values = values;
		}
	}
	getPath(access,_) {
		let _hx_tmp = ((access) instanceof types_Integer) ? access : null;
		if(_hx_tmp == null) {
			return haxe_ds_Option.None;
		} else {
			let _g = _hx_tmp.get_TYPE_KIND();
			let i = _hx_tmp.int;
			if(1 <= i && i <= this.values.length) {
				return haxe_ds_Option.Some(new types_Integer(this.values[i - 1]));
			} else {
				return haxe_ds_Option.None;
			}
		}
	}
	get_TYPE_KIND() {
		return 35;
	}
}
types_Tuple.__name__ = true;
types_Tuple.__interfaces__ = [types_base_IGetPath];
types_Tuple.__super__ = Value;
Object.assign(types_Tuple.prototype, {
	__class__: types_Tuple
});
class runtime_natives_Min {
	static call(value1,value2) {
		return runtime_natives_MinMax_minmax(value1,value2,false);
	}
}
runtime_natives_Min.__name__ = true;
class runtime_natives_Max {
	static call(value1,value2) {
		return runtime_natives_MinMax_minmax(value1,value2,true);
	}
}
runtime_natives_Max.__name__ = true;
class runtime_natives_Nan_$q {
	static call(value) {
		let f = value.asFloat();
		if(isNaN(f)) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
}
runtime_natives_Nan_$q.__name__ = true;
class runtime_natives_Negative_$q {
	static call(value) {
		let cond;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2 = ((value) instanceof types_base__$Integer) ? value : null;
		if(_hx_tmp2 == null) {
			_hx_tmp1 = ((value) instanceof types_base__$Float) ? value : null;
			if(_hx_tmp1 == null) {
				_hx_tmp = ((value) instanceof types_Money);
				if(_hx_tmp == true) {
					let __anon0__m = value;
					let m = __anon0__m;
					throw haxe_Exception.thrown("NYI!");
				} else {
					throw haxe_Exception.thrown("bad");
				}
			} else {
				let _g = _hx_tmp1.get_TYPE_KIND();
				let f = _hx_tmp1.float;
				cond = f < 0.0;
			}
		} else {
			let _g = _hx_tmp2.get_TYPE_KIND();
			let i = _hx_tmp2.int;
			cond = i < 0;
		}
		if(cond) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
}
runtime_natives_Negative_$q.__name__ = true;
class runtime_natives_NewLine {
	static call(list,value,options) {
		let start = list.index;
		let cond = value.cond;
		if(cond) {
			list.addNewline(start);
		} else {
			list.removeNewline(start);
		}
		if(options.all || options.skip != null) {
			let end = list.values.length;
			let _g = options.skip;
			let step = _g == null ? 1 : _g.size.int;
			let i = start + step;
			while(i < end) {
				if(cond) {
					list.addNewline(i);
				} else {
					list.removeNewline(i);
				}
				i += step;
			}
		}
		return list;
	}
}
runtime_natives_NewLine.__name__ = true;
class runtime_natives_NewLine_$q {
	static call(list) {
		if(list.hasNewline(list.index)) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
}
runtime_natives_NewLine_$q.__name__ = true;
class runtime_natives_Not {
	static call(value) {
		if(!value.isTruthy()) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
}
runtime_natives_Not.__name__ = true;
class types_Date extends Value {
	constructor(date,zone) {
		super();
		this.date = date;
		this.zone = zone != null ? zone : new types_Time(date.getTimezoneOffset() * 60);
	}
	getDate() {
		return new types_Date(new Date(this.date.getFullYear(),this.date.getMonth(),this.date.getDate(),0,0,0));
	}
	getPath(access,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let _gthis = this;
		let opt;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2 = ((access) instanceof types_Integer) ? access : null;
		if(_hx_tmp2 == null) {
			_hx_tmp1 = ((access) instanceof types_Word) ? access : null;
			let _hx_tmp_a = _hx_tmp1 != null;
			let _hx_tmp_b = _hx_tmp1;
			let _g = _hx_tmp_b;
			if(_hx_tmp_a == true) {
				let _hx_tmp1;
				if(_g == null) {
					_hx_tmp1 = _g;
					let n = _hx_tmp1.symbol.name.toLowerCase();
					if(ignoreCase && types_Date.ACCESSORS.includes(n)) {
						opt = haxe_ds_Option.Some(haxe_ds_Either.Right(n));
					} else {
						_hx_tmp = ((access) instanceof types_Word) ? access : null;
						if(_hx_tmp == null) {
							opt = haxe_ds_Option.None;
						} else {
							let _g = _hx_tmp.get_TYPE_KIND();
							let _g1 = _hx_tmp.context;
							let _g2 = _hx_tmp.symbol;
							let _g3 = _hx_tmp.index;
							let _g4 = types_base_Symbol.INDEXES.get(_g2.name);
							let n = _g2.name;
							opt = !ignoreCase && types_Date.ACCESSORS.includes(n) ? haxe_ds_Option.Some(haxe_ds_Either.Right(n)) : haxe_ds_Option.None;
						}
					}
				} else {
					_hx_tmp1 = _g;
					let n = _hx_tmp1.symbol.name.toLowerCase();
					if(ignoreCase && types_Date.ACCESSORS.includes(n)) {
						opt = haxe_ds_Option.Some(haxe_ds_Either.Right(n));
					} else {
						_hx_tmp = ((access) instanceof types_Word) ? access : null;
						if(_hx_tmp == null) {
							opt = haxe_ds_Option.None;
						} else {
							let _g = _hx_tmp.get_TYPE_KIND();
							let _g1 = _hx_tmp.context;
							let _g2 = _hx_tmp.symbol;
							let _g3 = _hx_tmp.index;
							let _g4 = types_base_Symbol.INDEXES.get(_g2.name);
							let n = _g2.name;
							opt = !ignoreCase && types_Date.ACCESSORS.includes(n) ? haxe_ds_Option.Some(haxe_ds_Either.Right(n)) : haxe_ds_Option.None;
						}
					}
				}
			} else {
				_hx_tmp = ((access) instanceof types_Word) ? access : null;
				if(_hx_tmp == null) {
					opt = haxe_ds_Option.None;
				} else {
					let _g = _hx_tmp.get_TYPE_KIND();
					let _g1 = _hx_tmp.context;
					let _g2 = _hx_tmp.symbol;
					let _g3 = _hx_tmp.index;
					let _g4 = types_base_Symbol.INDEXES.get(_g2.name);
					let n = _g2.name;
					opt = !ignoreCase && types_Date.ACCESSORS.includes(n) ? haxe_ds_Option.Some(haxe_ds_Either.Right(n)) : haxe_ds_Option.None;
				}
			}
		} else {
			let _g = _hx_tmp2.get_TYPE_KIND();
			let i = _hx_tmp2.int;
			opt = haxe_ds_Option.Some(haxe_ds_Either.Left(i));
		}
		switch(opt[1]) {
		case 0:
			let v = opt[2];
			switch(v[1]) {
			case 0:
				switch(v[2]) {
				case 1:
					return haxe_ds_Option.Some(_gthis.getDate());
				case 2:
					return haxe_ds_Option.Some(new types_Integer(_gthis.date.getFullYear()));
				case 3:
					return haxe_ds_Option.Some(new types_Integer(_gthis.date.getMonth() + 1));
				case 4:
					return haxe_ds_Option.Some(new types_Integer(_gthis.date.getDate()));
				case 5:
					return haxe_ds_Option.Some(_gthis.zone);
				case 6:
					return haxe_ds_Option.Some(new types_Time(_gthis.date.getTime() / 1000));
				case 7:
					return haxe_ds_Option.Some(new types_Integer(_gthis.date.getHours()));
				case 8:
					return haxe_ds_Option.Some(new types_Integer(_gthis.date.getMinutes()));
				case 9:
					let sec = _gthis.date.getSeconds();
					return haxe_ds_Option.Some(sec % 1 == 0 ? new types_Integer(sec) : new types_Float(sec));
				case 10:
					return haxe_ds_Option.Some(new types_Integer(_gthis.date.getDay() + 1));
				case 11:
					return haxe_ds_Option.Some(null);
				case 12:
					return haxe_ds_Option.Some(null);
				case 13:
					return haxe_ds_Option.Some(null);
				case 14:
					return haxe_ds_Option.Some(null);
				default:
					return haxe_ds_Option.None;
				}
				break;
			case 1:
				switch(v[2]) {
				case "date":
					return haxe_ds_Option.Some(_gthis.getDate());
				case "day":
					return haxe_ds_Option.Some(new types_Integer(_gthis.date.getDate()));
				case "hour":
					return haxe_ds_Option.Some(new types_Integer(_gthis.date.getHours()));
				case "isoweek":
					return haxe_ds_Option.Some(null);
				case "julian":case "yearday":
					return haxe_ds_Option.Some(null);
				case "minute":
					return haxe_ds_Option.Some(new types_Integer(_gthis.date.getMinutes()));
				case "month":
					return haxe_ds_Option.Some(new types_Integer(_gthis.date.getMonth() + 1));
				case "second":
					let sec1 = _gthis.date.getSeconds();
					return haxe_ds_Option.Some(sec1 % 1 == 0 ? new types_Integer(sec1) : new types_Float(sec1));
				case "time":
					return haxe_ds_Option.Some(new types_Time(_gthis.date.getTime() / 1000));
				case "timezone":
					return haxe_ds_Option.Some(null);
				case "week":
					return haxe_ds_Option.Some(null);
				case "weekday":
					return haxe_ds_Option.Some(new types_Integer(_gthis.date.getDay() + 1));
				case "year":
					return haxe_ds_Option.Some(new types_Integer(_gthis.date.getFullYear()));
				case "zone":
					return haxe_ds_Option.Some(_gthis.zone);
				default:
					return haxe_ds_Option.None;
				}
				break;
			}
			break;
		case 1:
			return haxe_ds_Option.None;
		}
	}
	get_TYPE_KIND() {
		return 41;
	}
}
types_Date.__name__ = true;
types_Date.__interfaces__ = [types_base_IGetPath];
types_Date.__super__ = Value;
Object.assign(types_Date.prototype, {
	__class__: types_Date
});
class types_Time extends types_base__$Float {
	constructor(float) {
		super(float);
	}
	make(value) {
		return new types_Time(value);
	}
	getPath(access,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let _hx_tmp;
		let _hx_tmp1 = ((access) instanceof types_Integer) ? access : null;
		if(_hx_tmp1 == null) {
			_hx_tmp = ((access) instanceof types_Word) ? access : null;
			let _hx_tmp_a = _hx_tmp != null;
			let _hx_tmp_b = _hx_tmp;
			let _g = _hx_tmp_b;
			if(_hx_tmp_a == true) {
				let _hx_tmp;
				if(_g == null) {
					let _hx_tmp1;
					let _hx_tmp2;
					_hx_tmp = _g;
					let _hx_tmp3 = _hx_tmp;
					if(_hx_tmp3.symbol.equalsString("hour",ignoreCase) == true) {
						return haxe_ds_Option.Some(new types_Integer(this.float < 0 ? Math.ceil(this.float / 3600) : Math.floor(this.float / 3600)));
					} else {
						_hx_tmp2 = _hx_tmp3.symbol.equalsString("minute",ignoreCase);
						if(_hx_tmp2 == true) {
							return haxe_ds_Option.Some(new types_Integer(Math.floor(Math.abs(this.float) / 60) % 60));
						} else {
							_hx_tmp1 = _hx_tmp3.symbol.equalsString("second",ignoreCase);
							if(_hx_tmp1 == true) {
								return haxe_ds_Option.Some(new types_Float(this.float % 60));
							} else {
								return haxe_ds_Option.None;
							}
						}
					}
				} else {
					let _hx_tmp1;
					let _hx_tmp2;
					_hx_tmp = _g;
					let _hx_tmp3 = _hx_tmp;
					if(_hx_tmp3.symbol.equalsString("hour",ignoreCase) == true) {
						return haxe_ds_Option.Some(new types_Integer(this.float < 0 ? Math.ceil(this.float / 3600) : Math.floor(this.float / 3600)));
					} else {
						_hx_tmp2 = _hx_tmp3.symbol.equalsString("minute",ignoreCase);
						if(_hx_tmp2 == true) {
							return haxe_ds_Option.Some(new types_Integer(Math.floor(Math.abs(this.float) / 60) % 60));
						} else {
							_hx_tmp1 = _hx_tmp3.symbol.equalsString("second",ignoreCase);
							if(_hx_tmp1 == true) {
								return haxe_ds_Option.Some(new types_Float(this.float % 60));
							} else {
								return haxe_ds_Option.None;
							}
						}
					}
				}
			} else {
				return haxe_ds_Option.None;
			}
		} else {
			let _g = _hx_tmp1.get_TYPE_KIND();
			switch(_hx_tmp1.int) {
			case 1:
				return haxe_ds_Option.Some(new types_Integer(this.float < 0 ? Math.ceil(this.float / 3600) : Math.floor(this.float / 3600)));
			case 2:
				_hx_tmp = ((access) instanceof types_Word) ? access : null;
				let _hx_tmp_a = _hx_tmp != null;
				let _hx_tmp_b = _hx_tmp;
				let _g1 = _hx_tmp_b;
				if(_hx_tmp_a == true) {
					let _hx_tmp;
					if(_g1 == null) {
						_hx_tmp = _g1;
						if(_hx_tmp.symbol.equalsString("hour",ignoreCase) == true) {
							return haxe_ds_Option.Some(new types_Integer(this.float < 0 ? Math.ceil(this.float / 3600) : Math.floor(this.float / 3600)));
						} else {
							return haxe_ds_Option.Some(new types_Integer(Math.floor(Math.abs(this.float) / 60) % 60));
						}
					} else {
						_hx_tmp = _g1;
						if(_hx_tmp.symbol.equalsString("hour",ignoreCase) == true) {
							return haxe_ds_Option.Some(new types_Integer(this.float < 0 ? Math.ceil(this.float / 3600) : Math.floor(this.float / 3600)));
						} else {
							return haxe_ds_Option.Some(new types_Integer(Math.floor(Math.abs(this.float) / 60) % 60));
						}
					}
				} else {
					return haxe_ds_Option.Some(new types_Integer(Math.floor(Math.abs(this.float) / 60) % 60));
				}
				break;
			case 3:
				_hx_tmp = ((access) instanceof types_Word) ? access : null;
				let _hx_tmp_a1 = _hx_tmp != null;
				let _hx_tmp_b1 = _hx_tmp;
				let _g2 = _hx_tmp_b1;
				if(_hx_tmp_a1 == true) {
					let _hx_tmp;
					if(_g2 == null) {
						let _hx_tmp1;
						_hx_tmp = _g2;
						let _hx_tmp2 = _hx_tmp;
						if(_hx_tmp2.symbol.equalsString("hour",ignoreCase) == true) {
							return haxe_ds_Option.Some(new types_Integer(this.float < 0 ? Math.ceil(this.float / 3600) : Math.floor(this.float / 3600)));
						} else {
							_hx_tmp1 = _hx_tmp2.symbol.equalsString("minute",ignoreCase);
							if(_hx_tmp1 == true) {
								return haxe_ds_Option.Some(new types_Integer(Math.floor(Math.abs(this.float) / 60) % 60));
							} else {
								return haxe_ds_Option.Some(new types_Float(this.float % 60));
							}
						}
					} else {
						let _hx_tmp1;
						_hx_tmp = _g2;
						let _hx_tmp2 = _hx_tmp;
						if(_hx_tmp2.symbol.equalsString("hour",ignoreCase) == true) {
							return haxe_ds_Option.Some(new types_Integer(this.float < 0 ? Math.ceil(this.float / 3600) : Math.floor(this.float / 3600)));
						} else {
							_hx_tmp1 = _hx_tmp2.symbol.equalsString("minute",ignoreCase);
							if(_hx_tmp1 == true) {
								return haxe_ds_Option.Some(new types_Integer(Math.floor(Math.abs(this.float) / 60) % 60));
							} else {
								return haxe_ds_Option.Some(new types_Float(this.float % 60));
							}
						}
					}
				} else {
					return haxe_ds_Option.Some(new types_Float(this.float % 60));
				}
				break;
			default:
				_hx_tmp = ((access) instanceof types_Word) ? access : null;
				let _hx_tmp_a2 = _hx_tmp != null;
				let _hx_tmp_b2 = _hx_tmp;
				let _g3 = _hx_tmp_b2;
				if(_hx_tmp_a2 == true) {
					let _hx_tmp;
					if(_g3 == null) {
						let _hx_tmp1;
						let _hx_tmp2;
						_hx_tmp = _g3;
						let _hx_tmp3 = _hx_tmp;
						if(_hx_tmp3.symbol.equalsString("hour",ignoreCase) == true) {
							return haxe_ds_Option.Some(new types_Integer(this.float < 0 ? Math.ceil(this.float / 3600) : Math.floor(this.float / 3600)));
						} else {
							_hx_tmp2 = _hx_tmp3.symbol.equalsString("minute",ignoreCase);
							if(_hx_tmp2 == true) {
								return haxe_ds_Option.Some(new types_Integer(Math.floor(Math.abs(this.float) / 60) % 60));
							} else {
								_hx_tmp1 = _hx_tmp3.symbol.equalsString("second",ignoreCase);
								if(_hx_tmp1 == true) {
									return haxe_ds_Option.Some(new types_Float(this.float % 60));
								} else {
									return haxe_ds_Option.None;
								}
							}
						}
					} else {
						let _hx_tmp1;
						let _hx_tmp2;
						_hx_tmp = _g3;
						let _hx_tmp3 = _hx_tmp;
						if(_hx_tmp3.symbol.equalsString("hour",ignoreCase) == true) {
							return haxe_ds_Option.Some(new types_Integer(this.float < 0 ? Math.ceil(this.float / 3600) : Math.floor(this.float / 3600)));
						} else {
							_hx_tmp2 = _hx_tmp3.symbol.equalsString("minute",ignoreCase);
							if(_hx_tmp2 == true) {
								return haxe_ds_Option.Some(new types_Integer(Math.floor(Math.abs(this.float) / 60) % 60));
							} else {
								_hx_tmp1 = _hx_tmp3.symbol.equalsString("second",ignoreCase);
								if(_hx_tmp1 == true) {
									return haxe_ds_Option.Some(new types_Float(this.float % 60));
								} else {
									return haxe_ds_Option.None;
								}
							}
						}
					}
				} else {
					return haxe_ds_Option.None;
				}
			}
		}
	}
	get_TYPE_KIND() {
		return 38;
	}
}
types_Time.__name__ = true;
types_Time.__interfaces__ = [types_base_IGetPath];
types_Time.__super__ = types_base__$Float;
Object.assign(types_Time.prototype, {
	__class__: types_Time
});
class runtime_natives_Now {
	static call(options) {
		let date = new Date();
		let res = new types_Date(date);
		if(options.utc) {
			res.zone.float = 0.0;
			res.date = new Date(res.date.getTime() + res.date.getTimezoneOffset() * 60.0 * 1000.0);
		}
		if(!options.precise) {
			res.date.setMilliseconds(0);
		}
		if(options.year) {
			return new types_Integer(res.date.getFullYear());
		} else if(options.month) {
			return new types_Integer(res.date.getMonth() + 1);
		} else if(options.day) {
			return new types_Integer(res.date.getDate());
		} else if(options.time) {
			return new types_Time(res.date.getTime() / 1000);
		} else if(options.zone) {
			return res.zone;
		} else if(options.date) {
			return res.getDate();
		} else if(options.weekday) {
			return new types_Integer(res.date.getDay() + 1);
		} else if(options.yearday) {
			runtime_actions_datatypes_DateActions.getYearday(res.date);
		}
		return res;
	}
}
runtime_natives_Now.__name__ = true;
class runtime_natives_Positive_$q {
	static call(value) {
		let cond;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2 = ((value) instanceof types_base__$Integer) ? value : null;
		if(_hx_tmp2 == null) {
			_hx_tmp1 = ((value) instanceof types_base__$Float) ? value : null;
			if(_hx_tmp1 == null) {
				_hx_tmp = ((value) instanceof types_Money);
				if(_hx_tmp == true) {
					let __anon0__m = value;
					let m = __anon0__m;
					throw haxe_Exception.thrown("NYI!");
				} else {
					throw haxe_Exception.thrown("bad");
				}
			} else {
				let _g = _hx_tmp1.get_TYPE_KIND();
				let f = _hx_tmp1.float;
				cond = f > 0.0;
			}
		} else {
			let _g = _hx_tmp2.get_TYPE_KIND();
			let i = _hx_tmp2.int;
			cond = i > 0;
		}
		if(cond) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
}
runtime_natives_Positive_$q.__name__ = true;
class runtime_natives_Prin {
	static call(value) {
		let tmp = runtime_actions_Form.call(value,runtime_actions_Form.defaultOptions).toJs();
		RedJS.prinHandler(tmp);
		return types_Unset.UNSET;
	}
}
runtime_natives_Prin.__name__ = true;
class runtime_natives_Reduce {
	static call(value,options) {
		if(options.into != null == true) {
			throw haxe_Exception.thrown("NYI!");
		}
		if(((value) instanceof types_Block) == true) {
			let __anon0__block = value;
			let block = __anon0__block;
			let values = [];
			let tokens = new util__$Series__$Series(block.values,block.index);
			while(tokens.offset < tokens.values.length) {
				let g;
				/*;
				g = */ //;
				[g, tokens] = runtime_natives_Do.groupNextExpr(tokens);
				values.push(runtime_natives_Do.evalGroupedExpr(g));
			}
			return new types_Block(values);
		} else {
			return runtime_natives_Do.evalValue(value);
		}
	}
}
runtime_natives_Reduce.__name__ = true;
class runtime_natives_Print {
	static call(value) {
		let tmp = runtime_actions_Form.call(((value) instanceof types_Block) ? runtime_natives_Reduce.call(value,runtime_natives_Reduce.defaultOptions) : value,runtime_actions_Form.defaultOptions).toJs();
		RedJS.printHandler(tmp);
		return types_Unset.UNSET;
	}
}
runtime_natives_Print.__name__ = true;
class runtime_natives_RemoveEach {
	static call(word,data,body) {
		let words;
		let _hx_tmp;
		if(((word) instanceof types_Word) == true) {
			let __anon0__word = word;
			let word1 = __anon0__word;
			words = [word1];
		} else {
			_hx_tmp = ((word) instanceof types_Block);
			if(_hx_tmp == true) {
				let __anon0__block = word;
				let block = __anon0__block;
				if(block.values.length - block.index == 0) {
					throw haxe_Exception.thrown("block length must not be zero!");
				} else {
					let _g = [];
					let _gthis = block;
					let _this = block.values.slice(block.index);
					let result = new Array(_this.length);
					let _g1 = 0;
					let _g2 = _this.length;
					while(_g1 < _g2) {
						let i = _g1++;
						result[i] = _gthis.wrap(_this[i]);
					}
					let _g_current = 0;
					let _g_array = result;
					while(_g_current < _g_array.length) {
						let value = _g_array[_g_current++];
						_g.push(js_Boot.__cast(value , types_Word));
					}
					words = _g;
				}
			} else {
				throw haxe_Exception.thrown("error!");
			}
		}
		let series = js_Boot.__cast(data , types_base_ISeriesOf);
		if(words.length == 1) {
			let word = words[0];
			let value = series.iterator();
			while(value.hasNext()) {
				let value1 = value.next();
				word.set(value1);
				try {
					if(runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index)).isTruthy()) {
						series.remove();
					}
				} catch( _g ) {
					let _g1 = haxe_Exception.caught(_g);
					if(((_g1) instanceof runtime_RedError)) {
						let e = _g1;
						if(e.error.isContinue()) {
							continue;
						} else if(e.error.isBreak()) {
							let ignoreCase = true;
							if(ignoreCase == null) {
								ignoreCase = true;
							}
							return e.error.ctx.get("arg1",ignoreCase);
						} else {
							throw e;
						}
					} else {
						throw _g;
					}
				}
			}
		} else {
			while(!series.isTail()) {
				let count = 0;
				let _g = 0;
				while(_g < words.length) {
					let word = words[_g];
					++_g;
					let tmp = series.pick(count);
					word.set(tmp != null ? tmp : types_None.NONE);
					++count;
				}
				try {
					if(runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index)).isTruthy()) {
						series.removePart(count);
					} else {
						series = series.skip(count);
					}
				} catch( _g ) {
					let _g1 = haxe_Exception.caught(_g);
					if(((_g1) instanceof runtime_RedError)) {
						let e = _g1;
						if(e.error.isContinue()) {
							continue;
						} else if(e.error.isBreak()) {
							let ignoreCase = true;
							if(ignoreCase == null) {
								ignoreCase = true;
							}
							return e.error.ctx.get("arg1",ignoreCase);
						} else {
							throw e;
						}
					} else {
						throw _g;
					}
				}
			}
		}
		return types_None.NONE;
	}
}
runtime_natives_RemoveEach.__name__ = true;
class runtime_natives_Repeat {
	static call(word,times,body) {
		let n;
		let _hx_tmp;
		let _hx_tmp1 = ((times) instanceof types_base__$Integer) ? times : null;
		if(_hx_tmp1 == null) {
			_hx_tmp = ((times) instanceof types_base__$Float) ? times : null;
			let _g = _hx_tmp.get_TYPE_KIND();
			let f = _hx_tmp.float;
			n = f | 0;
		} else {
			let _g = _hx_tmp1.get_TYPE_KIND();
			let i = _hx_tmp1.int;
			n = i;
		}
		let _g = 0;
		let _g1 = n;
		while(_g < _g1) {
			let i = _g++;
			try {
				word.set(new types_Integer(i + 1));
				runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index));
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g);
				if(((_g1) instanceof runtime_RedError)) {
					let e = _g1;
					if(e.error.isContinue()) {
						continue;
					} else if(e.error.isBreak()) {
						let ignoreCase = true;
						if(ignoreCase == null) {
							ignoreCase = true;
						}
						return e.error.ctx.get("arg1",ignoreCase);
					} else {
						throw e;
					}
				} else {
					throw _g;
				}
			}
		}
		return types_None.NONE;
	}
}
runtime_natives_Repeat.__name__ = true;
class runtime_natives_Return {
	static call(value) {
		throw new runtime_RedError(types_Error.create({ code : 1, type : "throw", id : "return", arg1 : value}));
	}
}
runtime_natives_Return.__name__ = true;
class runtime_natives_Set {
	static setMany_anon_iterator_func__Iterator_types_base__AnyWord(symbols,value,any,only,some) {
		if(!(value == types_None.NONE && some)) {
			if(!only) {
				let _hx_tmp;
				let _hx_tmp1;
				if(((value) instanceof types_base__$Block) == true) {
					let __anon0__b = value;
					let b = __anon0__b;
					runtime_natives_Set._setMany_setMany_Iter_types_base__Block(symbols,b,any,some);
				} else {
					_hx_tmp1 = ((value) instanceof types_base__$Path);
					if(_hx_tmp1 == true) {
						let __anon0__p = value;
						let p = __anon0__p;
						runtime_natives_Set._setMany_setMany_Iter_types_base__Path(symbols,p,any,some);
					} else {
						_hx_tmp = ((value) instanceof types_Map);
						if(_hx_tmp == true) {
							let __anon0__m = value;
							let m = __anon0__m;
							runtime_natives_Set._setMany_setMany_Iter_Array_types_Value(symbols,m.values.flatMap(function(k,i) {
								return [k,m.values[i]];
							}),any,some);
						} else {
							let s = $getIterator(symbols);
							while(s.hasNext()) {
								let s1 = s.next();
								s1.set(value);
							}
						}
					}
				}
			} else {
				let s = $getIterator(symbols);
				while(s.hasNext()) {
					let s1 = s.next();
					s1.set(value);
				}
			}
		}
	}
	static setMany_Array_types_base__AnyWord(symbols,value,any,only,some) {
		if(!(value == types_None.NONE && some)) {
			if(!only) {
				let _hx_tmp;
				let _hx_tmp1;
				if(((value) instanceof types_base__$Block) == true) {
					let __anon0__b = value;
					let b = __anon0__b;
					runtime_natives_Set._setMany_setMany_Iter_types_base__Block(symbols,b,any,some);
				} else {
					_hx_tmp1 = ((value) instanceof types_base__$Path);
					if(_hx_tmp1 == true) {
						let __anon0__p = value;
						let p = __anon0__p;
						runtime_natives_Set._setMany_setMany_Iter_types_base__Path(symbols,p,any,some);
					} else {
						_hx_tmp = ((value) instanceof types_Map);
						if(_hx_tmp == true) {
							let __anon0__m = value;
							let m = __anon0__m;
							runtime_natives_Set._setMany_setMany_Iter_Array_types_Value(symbols,m.values.flatMap(function(k,i) {
								return [k,m.values[i]];
							}),any,some);
						} else {
							let _g_current = 0;
							let _g_array = symbols;
							while(_g_current < _g_array.length) {
								let s = _g_array[_g_current++];
								s.set(value);
							}
						}
					}
				}
			} else {
				let _g_current = 0;
				let _g_array = symbols;
				while(_g_current < _g_array.length) {
					let s = _g_array[_g_current++];
					s.set(value);
				}
			}
		}
	}
	static _setMany_setMany_Iter_Array_types_Value(symbols,values,any,some) {
		let syms = $getIterator(symbols);
		let vals_current = 0;
		if(any) {
			if(some) {
				while(syms.hasNext() && vals_current < values.length) {
					let _g = values[vals_current++];
					if(_g != types_None.NONE) {
						syms.next().set(_g);
					}
				}
			} else {
				while(syms.hasNext() && vals_current < values.length) syms.next().set(values[vals_current++]);
				while(syms.hasNext()) syms.next().set(types_None.NONE);
			}
		} else if(some) {
			while(syms.hasNext() && vals_current < values.length) {
				let _g = values[vals_current++];
				switch(_g) {
				case types_None.NONE:
					break;
				case types_Unset.UNSET:
					throw haxe_Exception.thrown("Expected a value!");
				default:
					syms.next().set(_g);
				}
			}
		} else {
			while(syms.hasNext() && vals_current < values.length) {
				let _g = values[vals_current++];
				if(_g == types_Unset.UNSET) {
					throw haxe_Exception.thrown("Expected a value!");
				} else {
					syms.next().set(_g);
				}
			}
			while(syms.hasNext()) syms.next().set(types_None.NONE);
		}
	}
	static _setMany_setMany_Iter_types_base__Path(symbols,values,any,some) {
		let syms = $getIterator(symbols);
		let _gthis = values;
		let _this = values.values.slice(values.index);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _gthis.wrap(_this[i]);
		}
		let vals_current = 0;
		if(any) {
			if(some) {
				while(syms.hasNext() && vals_current < result.length) {
					let _g = result[vals_current++];
					if(_g != types_None.NONE) {
						syms.next().set(_g);
					}
				}
			} else {
				while(syms.hasNext() && vals_current < result.length) syms.next().set(result[vals_current++]);
				while(syms.hasNext()) syms.next().set(types_None.NONE);
			}
		} else if(some) {
			while(syms.hasNext() && vals_current < result.length) {
				let _g = result[vals_current++];
				switch(_g) {
				case types_None.NONE:
					break;
				case types_Unset.UNSET:
					throw haxe_Exception.thrown("Expected a value!");
				default:
					syms.next().set(_g);
				}
			}
		} else {
			while(syms.hasNext() && vals_current < result.length) {
				let _g = result[vals_current++];
				if(_g == types_Unset.UNSET) {
					throw haxe_Exception.thrown("Expected a value!");
				} else {
					syms.next().set(_g);
				}
			}
			while(syms.hasNext()) syms.next().set(types_None.NONE);
		}
	}
	static _setMany_setMany_Iter_types_base__Block(symbols,values,any,some) {
		let syms = $getIterator(symbols);
		let _gthis = values;
		let _this = values.values.slice(values.index);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _gthis.wrap(_this[i]);
		}
		let vals_current = 0;
		if(any) {
			if(some) {
				while(syms.hasNext() && vals_current < result.length) {
					let _g = result[vals_current++];
					if(_g != types_None.NONE) {
						syms.next().set(_g);
					}
				}
			} else {
				while(syms.hasNext() && vals_current < result.length) syms.next().set(result[vals_current++]);
				while(syms.hasNext()) syms.next().set(types_None.NONE);
			}
		} else if(some) {
			while(syms.hasNext() && vals_current < result.length) {
				let _g = result[vals_current++];
				switch(_g) {
				case types_None.NONE:
					break;
				case types_Unset.UNSET:
					throw haxe_Exception.thrown("Expected a value!");
				default:
					syms.next().set(_g);
				}
			}
		} else {
			while(syms.hasNext() && vals_current < result.length) {
				let _g = result[vals_current++];
				if(_g == types_Unset.UNSET) {
					throw haxe_Exception.thrown("Expected a value!");
				} else {
					syms.next().set(_g);
				}
			}
			while(syms.hasNext()) syms.next().set(types_None.NONE);
		}
	}
	static _getPathUptoEnd(value,path,ignoreCase) {
		while(true) if(path.values.length - path.index == 1) {
			let value1 = path.pick(0);
			if(value1 == null) {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			return { value : value, access : ((value1) instanceof types_Word) ? value1 : runtime_natives_Do.evalValue(value1)};
		} else if(js_Boot.__implements(value,types_base_IGetPath)) {
			let value1 = path.pick(0);
			if(value1 == null) {
				throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
			}
			let opt = (js_Boot.__cast(value , types_base_IGetPath)).getPath(((value1) instanceof types_Word) ? value1 : runtime_natives_Do.evalValue(value1),ignoreCase);
			let _gtmp;
			switch(opt[1]) {
			case 0:
				_gtmp = opt[2];
				break;
			case 1:
				throw haxe_Exception.thrown("Value was empty!");
			}
			value = _gtmp;
			path = path.skip(1);
			continue;
		} else {
			throw haxe_Exception.thrown("error!");
		}
	}
	static setPath(path,newValue,ignoreCase) {
		if(ignoreCase == null) {
			ignoreCase = true;
		}
		let value = path.pick(0);
		let _g;
		if(value != null) {
			_g = value;
		} else {
			throw new util_errors_NullException(null,null,{ fileName : "src/Util.hx", lineNumber : 385, className : "Util", methodName : "nonNull"});
		}
		let _g1 = runtime_natives_Set._getPathUptoEnd(runtime_natives_Do.evalValue(_g),path.skip(1),ignoreCase);
		let _g2 = _g1.value;
		if(js_Boot.__implements(_g2,types_base_ISetPath) == true) {
			let access = _g1.access;
			let __anon0__value = _g2;
			let value = __anon0__value;
			if(value.setPath(access,newValue,ignoreCase)) {
				return newValue;
			} else {
				throw haxe_Exception.thrown("error!");
			}
		} else {
			throw haxe_Exception.thrown("error!");
		}
	}
	static call(word,value,options) {
		if(value == types_Unset.UNSET && !options.any) {
			throw haxe_Exception.thrown("Expected a value!");
		}
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		if(((word) instanceof types_base__$AnyWord) == true) {
			let __anon0__s = word;
			let s = __anon0__s;
			s.set(value);
		} else {
			_hx_tmp2 = ((word) instanceof types_base__$Path);
			if(_hx_tmp2 == true) {
				let __anon0__p = word;
				let p = __anon0__p;
				runtime_natives_Set.setPath(p,value,options._case);
			} else {
				_hx_tmp1 = ((word) instanceof types_Block);
				if(_hx_tmp1 == true) {
					let __anon0__b = word;
					let b = __anon0__b;
					let _g = [];
					let _gthis = b;
					let _this = b.values.slice(b.index);
					let result = new Array(_this.length);
					let _g1 = 0;
					let _g2 = _this.length;
					while(_g1 < _g2) {
						let i = _g1++;
						result[i] = _gthis.wrap(_this[i]);
					}
					let _g_current = 0;
					let _g_array = result;
					while(_g_current < _g_array.length) {
						let s = _g_array[_g_current++];
						_g.push(js_Boot.__cast(s , types_base__$AnyWord));
					}
					runtime_natives_Set.setMany_Array_types_base__AnyWord(_g,value,options.any,options.only,options.some);
				} else {
					_hx_tmp = ((word) instanceof types_Object);
					if(_hx_tmp == true) {
						let __anon0__o = word;
						let o = __anon0__o;
						runtime_natives_Set.setMany_anon_iterator_func__Iterator_types_base__AnyWord(o.ctx.symbols,value,options.any,options.only,options.some);
					} else {
						throw haxe_Exception.thrown("Invalid type!");
					}
				}
			}
		}
		return value;
	}
}
runtime_natives_Set.__name__ = true;
function runtime_natives_SetOp_doSetOp(value1,value2,op,options) {
	let step;
	let _g = options.skip;
	if(_g == null) {
		step = 1;
	} else {
		let _g1 = _g.size;
		let _g2 = _g1.get_TYPE_KIND();
		let size = _g1.int;
		if(size <= 0) {
			throw haxe_Exception.thrown("invalid size");
		} else {
			step = size;
		}
	}
	let isCase = options._case;
	if(op != 8 && value1.constructor != value2.constructor) {
		throw haxe_Exception.thrown("invalid type");
	}
	let _hx_tmp;
	let _hx_tmp1;
	let _hx_tmp2;
	let _hx_tmp3;
	let _hx_tmp4;
	if(((value1) instanceof types_Block) == true) {
		let __anon0__b = value1;
		let b = __anon0__b;
		throw haxe_Exception.thrown("todo");
	} else {
		_hx_tmp4 = ((value1) instanceof types_Hash);
		if(_hx_tmp4 == true) {
			let __anon0__b = value1;
			let b = __anon0__b;
			throw haxe_Exception.thrown("todo");
		} else {
			_hx_tmp3 = ((value1) instanceof types_String);
			if(_hx_tmp3 == true) {
				let __anon0__s = value1;
				let s = __anon0__s;
				throw haxe_Exception.thrown("todo");
			} else {
				_hx_tmp2 = ((value1) instanceof types_Bitset);
				if(_hx_tmp2 == true) {
					let __anon0__b = value1;
					let b = __anon0__b;
					throw haxe_Exception.thrown("todo");
				} else {
					_hx_tmp1 = ((value1) instanceof types_Typeset);
					if(_hx_tmp1 == true) {
						let __anon0__t = value1;
						let t = __anon0__t;
						return runtime_actions_datatypes_TypesetActions.doBitwise(t,value2,op);
					} else {
						_hx_tmp = ((value1) instanceof types_Date);
						if(_hx_tmp == true) {
							let __anon0__d = value1;
							let d = __anon0__d;
							if(op != 12) {
								throw haxe_Exception.thrown("invalid type");
							}
							throw haxe_Exception.thrown("todo");
						} else {
							throw haxe_Exception.thrown("invalid type");
						}
					}
				}
			}
		}
	}
}
class util__$Set__$Set {
	static filter(this1,cond) {
		let _g = [];
		let jsIterator = this1.values();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			if(cond(v)) {
				_g.push(v);
			}
		}
		return new Set(_g);
	}
	static map(this1,fn) {
		let _g = [];
		let jsIterator = this1.values();
		let _g_lastStep = jsIterator.next();
		while(!_g_lastStep.done) {
			let v = _g_lastStep.value;
			_g_lastStep = jsIterator.next();
			_g.push(fn(v));
		}
		return new Set(_g);
	}
}
class runtime_natives_Union {
	static call(value1,value2,options) {
		return runtime_natives_SetOp_doSetOp(value1,value2,9,options);
	}
}
runtime_natives_Union.__name__ = true;
class runtime_natives_Intersect {
	static call(value1,value2,options) {
		return runtime_natives_SetOp_doSetOp(value1,value2,10,options);
	}
}
runtime_natives_Intersect.__name__ = true;
class runtime_natives_Unique {
	static call(value,options) {
		return runtime_natives_SetOp_doSetOp(value,value,8,options);
	}
}
runtime_natives_Unique.__name__ = true;
class runtime_natives_Difference {
	static call(value1,value2,options) {
		return runtime_natives_SetOp_doSetOp(value1,value2,12,options);
	}
}
runtime_natives_Difference.__name__ = true;
class runtime_natives_Exclude {
	static call(value1,value2,options) {
		return runtime_natives_SetOp_doSetOp(value1,value2,11,options);
	}
}
runtime_natives_Exclude.__name__ = true;
class runtime_natives_Shift {
	static call(data,bits,options) {
		return new types_Integer(options.left ? data.int << bits.int : options.logical ? data.int >>> bits.int : data.int >> bits.int);
	}
}
runtime_natives_Shift.__name__ = true;
class runtime_natives_Sign_$q {
	static call(value) {
		let _hx_tmp;
		let _hx_tmp1;
		let tmp;
		if(((value) instanceof types_base__$Integer) == true) {
			let __anon0__i = value;
			let i = __anon0__i;
			tmp = Math.sign(i.int);
		} else {
			_hx_tmp1 = ((value) instanceof types_base__$Float);
			if(_hx_tmp1 == true) {
				let __anon0__f = value;
				let f = __anon0__f;
				tmp = Math.sign(f.float);
			} else {
				_hx_tmp = ((value) instanceof types_Money);
				if(_hx_tmp == true) {
					let __anon0__m = value;
					let m = __anon0__m;
					throw haxe_Exception.thrown("NYI!");
				} else {
					throw haxe_Exception.thrown("bad");
				}
			}
		}
		return new types_Integer(tmp);
	}
}
runtime_natives_Sign_$q.__name__ = true;
class runtime_natives_Switch {
	static call(value,cases,options) {
		let len = cases.values.length - cases.index;
		let kind = value.get_TYPE_KIND();
		let i = 0;
		while(i < len) {
			let v = cases.wrap(cases.values[cases.index + i]);
			switch(v.get_TYPE_KIND()) { //;
			case 4: break;
			case kind: //;
			if(runtime_Actions.compare(value,v,0).cond) {
				/*;
				let blk = null;
				*/ let blk;
				do {
				if(++i >= len) {
					return types_None.NONE;
				}
				} while((blk = cases.wrap(cases.values[cases.index + i])).get_TYPE_KIND() != 4);
				let series = blk;
				return runtime_natives_Do.evalValues(new util__$Series__$Series(series.values,series.index));
			}
			}
			++i;
		}
		let _g = options._default;
		if(_g == null) {
			return types_None.NONE;
		} else {
			let _case = _g._case;
			return runtime_natives_Do.evalValues(new util__$Series__$Series(_case.values,_case.index));
		}
	}
}
runtime_natives_Switch.__name__ = true;
class runtime_natives_Throw {
	static call(value,options) {
		let tmp = types_Error.create({ code : 2, type : "throw", id : "throw", arg1 : value});
		let tmp1 = options.name;
		throw new runtime_RedError(tmp,tmp1 != null ? tmp1.word : null);
	}
}
runtime_natives_Throw.__name__ = true;
class runtime_natives_ToHex {
	static call(value,options) {
		let int = value.int;
		let length;
		let _g = options.size;
		if(_g == null) {
			length = 8;
		} else {
			let l = _g.length.int;
			if(l < 0) {
				throw haxe_Exception.thrown("error!");
			}
			length = l;
		}
		let hex = int.toString(16).toUpperCase().padStart(length, '0');
		return new types_Issue(types_base_Symbol.make(hex));
	}
}
runtime_natives_ToHex.__name__ = true;
class types_Binary extends types_base__$String {
	constructor(values,index) {
		super(values,index);
	}
	clone(values,index) {
		return new types_Binary(values,index);
	}
	get_TYPE_KIND() {
		return 37;
	}
	at(index) {
		return js_Boot.__cast(super.at(index) , types_Binary);
	}
	skip(index) {
		return js_Boot.__cast(super.skip(index) , types_Binary);
	}
	fastSkipHead(index) {
		return js_Boot.__cast(super.fastSkipHead(index) , types_Binary);
	}
	copy() {
		return js_Boot.__cast(super.copy() , types_Binary);
	}
	head() {
		return js_Boot.__cast(super.head() , types_Binary);
	}
	tail() {
		return js_Boot.__cast(super.tail() , types_Binary);
	}
}
types_Binary.__name__ = true;
types_Binary.__super__ = types_base__$String;
Object.assign(types_Binary.prototype, {
	__class__: types_Binary
});
class tokenizer_Actions {
	static anyWord(rdr) {
		if(rdr.matchesRx(tokenizer_Regexps.word)) {
			return rdr.matchRx(tokenizer_Regexps.word)[0];
		} else if(rdr.matchesRx(tokenizer_Regexps.specialWord)) {
			return rdr.matchRx(tokenizer_Regexps.specialWord)[0];
		} else {
			throw haxe_Exception.thrown("Error while parsing word! at " + rdr.getLocStr());
		}
	}
	static integer(rdr) {
		return Util.mustParseInt(rdr.matchRx(tokenizer_Regexps.integer)[0]);
	}
	static float(rdr) {
		return parseFloat(rdr.matchRx(tokenizer_Regexps.float)[0]);
	}
	static specialFloat(rdr) {
		let match = rdr.tryMatchRx(tokenizer_Regexps.nanFloat);
		if(match != null) {
			return NaN;
		} else {
			match = rdr.tryMatchRx(tokenizer_Regexps.infFloat);
			if(match != null) {
				if(match[1] == "-") {
					return -Infinity;
				} else {
					return Infinity;
				}
			} else {
				return null;
			}
		}
	}
	static number(rdr) {
		let match = rdr.tryMatchRx(tokenizer_Regexps.integer);
		if(match != null) {
			return Util.mustParseInt(match[0]);
		} else {
			match = rdr.tryMatchRx(tokenizer_Regexps.float);
			if(match != null) {
				return parseFloat(match[0]);
			} else {
				return tokenizer_Actions.specialFloat(rdr);
			}
		}
	}
	static point(rdr) {
		let tmp = tokenizer_Actions.number(rdr);
		if(tmp == null) {
			throw haxe_Exception.thrown("Invalid float literal!");
		}
		rdr.matchRx(tokenizer_Regexps.pointComma);
		let tmp1 = tokenizer_Actions.number(rdr);
		if(tmp1 == null) {
			throw haxe_Exception.thrown("Invalid float literal!");
		}
		if(rdr.tryMatchRx(tokenizer_Regexps.pointComma) != null) {
			let tmp2 = tokenizer_Actions.number(rdr);
			if(tmp2 == null) {
				throw haxe_Exception.thrown("Invalid float literal!");
			}
			rdr.trimSpace();
			rdr.match(")");
			return tokenizer_Token.TPoint3D(tmp,tmp1,tmp2);
		} else {
			rdr.trimSpace();
			rdr.match(")");
			return tokenizer_Token.TPoint2D(tmp,tmp1);
		}
	}
	static word(rdr,word) {
		if(rdr.tryMatch(":")) {
			return tokenizer_Token.TSetWord(word);
		} else if(rdr.peek() == "/") {
			let path = tokenizer_Actions.path(rdr,tokenizer_Token.TWord(word));
			if(rdr.tryMatch(":")) {
				return tokenizer_Token.TSetPath(path);
			} else {
				return tokenizer_Token.TPath(path);
			}
		} else if(rdr.tryMatch("@")) {
			let match = Tokenizer.matchRxWithGuardRx(rdr,tokenizer_RegexpChecks.word,tokenizer_Regexps.word);
			if(match != null) {
				return tokenizer_Token.TEmail(word + "@" + match[0]);
			} else {
				throw haxe_Exception.thrown("Invalid email!");
			}
		} else {
			return tokenizer_Token.TWord(word);
		}
	}
	static path(rdr,head) {
		let out = [head];
		while(rdr.tryMatch("/")) {
			let tmp;
			if(rdr.matches(tokenizer_RegexpChecks.paren)) {
				tmp = tokenizer_Token.TParen(tokenizer_Actions.delim(rdr,"paren!","(",")"));
			} else if(tokenizer_Checks.anyWord(rdr)) {
				tmp = tokenizer_Token.TWord(tokenizer_Actions.anyWord(rdr));
			} else if(rdr.matchesRx(tokenizer_RegexpChecks.integer)) {
				tmp = tokenizer_Token.TInteger(tokenizer_Actions.integer(rdr));
			} else if(rdr.matchesRx(tokenizer_RegexpChecks.float)) {
				tmp = tokenizer_Token.TFloat(tokenizer_Actions.float(rdr));
			} else if(rdr.matchesRx(tokenizer_RegexpChecks.specialFloat)) {
				tmp = tokenizer_Token.TFloat(tokenizer_Actions.specialFloat(rdr));
			} else if(rdr.tryMatch("'")) {
				if(tokenizer_Checks.anyWord(rdr)) {
					tmp = tokenizer_Token.TWord(tokenizer_Actions.anyWord(rdr));
				} else {
					throw haxe_Exception.thrown("Error while parsing path! at " + rdr.getLocStr() + " (debug: 1)");
				}
			} else if(rdr.tryMatch(":")) {
				if(tokenizer_Checks.anyWord(rdr)) {
					tmp = tokenizer_Token.TGetWord(tokenizer_Actions.anyWord(rdr));
				} else {
					throw haxe_Exception.thrown("Error while parsing path! at " + rdr.getLocStr() + " (debug: 2)");
				}
			} else {
				throw haxe_Exception.thrown("Error while parsing path! at " + rdr.getLocStr() + " (debug: 3)");
			}
			out.push(tmp);
		}
		return out;
	}
	static date(match) {
		let day;
		let month;
		let year;
		let date;
		if(tokenizer_DateMatch_isDDMMMY(match)) {
			day = +match.date_ddmmmy_dd;
			if(match.date_ddmmmy_mmm_m != null) {
				month = +match.date_ddmmmy_mmm_m;
			} else if(match.date_ddmmmy_mmm_mon != null) {
				month = tokenizer_DateMatch_getMonth(match.date_ddmmmy_mmm_mon) + 1;
			} else if(match.date_ddmmmy_mmm_month != null) {
				month = tokenizer_DateMatch_getMonth(match.date_ddmmmy_mmm_month) + 1;
			} else {
				throw haxe_Exception.thrown("Error 1!");
			}
			if(match.date_ddmmmy_yyyy != null) {
				year = +match.date_ddmmmy_yyyy;
			} else if(match.date_ddmmmy_yy != null) {
				year = +match.date_ddmmmy_yy;
				year += year > 50 ? 1900 : 2000;
			} else {
				throw haxe_Exception.thrown("Error 2!");
			}
			date = tokenizer_DateKind.YYYYMDD(year,month,day);
		} else if(tokenizer_DateMatch_isYYYYMMMDD(match)) {
			day = +match.date_yyyymmmdd_dd;
			if(match.date_yyyymmmdd_mmm_m != null) {
				month = +match.date_yyyymmmdd_mmm_m;
			} else if(match.date_yyyymmmdd_mmm_mon != null) {
				month = tokenizer_DateMatch_getMonth(match.date_yyyymmmdd_mmm_mon) + 1;
			} else if(match.date_yyyymmmdd_mmm_month != null) {
				month = tokenizer_DateMatch_getMonth(match.date_yyyymmmdd_mmm_month) + 1;
			} else {
				throw haxe_Exception.thrown("Error 3!");
			}
			if(match.date_yyyymmmdd_yyyy != null) {
				year = +match.date_yyyymmmdd_yyyy;
			} else {
				throw haxe_Exception.thrown("Error 4!");
			}
			date = tokenizer_DateKind.YYYYMDD(year,month,day);
		} else if(tokenizer_DateMatch_isYYYYDDD(match)) {
			date = tokenizer_DateKind.YYYYDDD(+match.date_yyyyddd_yyyy,+match.date_yyyyddd_ddd);
		} else if(tokenizer_DateMatch_isYYYYW(match)) {
			date = tokenizer_DateKind.YYYYWWD(+match.date_yyyyW_yyyy,+match.date_yyyyW_ww,match.date_yyyyW_d == null ? 1 : +match.date_yyyyW_d);
		} else if(tokenizer_DateMatch_isDateT(match)) {
			date = tokenizer_DateKind.YYYYMDD(+match.dateT_yyyy,+match.dateT_mm,+match.dateT_dd);
		} else {
			throw haxe_Exception.thrown("Error 5!");
		}
		let time;
		if(match.time != null) {
			if(tokenizer_DateMatch_isHMS(match)) {
				time = tokenizer_TimeKind.HMS(+match.time_hms_hour,+match.time_hms_min,match.time_hms_sec == null ? 0 : +match.time_hms_sec);
			} else if(tokenizer_DateMatch_isHHMM(match)) {
				time = tokenizer_TimeKind.HHMM(+match.time_hhmm * 100);
			} else if(tokenizer_DateMatch_isHHMMSS(match)) {
				let ms = match.time_hhmmss_dec == null ? 0 : +("" + match.time_hhmmss_dec);
				time = tokenizer_TimeKind.HHMMSS(+match.time_hhmmss_hhmmss,ms);
			} else {
				throw haxe_Exception.thrown("Error 6!");
			}
		} else {
			time = null;
		}
		let zone;
		if(match.zone != null) {
			if(tokenizer_DateMatch_isZoneHM15(match)) {
				zone = tokenizer_ZoneKind.ZoneHM15(match.zone_sign,+match.zone_hm15_hour,+match.zone_hm15_min15);
			} else if(tokenizer_DateMatch_isZoneHHMM(match)) {
				zone = tokenizer_ZoneKind.ZoneHHMM(match.zone_sign,+match.zone_hhmm);
			} else if(tokenizer_DateMatch_isZoneHour(match)) {
				zone = tokenizer_ZoneKind.ZoneHour(match.zone_sign,+match.zone_hour);
			} else {
				throw haxe_Exception.thrown("Error 7!");
			}
		} else {
			zone = null;
		}
		return tokenizer_Token.TDate(date,time,zone);
	}
	static delim(rdr,name,start,stop) {
		rdr.match(start);
		let out = [];
		rdr.trimSpace();
		while(!rdr.matches(stop)) {
			if(rdr.eof()) {
				throw haxe_Exception.thrown("Error while parsing " + name + " at " + rdr.getLocStr());
			}
			out.push(tokenizer_Actions.makeNext(rdr));
		}
		rdr.match(stop);
		return out;
	}
}
tokenizer_Actions.__name__ = true;
class tokenizer_Regexps {
}
tokenizer_Regexps.__name__ = true;
var tokenizer_Token = { __ename__:true,__constructs__:["TWord","TGetWord","TSetWord","TLitWord","TPath","TGetPath","TSetPath","TLitPath","TInteger","TFloat","TPercent","TMoney","TChar","TString","TRawString","TFile","TEmail","TUrl","TIssue","TRefinement","TTag","TRef","TBinary","TBlock","TParen","TMap","TTuple","TPair","TPoint2D","TPoint3D","TDate","TTime","TConstruct"] };
tokenizer_Token.TWord = function(word) { var $x = ["TWord",0,word]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TGetWord = function(word) { var $x = ["TGetWord",1,word]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TSetWord = function(word) { var $x = ["TSetWord",2,word]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TLitWord = function(word) { var $x = ["TLitWord",3,word]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TPath = function(path) { var $x = ["TPath",4,path]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TGetPath = function(path) { var $x = ["TGetPath",5,path]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TSetPath = function(path) { var $x = ["TSetPath",6,path]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TLitPath = function(path) { var $x = ["TLitPath",7,path]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TInteger = function(int) { var $x = ["TInteger",8,int]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TFloat = function(float) { var $x = ["TFloat",9,float]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TPercent = function(percent) { var $x = ["TPercent",10,percent]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TMoney = function(money,region) { var $x = ["TMoney",11,money,region]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TChar = function(char) { var $x = ["TChar",12,char]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TString = function(string) { var $x = ["TString",13,string]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TRawString = function(string) { var $x = ["TRawString",14,string]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TFile = function(file) { var $x = ["TFile",15,file]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TEmail = function(email) { var $x = ["TEmail",16,email]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TUrl = function(url) { var $x = ["TUrl",17,url]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TIssue = function(issue) { var $x = ["TIssue",18,issue]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TRefinement = function(refinement) { var $x = ["TRefinement",19,refinement]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TTag = function(tag) { var $x = ["TTag",20,tag]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TRef = function(ref) { var $x = ["TRef",21,ref]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TBinary = function(binary,base) { var $x = ["TBinary",22,binary,base]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TBlock = function(block) { var $x = ["TBlock",23,block]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TParen = function(paren) { var $x = ["TParen",24,paren]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TMap = function(map) { var $x = ["TMap",25,map]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TTuple = function(tuple) { var $x = ["TTuple",26,tuple]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TPair = function(x,y) { var $x = ["TPair",27,x,y]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TPoint2D = function(x,y) { var $x = ["TPoint2D",28,x,y]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TPoint3D = function(x,y,z) { var $x = ["TPoint3D",29,x,y,z]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TDate = function(date,time,zone) { var $x = ["TDate",30,date,time,zone]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TTime = function(hour,minute,second) { var $x = ["TTime",31,hour,minute,second]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
tokenizer_Token.TConstruct = function(construct) { var $x = ["TConstruct",32,construct]; $x.__enum__ = tokenizer_Token; $x.toString = $estr; return $x; }
class tokenizer_RegexpChecks {
}
tokenizer_RegexpChecks.__name__ = true;
class tokenizer_Checks {
	static anyWord(rdr) {
		if(!rdr.matchesRx(tokenizer_RegexpChecks.word)) {
			return rdr.matchesRx(tokenizer_RegexpChecks.specialWord);
		} else {
			return true;
		}
	}
}
tokenizer_Checks.__name__ = true;
function tokenizer_DateMatch_isYYYYMMMDD(match) {
	return match.date_yyyymmmdd != null;
}
function tokenizer_DateMatch_isDDMMMY(match) {
	return match.date_ddmmmy != null;
}
function tokenizer_DateMatch_isYYYYDDD(match) {
	return match.date_yyyyddd != null;
}
function tokenizer_DateMatch_isYYYYW(match) {
	return match.date_yyyyW != null;
}
function tokenizer_DateMatch_isDateT(match) {
	return match.dateT != null;
}
function tokenizer_DateMatch_isHMS(match) {
	return match.time_hms != null;
}
function tokenizer_DateMatch_isHHMMSS(match) {
	return match.time_hhmmss != null;
}
function tokenizer_DateMatch_isHHMM(match) {
	return match.time_hhmm != null;
}
function tokenizer_DateMatch_isZoneHM15(match) {
	return match.zone_hm15 != null;
}
function tokenizer_DateMatch_isZoneHHMM(match) {
	return match.zone_hhmm != null;
}
function tokenizer_DateMatch_isZoneHour(match) {
	return match.zone_hour != null;
}
function tokenizer_DateMatch_getMonth(name) {
	name = name.toLowerCase();
	return tokenizer_DateMatch_MONTHS.findIndex(function(month) {
		return name.startsWith(month);
	});
}
var tokenizer_DateKind = { __ename__:true,__constructs__:["YYYYMDD","YYYYDDD","YYYYWWD"] };
tokenizer_DateKind.YYYYMDD = function(yyyy,m,dd) { var $x = ["YYYYMDD",0,yyyy,m,dd]; $x.__enum__ = tokenizer_DateKind; $x.toString = $estr; return $x; }
tokenizer_DateKind.YYYYDDD = function(yyyy,ddd) { var $x = ["YYYYDDD",1,yyyy,ddd]; $x.__enum__ = tokenizer_DateKind; $x.toString = $estr; return $x; }
tokenizer_DateKind.YYYYWWD = function(yyyy,ww,d) { var $x = ["YYYYWWD",2,yyyy,ww,d]; $x.__enum__ = tokenizer_DateKind; $x.toString = $estr; return $x; }
var tokenizer_TimeKind = { __ename__:true,__constructs__:["HMS","HHMMSS","HHMM"] };
tokenizer_TimeKind.HMS = function(h,m,s) { var $x = ["HMS",0,h,m,s]; $x.__enum__ = tokenizer_TimeKind; $x.toString = $estr; return $x; }
tokenizer_TimeKind.HHMMSS = function(hhmmss,ms) { var $x = ["HHMMSS",1,hhmmss,ms]; $x.__enum__ = tokenizer_TimeKind; $x.toString = $estr; return $x; }
tokenizer_TimeKind.HHMM = function(hhmm) { var $x = ["HHMM",2,hhmm]; $x.__enum__ = tokenizer_TimeKind; $x.toString = $estr; return $x; }
var tokenizer_ZoneKind = { __ename__:true,__constructs__:["ZoneHM15","ZoneHHMM","ZoneHour"] };
tokenizer_ZoneKind.ZoneHM15 = function(sign,hour,min15) { var $x = ["ZoneHM15",0,sign,hour,min15]; $x.__enum__ = tokenizer_ZoneKind; $x.toString = $estr; return $x; }
tokenizer_ZoneKind.ZoneHHMM = function(sign,hhmm) { var $x = ["ZoneHHMM",1,sign,hhmm]; $x.__enum__ = tokenizer_ZoneKind; $x.toString = $estr; return $x; }
tokenizer_ZoneKind.ZoneHour = function(sign,hour) { var $x = ["ZoneHour",2,sign,hour]; $x.__enum__ = tokenizer_ZoneKind; $x.toString = $estr; return $x; }
class tokenizer_Reader {
	constructor(input) {
		this.stream = input;
		this.pos = 0;
	}
	eof() {
		return this.pos >= this.stream.length;
	}
	peek(length) {
		if(length == null) {
			length = 1;
		}
		if(this.eof() || this.pos + length > this.stream.length) {
			return null;
		} else {
			return this.stream.substr(this.pos,length);
		}
	}
	next(length) {
		if(length == null) {
			length = 1;
		}
		if(this.eof() || this.pos + length > this.stream.length) {
			throw haxe_Exception.thrown("range error!");
		} else {
			return this.stream.substr((this.pos += length) - length,length);
		}
	}
	matchesRx(rx) {
		rx.lastIndex = this.pos;
		return rx.test(this.stream);
	}
	matchRx(rx) {
		rx.lastIndex = this.pos;
		let match = rx.exec(this.stream);
		if(match != null) {
			this.pos += match[0].length;
			return match;
		} else {
			throw haxe_Exception.thrown("did not match!");
		}
	}
	tryMatchRx(rx) {
		rx.lastIndex = this.pos;
		let match = rx.exec(this.stream);
		if(match != null) {
			this.pos += match[0].length;
			return match;
		} else {
			return null;
		}
	}
	matches(str) {
		return this.stream.startsWith(str, this.pos);
	}
	match(str) {
		if(this.matches(str)) {
			this.pos += str.length;
			return str;
		} else {
			throw haxe_Exception.thrown("did not match!");
		}
	}
	matchSubstr(str) {
		let index = this.stream.indexOf(str,this.pos);
		if(index == -1) {
			return null;
		} else {
			let start = this.pos;
			this.pos = index + str.length;
			return this.stream.substring(start,index);
		}
	}
	tryMatch(str) {
		if(this.matches(str)) {
			this.pos += str.length;
			return true;
		} else {
			return false;
		}
	}
	trimSpace() {
		while(runtime_actions_datatypes_StringActions.WHITE_CHAR.has(this.stream.charCodeAt(this.pos))) this.pos++;
	}
	getLoc() {
		let line = 1;
		let column = 0;
		let _g = this.pos;
		let _g1 = this.stream.length;
		while(_g < _g1) {
			let _g1 = this.stream.charCodeAt((_g++));
			if(_g1 == null) {
				++column;
			} else {
				switch(_g1) {
				case 10:case 13:
					++line;
					column = 0;
					break;
				default:
					++column;
				}
			}
		}
		return { line : line, column : column};
	}
	getLocStr() {
		let loc = this.getLoc();
		return "[" + loc.line + ":" + loc.column + "]";
	}
}
tokenizer_Reader.__name__ = true;
Object.assign(tokenizer_Reader.prototype, {
	__class__: tokenizer_Reader
});
class types_Percent extends types_base__$Float {
	constructor(float) {
		super(float);
	}
	make(value) {
		return new types_Percent(value);
	}
	get_TYPE_KIND() {
		return 34;
	}
}
types_Percent.__name__ = true;
types_Percent.__super__ = types_base__$Float;
Object.assign(types_Percent.prototype, {
	__class__: types_Percent
});
class types_Point2D extends Value {
	constructor(x,y) {
		super();
		this.x = x;
		this.y = y;
	}
	get_TYPE_KIND() {
		return 27;
	}
}
types_Point2D.__name__ = true;
types_Point2D.__super__ = Value;
Object.assign(types_Point2D.prototype, {
	__class__: types_Point2D
});
class types_Point3D extends Value {
	constructor(x,y,z) {
		super();
		this.x = x;
		this.y = y;
		this.z = z;
	}
	get_TYPE_KIND() {
		return 28;
	}
}
types_Point3D.__name__ = true;
types_Point3D.__super__ = Value;
Object.assign(types_Point3D.prototype, {
	__class__: types_Point3D
});
class util_DateTools {
	static weekToDate(year,week) {
		--week;
		let date = new Date(year,0,week * 7);
		let day = date.getDay();
		if(day != 1) {
			date.setUTCFullYear(year,0,week * 7 + (day < 4 ? 1 - day : 6 - day + 2));
		}
		return date;
	}
}
util_DateTools.__name__ = true;
class runtime_natives_Transcode {
	static call(src,options) {
		let _g = options.into;
		let _g1 = options.one;
		let _g2 = options.part;
		let _g3 = options.prescan;
		let _g4 = options.scan;
		let _g5 = options.trace;
		if(options.next == true) {
			throw haxe_Exception.thrown("NYI");
		} else if(_g1 == true) {
			throw haxe_Exception.thrown("NYI");
		} else if(_g3 == true) {
			throw haxe_Exception.thrown("NYI");
		} else if(_g4 == true) {
			throw haxe_Exception.thrown("NYI");
		} else {
			let _hx_tmp;
			if(_g == null) {
				_hx_tmp = _g != null;
				if(_hx_tmp == true) {
					if(_g2 != null == true) {
						throw haxe_Exception.thrown("NYI");
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else if(_g2 != null == true) {
					throw haxe_Exception.thrown("NYI");
				} else if(_g2 == null) {
					if(_g5 != null == true) {
						throw haxe_Exception.thrown("NYI");
					} else {
						let _hx_tmp;
						if(((src) instanceof types_Binary) == true) {
							throw haxe_Exception.thrown("NYI");
						} else {
							_hx_tmp = ((src) instanceof types_String);
							if(_hx_tmp == true) {
								let __anon0__s = src;
								let s = __anon0__s;
								return new types_Block(Tokenizer.parse(s.toJs()));
							} else {
								throw haxe_Exception.thrown("error!");
							}
						}
					}
				} else if(_g5 != null == true) {
					throw haxe_Exception.thrown("NYI");
				} else {
					let _hx_tmp;
					if(((src) instanceof types_Binary) == true) {
						throw haxe_Exception.thrown("NYI");
					} else {
						_hx_tmp = ((src) instanceof types_String);
						if(_hx_tmp == true) {
							let __anon0__s = src;
							let s = __anon0__s;
							return new types_Block(Tokenizer.parse(s.toJs()));
						} else {
							throw haxe_Exception.thrown("error!");
						}
					}
				}
			} else {
				_hx_tmp = _g != null;
				if(_hx_tmp == true) {
					if(_g2 != null == true) {
						throw haxe_Exception.thrown("NYI");
					} else {
						throw haxe_Exception.thrown("NYI");
					}
				} else if(_g2 != null == true) {
					throw haxe_Exception.thrown("NYI");
				} else if(_g2 == null) {
					if(_g5 != null == true) {
						throw haxe_Exception.thrown("NYI");
					} else {
						let _hx_tmp;
						if(((src) instanceof types_Binary) == true) {
							throw haxe_Exception.thrown("NYI");
						} else {
							_hx_tmp = ((src) instanceof types_String);
							if(_hx_tmp == true) {
								let __anon0__s = src;
								let s = __anon0__s;
								return new types_Block(Tokenizer.parse(s.toJs()));
							} else {
								throw haxe_Exception.thrown("error!");
							}
						}
					}
				} else if(_g5 != null == true) {
					throw haxe_Exception.thrown("NYI");
				} else {
					let _hx_tmp;
					if(((src) instanceof types_Binary) == true) {
						throw haxe_Exception.thrown("NYI");
					} else {
						_hx_tmp = ((src) instanceof types_String);
						if(_hx_tmp == true) {
							let __anon0__s = src;
							let s = __anon0__s;
							return new types_Block(Tokenizer.parse(s.toJs()));
						} else {
							throw haxe_Exception.thrown("error!");
						}
					}
				}
			}
		}
	}
	static _call(src) {
		return new types_Block(Tokenizer.parse(src));
	}
}
runtime_natives_Transcode.__name__ = true;
function runtime_natives_Trig__degreesToRadians(value,type) {
	let val = value % 360.0;
	if(val > 180.0 || val < -180.0) {
		val += val < 0.0 ? 360.0 : -360.0;
	}
	if(val > 90.0 || val < -90.0) {
		switch(type) {
		case 0:
			val += val < 0.0 ? 180.0 : -180.0;
			break;
		case 2:
			val = (val < 0.0 ? -180.0 : 180.0) - val;
			break;
		default:
		}
	}
	val = val * Math.PI / 180.0;
	return val;
}
function runtime_natives_Trig_arcTrans(value,type,isRadians) {
	let res;
	switch(type) {
	case 0:
		res = Math.atan(value);
		break;
	case 1:
		res = Math.acos(value);
		break;
	case 2:
		res = Math.asin(value);
		break;
	}
	if(isRadians) {
		return res;
	} else {
		return res * 180.0 / Math.PI;
	}
}
class runtime_natives_Sine {
	static call(angle,options) {
		let value = angle.asFloat();
		let res = Math.sin(options.radians ? value : runtime_natives_Trig__degreesToRadians(value,2));
		if(types_Float.DBL_EPSILON > Math.abs(res)) {
			res = 0.0;
		}
		return new types_Float(res);
	}
}
runtime_natives_Sine.__name__ = true;
class runtime_natives_Cosine {
	static call(angle,options) {
		let value = angle.asFloat();
		let res = Math.cos(options.radians ? value : runtime_natives_Trig__degreesToRadians(value,1));
		if(types_Float.DBL_EPSILON > Math.abs(res)) {
			res = 0.0;
		}
		return new types_Float(res);
	}
}
runtime_natives_Cosine.__name__ = true;
class runtime_natives_Tangent {
	static call(angle,options) {
		let value = angle.asFloat();
		let value1 = options.radians ? value : runtime_natives_Trig__degreesToRadians(value,0);
		let res = value1 == Math.PI / 2 ? -Infinity : value1 == Math.PI / -2 ? Infinity : Math.tan(value1);
		return new types_Float(res);
	}
}
runtime_natives_Tangent.__name__ = true;
class runtime_natives_Arcsine {
	static call(angle,options) {
		return new types_Float(runtime_natives_Trig_arcTrans(angle.asFloat(),2,options.radians));
	}
}
runtime_natives_Arcsine.__name__ = true;
class runtime_natives_Arccosine {
	static call(angle,options) {
		return new types_Float(runtime_natives_Trig_arcTrans(angle.asFloat(),1,options.radians));
	}
}
runtime_natives_Arccosine.__name__ = true;
class runtime_natives_Arctangent {
	static call(angle,options) {
		return new types_Float(runtime_natives_Trig_arcTrans(angle.asFloat(),0,options.radians));
	}
}
runtime_natives_Arctangent.__name__ = true;
class runtime_natives_Arctangent2 {
	static call(y,x,options) {
		let res = Math.atan2(y.asFloat(),x.asFloat());
		if(!options.radians) {
			res = 180.0 / Math.PI * res;
		}
		return new types_Float(res);
	}
}
runtime_natives_Arctangent2.__name__ = true;
class runtime_natives_Try {
	static call(block,options) {
		if(options.keep) {
			throw haxe_Exception.thrown("NYI!");
		}
		try {
			return runtime_natives_Do.evalValues(new util__$Series__$Series(block.values,block.index));
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g);
			if(((_g1) instanceof runtime_RedError)) {
				let e = _g1;
				if(!options.all && e.error.isSpecial()) {
					throw e;
				}
				return e.error;
			} else {
				throw _g;
			}
		}
	}
}
runtime_natives_Try.__name__ = true;
class runtime_natives_Type_$q {
	static of(value) {
		return Runtime.DATATYPES[value.get_TYPE_KIND()][1];
	}
	static call(value,options) {
		let datatype = Runtime.DATATYPES[value.get_TYPE_KIND()];
		if(options.word) {
			return new types_Word(datatype[0]);
		} else {
			return datatype[1];
		}
	}
}
runtime_natives_Type_$q.__name__ = true;
class runtime_natives_Unless {
	static call(cond,body) {
		if(cond.isTruthy()) {
			return types_None.NONE;
		} else {
			return runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index));
		}
	}
}
runtime_natives_Unless.__name__ = true;
class runtime_natives_Unset {
	static call(value) {
		let _hx_tmp;
		if(((value) instanceof types_Word) == true) {
			let __anon0__word = value;
			let word = __anon0__word;
			word.set(types_Unset.UNSET);
		} else {
			_hx_tmp = ((value) instanceof types_Block);
			if(_hx_tmp == true) {
				let __anon0__block = value;
				let block = __anon0__block;
				let _gthis = block;
				let _this = block.values.slice(block.index);
				let result = new Array(_this.length);
				let _g = 0;
				let _g1 = _this.length;
				while(_g < _g1) {
					let i = _g++;
					result[i] = _gthis.wrap(_this[i]);
				}
				let _g_current = 0;
				let _g_array = result;
				while(_g_current < _g_array.length) {
					let val = _g_array[_g_current++];
					if(((val) instanceof types_Word) == true) {
						let __anon0__word = val;
						let word = __anon0__word;
						word.set(types_Unset.UNSET);
					} else {
						continue;
					}
				}
			} else {
				throw haxe_Exception.thrown("error!");
			}
		}
		return types_Unset.UNSET;
	}
}
runtime_natives_Unset.__name__ = true;
class runtime_natives_Until {
	static call(body) {
		let res;
		while(true) {
			try {
				res = runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index));
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g);
				if(((_g1) instanceof runtime_RedError)) {
					let e = _g1;
					if(e.error.isContinue()) {
						if(res.isTruthy()) {
							break;
						} else {
							continue;
						}
					} else if(e.error.isBreak()) {
						return e.error.ctx.get("arg1",true);
					} else {
						throw e;
					}
				} else {
					throw _g;
				}
			}
			if(res.isTruthy()) {
				break;
			}
		}
		return res;
	}
}
runtime_natives_Until.__name__ = true;
class runtime_natives_Value_$q {
	static call(value) {
		if(((value) instanceof types_base__$AnyWord) == true) {
			let __anon0__sym = value;
			let sym = __anon0__sym;
			value = sym.get(true);
		}
		if(value != types_Unset.UNSET) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
}
runtime_natives_Value_$q.__name__ = true;
class runtime_natives_While {
	static call(cond,body) {
		while(true) {
			let tmp;
			try {
				tmp = runtime_natives_Do.evalValues(new util__$Series__$Series(cond.values,cond.index)).isTruthy();
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g);
				if(((_g1) instanceof runtime_RedError)) {
					let e = _g1;
					if(e.error.isBreak() || e.error.isContinue()) {
						throw haxe_Exception.thrown(types_Error.create({ type : "throw", id : "while-cond"}));
					} else {
						throw e;
					}
				} else {
					throw _g;
				}
			}
			if(!tmp) {
				break;
			}
			try {
				runtime_natives_Do.evalValues(new util__$Series__$Series(body.values,body.index));
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g);
				if(((_g1) instanceof runtime_RedError)) {
					let e = _g1;
					if(e.error.isContinue()) {
						continue;
					} else if(e.error.isBreak()) {
						return e.error.ctx.get("arg1",true);
					} else {
						throw e;
					}
				} else {
					throw _g;
				}
			}
		}
		return types_None.NONE;
	}
}
runtime_natives_While.__name__ = true;
class runtime_natives_Zero_$q {
	static call(value) {
		let cond;
		let _hx_tmp;
		let _hx_tmp1;
		let _hx_tmp2;
		let _hx_tmp3;
		if(((value) instanceof types_Money) == true) {
			let __anon0__m = value;
			let m = __anon0__m;
			throw haxe_Exception.thrown("NYI!");
		} else {
			_hx_tmp3 = ((value) instanceof types_base__$Integer) ? value : null;
			if(_hx_tmp3 == null) {
				_hx_tmp2 = ((value) instanceof types_base__$Float) ? value : null;
				if(_hx_tmp2 == null) {
					_hx_tmp1 = ((value) instanceof types_Pair) ? value : null;
					if(_hx_tmp1 == null) {
						_hx_tmp = ((value) instanceof types_Tuple) ? value : null;
						if(_hx_tmp == null) {
							throw haxe_Exception.thrown("error!");
						} else {
							let _g = _hx_tmp.get_TYPE_KIND();
							let values = _hx_tmp.values;
							cond = values.every(function(v) {
								return v == 0;
							});
						}
					} else {
						let _g = _hx_tmp1.get_TYPE_KIND();
						let x = _hx_tmp1.x;
						let y = _hx_tmp1.y;
						cond = x == 0 && y == 0;
					}
				} else {
					let _g = _hx_tmp2.get_TYPE_KIND();
					let f = _hx_tmp2.float;
					cond = f == 0.0;
				}
			} else {
				let _g = _hx_tmp3.get_TYPE_KIND();
				let i = _hx_tmp3.int;
				cond = i == 0;
			}
		}
		if(cond) {
			return types_Logic.TRUE;
		} else {
			return types_Logic.FALSE;
		}
	}
}
runtime_natives_Zero_$q.__name__ = true;
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
{
	Object.defineProperty(String.prototype,"__class__",{ value : String, enumerable : false, writable : true});
	String.__name__ = true;
	Array.__name__ = true;
	Date.prototype.__class__ = Date;
	Date.__name__ = "Date";
	var Int = { };
	var Dynamic = { };
	var Float = Number;
	var Bool = Boolean;
	var Class = { };
	var Enum = { };
}
js_Boot.__toStr = ({ }).toString;
runtime_actions_datatypes_WordActions.thisType = types_Word;
runtime_actions_datatypes_SetWordActions.thisType = types_SetWord;
runtime_actions_datatypes_LitWordActions.thisType = types_LitWord;
runtime_actions_datatypes_GetWordActions.thisType = types_GetWord;
runtime_actions_datatypes_IssueActions.thisType = types_Issue;
runtime_actions_datatypes_NativeActions.MAPPINGS = new Map([]);
runtime_actions_datatypes_ActionActions.MAPPINGS = new Map([]);
{
	let value = types_ActionFn.AAbsolute(runtime_actions_Absolute.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_ABSOLUTE",value);
}
{
	let value = types_ActionFn.AAdd(runtime_actions_Add.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_ADD",value);
}
{
	let value = types_ActionFn.AAnd(runtime_actions_And.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_AND~",value);
}
{
	let value = types_ActionFn.AAppend(runtime_actions_Append.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_APPEND",value);
}
{
	let value = types_ActionFn.AAt(runtime_actions_At.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_AT",value);
}
{
	let value = types_ActionFn.ABack(runtime_actions_Back.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_BACK",value);
}
{
	let value = types_ActionFn.AChange(runtime_actions_Change.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_CHANGE",value);
}
{
	let value = types_ActionFn.AClear(runtime_actions_Clear.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_CLEAR",value);
}
{
	let value = types_ActionFn.AComplement(runtime_actions_Complement.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_COMPLEMENT",value);
}
{
	let value = types_ActionFn.ACopy(runtime_actions_Copy.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_COPY",value);
}
{
	let value = types_ActionFn.ADivide(runtime_actions_Divide.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_DIVIDE",value);
}
{
	let value = types_ActionFn.AEven_q(runtime_actions_Even_$q.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_EVEN?",value);
}
{
	let value = types_ActionFn.AFind(runtime_actions_Find.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_FIND",value);
}
{
	let value = types_ActionFn.AForm(runtime_actions_Form.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_FORM",value);
}
{
	let value = types_ActionFn.AHead(runtime_actions_Head.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_HEAD",value);
}
{
	let value = types_ActionFn.AHead_q(runtime_actions_Head_$q.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_HEAD?",value);
}
{
	let value = types_ActionFn.AIndex_q(runtime_actions_Index_$q.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_INDEX?",value);
}
{
	let value = types_ActionFn.AInsert(runtime_actions_Insert.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_INSERT",value);
}
{
	let value = types_ActionFn.ALength_q(runtime_actions_Length_$q.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_LENGTH?",value);
}
{
	let value = types_ActionFn.AMake(runtime_actions_Make.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_MAKE",value);
}
{
	let value = types_ActionFn.AMold(runtime_actions_Mold.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_MOLD",value);
}
{
	let value = types_ActionFn.AMove(runtime_actions_Move.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_MOVE",value);
}
{
	let value = types_ActionFn.AMultiply(runtime_actions_Multiply.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_MULTIPLY",value);
}
{
	let value = types_ActionFn.ANegate(runtime_actions_Negate.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_NEGATE",value);
}
{
	let value = types_ActionFn.ANext(runtime_actions_Next.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_NEXT",value);
}
{
	let value = types_ActionFn.AOdd_q(runtime_actions_Odd_$q.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_ODD?",value);
}
{
	let value = types_ActionFn.AOr(runtime_actions_Or.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_OR~",value);
}
{
	let value = types_ActionFn.APick(runtime_actions_Pick.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_PICK",value);
}
{
	let value = types_ActionFn.APoke(runtime_actions_Poke.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_POKE",value);
}
{
	let value = types_ActionFn.APower(runtime_actions_Power.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_POWER",value);
}
{
	let value = types_ActionFn.APut(runtime_actions_Put.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_PUT",value);
}
{
	let value = types_ActionFn.AReflect(runtime_actions_Reflect.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_REFLECT",value);
}
{
	let value = types_ActionFn.ARemainder(runtime_actions_Remainder.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_REMAINDER",value);
}
{
	let value = types_ActionFn.ARemove(runtime_actions_Remove.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_REMOVE",value);
}
{
	let value = types_ActionFn.AReverse(runtime_actions_Reverse.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_REVERSE",value);
}
{
	let value = types_ActionFn.ARound(runtime_actions_Round.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_ROUND",value);
}
{
	let value = types_ActionFn.ASelect(runtime_actions_Select.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_SELECT",value);
}
{
	let value = types_ActionFn.ASkip(runtime_actions_Skip.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_SKIP",value);
}
{
	let value = types_ActionFn.ASort(runtime_actions_Sort.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_SORT",value);
}
{
	let value = types_ActionFn.ASubtract(runtime_actions_Subtract.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_SUBTRACT",value);
}
{
	let value = types_ActionFn.ASwap(runtime_actions_Swap.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_SWAP",value);
}
{
	let value = types_ActionFn.ATail(runtime_actions_Tail.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_TAIL",value);
}
{
	let value = types_ActionFn.ATail_q(runtime_actions_Tail_$q.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_TAIL?",value);
}
{
	let value = types_ActionFn.ATake(runtime_actions_Take.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_TAKE",value);
}
{
	let value = types_ActionFn.ATo(runtime_actions_To.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_TO",value);
}
{
	let value = types_ActionFn.ATrim(runtime_actions_Trim.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_TRIM",value);
}
{
	let value = types_ActionFn.AXor(runtime_actions_Xor.call);
	runtime_actions_datatypes_ActionActions.MAPPINGS.set("ACT_XOR~",value);
}
{
	let this1 = runtime_actions_datatypes_NativeActions.MAPPINGS;
	let value = types_NativeFn.NDo(runtime_natives_Do.call);
	this1.set("NAT_DO",value);
}
{
	let value = types_NativeFn.NAll(runtime_natives_All.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_ALL",value);
}
{
	let value = types_NativeFn.NAny(runtime_natives_Any.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_ANY",value);
}
{
	let value = types_NativeFn.NApply(runtime_natives_Apply.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_APPLY",value);
}
{
	let value = types_NativeFn.NAs(runtime_natives_As.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_AS",value);
}
{
	let value = types_NativeFn.NAsMoney(runtime_natives_AsMoney.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_AS_MONEY",value);
}
{
	let value = types_NativeFn.NAsPair(runtime_natives_AsPair.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_AS_PAIR",value);
}
{
	let value = types_NativeFn.NBind(runtime_natives_Bind.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_BIND",value);
}
{
	let value = types_NativeFn.NBreak(runtime_natives_Break.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_BREAK",value);
}
{
	let value = types_NativeFn.NCase(runtime_natives_Case.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_CASE",value);
}
types_Char.chars = new Map([[0,new types_Char(0)],[1,new types_Char(1)],[2,new types_Char(2)],[3,new types_Char(3)],[4,new types_Char(4)],[5,new types_Char(5)],[6,new types_Char(6)],[7,new types_Char(7)],[8,new types_Char(8)],[9,new types_Char(9)],[10,new types_Char(10)],[11,new types_Char(11)],[12,new types_Char(12)],[13,new types_Char(13)],[14,new types_Char(14)],[15,new types_Char(15)],[16,new types_Char(16)],[17,new types_Char(17)],[18,new types_Char(18)],[19,new types_Char(19)],[20,new types_Char(20)],[21,new types_Char(21)],[22,new types_Char(22)],[23,new types_Char(23)],[24,new types_Char(24)],[25,new types_Char(25)],[26,new types_Char(26)],[27,new types_Char(27)],[28,new types_Char(28)],[29,new types_Char(29)],[30,new types_Char(30)],[31,new types_Char(31)],[32,new types_Char(32)],[33,new types_Char(33)],[34,new types_Char(34)],[35,new types_Char(35)],[36,new types_Char(36)],[37,new types_Char(37)],[38,new types_Char(38)],[39,new types_Char(39)],[40,new types_Char(40)],[41,new types_Char(41)],[42,new types_Char(42)],[43,new types_Char(43)],[44,new types_Char(44)],[45,new types_Char(45)],[46,new types_Char(46)],[47,new types_Char(47)],[48,new types_Char(48)],[49,new types_Char(49)],[50,new types_Char(50)],[51,new types_Char(51)],[52,new types_Char(52)],[53,new types_Char(53)],[54,new types_Char(54)],[55,new types_Char(55)],[56,new types_Char(56)],[57,new types_Char(57)],[58,new types_Char(58)],[59,new types_Char(59)],[60,new types_Char(60)],[61,new types_Char(61)],[62,new types_Char(62)],[63,new types_Char(63)],[64,new types_Char(64)],[65,new types_Char(65)],[66,new types_Char(66)],[67,new types_Char(67)],[68,new types_Char(68)],[69,new types_Char(69)],[70,new types_Char(70)],[71,new types_Char(71)],[72,new types_Char(72)],[73,new types_Char(73)],[74,new types_Char(74)],[75,new types_Char(75)],[76,new types_Char(76)],[77,new types_Char(77)],[78,new types_Char(78)],[79,new types_Char(79)],[80,new types_Char(80)],[81,new types_Char(81)],[82,new types_Char(82)],[83,new types_Char(83)],[84,new types_Char(84)],[85,new types_Char(85)],[86,new types_Char(86)],[87,new types_Char(87)],[88,new types_Char(88)],[89,new types_Char(89)],[90,new types_Char(90)],[91,new types_Char(91)],[92,new types_Char(92)],[93,new types_Char(93)],[94,new types_Char(94)],[95,new types_Char(95)],[96,new types_Char(96)],[97,new types_Char(97)],[98,new types_Char(98)],[99,new types_Char(99)],[100,new types_Char(100)],[101,new types_Char(101)],[102,new types_Char(102)],[103,new types_Char(103)],[104,new types_Char(104)],[105,new types_Char(105)],[106,new types_Char(106)],[107,new types_Char(107)],[108,new types_Char(108)],[109,new types_Char(109)],[110,new types_Char(110)],[111,new types_Char(111)],[112,new types_Char(112)],[113,new types_Char(113)],[114,new types_Char(114)],[115,new types_Char(115)],[116,new types_Char(116)],[117,new types_Char(117)],[118,new types_Char(118)],[119,new types_Char(119)],[120,new types_Char(120)],[121,new types_Char(121)],[122,new types_Char(122)],[123,new types_Char(123)],[124,new types_Char(124)],[125,new types_Char(125)],[126,new types_Char(126)],[127,new types_Char(127)],[128,new types_Char(128)],[129,new types_Char(129)],[130,new types_Char(130)],[131,new types_Char(131)],[132,new types_Char(132)],[133,new types_Char(133)],[134,new types_Char(134)],[135,new types_Char(135)],[136,new types_Char(136)],[137,new types_Char(137)],[138,new types_Char(138)],[139,new types_Char(139)],[140,new types_Char(140)],[141,new types_Char(141)],[142,new types_Char(142)],[143,new types_Char(143)],[144,new types_Char(144)],[145,new types_Char(145)],[146,new types_Char(146)],[147,new types_Char(147)],[148,new types_Char(148)],[149,new types_Char(149)],[150,new types_Char(150)],[151,new types_Char(151)],[152,new types_Char(152)],[153,new types_Char(153)],[154,new types_Char(154)],[155,new types_Char(155)],[156,new types_Char(156)],[157,new types_Char(157)],[158,new types_Char(158)],[159,new types_Char(159)],[160,new types_Char(160)],[161,new types_Char(161)],[162,new types_Char(162)],[163,new types_Char(163)],[164,new types_Char(164)],[165,new types_Char(165)],[166,new types_Char(166)],[167,new types_Char(167)],[168,new types_Char(168)],[169,new types_Char(169)],[170,new types_Char(170)],[171,new types_Char(171)],[172,new types_Char(172)],[173,new types_Char(173)],[174,new types_Char(174)],[175,new types_Char(175)],[176,new types_Char(176)],[177,new types_Char(177)],[178,new types_Char(178)],[179,new types_Char(179)],[180,new types_Char(180)],[181,new types_Char(181)],[182,new types_Char(182)],[183,new types_Char(183)],[184,new types_Char(184)],[185,new types_Char(185)],[186,new types_Char(186)],[187,new types_Char(187)],[188,new types_Char(188)],[189,new types_Char(189)],[190,new types_Char(190)],[191,new types_Char(191)],[192,new types_Char(192)],[193,new types_Char(193)],[194,new types_Char(194)],[195,new types_Char(195)],[196,new types_Char(196)],[197,new types_Char(197)],[198,new types_Char(198)],[199,new types_Char(199)],[200,new types_Char(200)],[201,new types_Char(201)],[202,new types_Char(202)],[203,new types_Char(203)],[204,new types_Char(204)],[205,new types_Char(205)],[206,new types_Char(206)],[207,new types_Char(207)],[208,new types_Char(208)],[209,new types_Char(209)],[210,new types_Char(210)],[211,new types_Char(211)],[212,new types_Char(212)],[213,new types_Char(213)],[214,new types_Char(214)],[215,new types_Char(215)],[216,new types_Char(216)],[217,new types_Char(217)],[218,new types_Char(218)],[219,new types_Char(219)],[220,new types_Char(220)],[221,new types_Char(221)],[222,new types_Char(222)],[223,new types_Char(223)],[224,new types_Char(224)],[225,new types_Char(225)],[226,new types_Char(226)],[227,new types_Char(227)],[228,new types_Char(228)],[229,new types_Char(229)],[230,new types_Char(230)],[231,new types_Char(231)],[232,new types_Char(232)],[233,new types_Char(233)],[234,new types_Char(234)],[235,new types_Char(235)],[236,new types_Char(236)],[237,new types_Char(237)],[238,new types_Char(238)],[239,new types_Char(239)],[240,new types_Char(240)],[241,new types_Char(241)],[242,new types_Char(242)],[243,new types_Char(243)],[244,new types_Char(244)],[245,new types_Char(245)],[246,new types_Char(246)],[247,new types_Char(247)],[248,new types_Char(248)],[249,new types_Char(249)],[250,new types_Char(250)],[251,new types_Char(251)],[252,new types_Char(252)],[253,new types_Char(253)],[254,new types_Char(254)],[255,new types_Char(255)]]);
{
	let value = types_NativeFn.NUppercase(runtime_natives_Uppercase.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_UPPERCASE",value);
}
{
	let value = types_NativeFn.NLowercase(runtime_natives_Lowercase.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_LOWERCASE",value);
}
{
	let value = types_NativeFn.NCatch(runtime_natives_Catch.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_CATCH",value);
}
{
	let value = types_NativeFn.NEqual_q(runtime_natives_Equal_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_EQUAL?",value);
}
{
	let value = types_NativeFn.NNotEqual_q(runtime_natives_NotEqual_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_NOT_EQUAL?",value);
}
{
	let value = types_NativeFn.NStrictEqual_q(runtime_natives_StrictEqual_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_STRICT_EQUAL?",value);
}
{
	let value = types_NativeFn.NLesser_q(runtime_natives_Lesser_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_LESSER?",value);
}
{
	let value = types_NativeFn.NLesserOrEqual_q(runtime_natives_LesserOrEqual_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_LESSER_OR_EQUAL?",value);
}
{
	let value = types_NativeFn.NGreater_q(runtime_natives_Greater_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_GREATER?",value);
}
{
	let value = types_NativeFn.NGreaterOrEqual_q(runtime_natives_GreaterOrEqual_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_GREATER_OR_EQUAL?",value);
}
{
	let value = types_NativeFn.NSame_q(runtime_natives_Same_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_SAME?",value);
}
{
	let value = types_NativeFn.NComplement_q(runtime_natives_Complement_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_COMPLEMENT?",value);
}
{
	let value = types_NativeFn.NCompose(runtime_natives_Compose.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_COMPOSE",value);
}
{
	let value = types_NativeFn.NConstruct(runtime_natives_Construct.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_CONSTRUCT",value);
}
{
	let value = types_NativeFn.NContext_q(runtime_natives_Context_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_CONTEXT?",value);
}
{
	let value = types_NativeFn.NContinue(runtime_natives_Continue.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_CONTINUE",value);
}
{
	let value = types_NativeFn.NDehex(runtime_natives_Dehex.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_DEHEX",value);
}
{
	let value = types_NativeFn.NDoes(runtime_natives_Does.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_DOES",value);
}
{
	let value = types_NativeFn.NEither(runtime_natives_Either.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_EITHER",value);
}
{
	let value = types_NativeFn.NEnhex(runtime_natives_Enhex.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_ENHEX",value);
}
{
	let value = types_NativeFn.NExit(runtime_natives_Exit.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_EXIT",value);
}
{
	let value = types_NativeFn.NExtend(runtime_natives_Extend.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_EXTEND",value);
}
{
	let value = types_NativeFn.NForall(runtime_natives_Forall.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_FORALL",value);
}
{
	let value = types_NativeFn.NForeach(runtime_natives_Foreach.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_FOREACH",value);
}
{
	let value = types_NativeFn.NForever(runtime_natives_Forever.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_FOREVER",value);
}
{
	let value = types_NativeFn.NFunc(runtime_natives_Func.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_FUNC",value);
}
{
	let value = types_NativeFn.NGet(runtime_natives_Get.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_GET",value);
}
{
	let value = types_NativeFn.NHas(runtime_natives_Has.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_HAS",value);
}
{
	let value = types_NativeFn.NIf(runtime_natives_If.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_IF",value);
}
{
	let value = types_NativeFn.NIn(runtime_natives_In.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_IN",value);
}
{
	let value = types_NativeFn.NLog2(runtime_natives_Log2.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_LOG_2",value);
}
{
	let value = types_NativeFn.NLog10(runtime_natives_Log10.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_LOG_10",value);
}
{
	let value = types_NativeFn.NLogE(runtime_natives_LogE.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_LOG_E",value);
}
{
	let value = types_NativeFn.NExp(runtime_natives_Exp.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_EXP",value);
}
{
	let value = types_NativeFn.NSquareRoot(runtime_natives_SquareRoot.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_SQUARE_ROOT",value);
}
{
	let value = types_NativeFn.NLoop(runtime_natives_Loop.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_LOOP",value);
}
{
	let value = types_NativeFn.NMin(runtime_natives_Min.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_MIN",value);
}
{
	let value = types_NativeFn.NMax(runtime_natives_Max.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_MAX",value);
}
{
	let value = types_NativeFn.NNan_q(runtime_natives_Nan_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_NAN?",value);
}
{
	let value = types_NativeFn.NNegative_q(runtime_natives_Negative_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_NEGATIVE?",value);
}
{
	let value = types_NativeFn.NNewLine(runtime_natives_NewLine.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_NEW_LINE",value);
}
{
	let value = types_NativeFn.NNewLine_q(runtime_natives_NewLine_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_NEW_LINE?",value);
}
{
	let value = types_NativeFn.NNot(runtime_natives_Not.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_NOT",value);
}
{
	let value = types_NativeFn.NNow(runtime_natives_Now.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_NOW",value);
}
{
	let value = types_NativeFn.NPositive_q(runtime_natives_Positive_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_POSITIVE?",value);
}
{
	let value = types_NativeFn.NPrin(runtime_natives_Prin.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_PRIN",value);
}
{
	let value = types_NativeFn.NReduce(runtime_natives_Reduce.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_REDUCE",value);
}
{
	let value = types_NativeFn.NPrint(runtime_natives_Print.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_PRINT",value);
}
{
	let value = types_NativeFn.NRemoveEach(runtime_natives_RemoveEach.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_REMOVE_EACH",value);
}
{
	let value = types_NativeFn.NRepeat(runtime_natives_Repeat.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_REPEAT",value);
}
{
	let value = types_NativeFn.NReturn(runtime_natives_Return.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_RETURN",value);
}
{
	let value = types_NativeFn.NSet(runtime_natives_Set.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_SET",value);
}
{
	let value = types_NativeFn.NUnion(runtime_natives_Union.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_UNION",value);
}
{
	let value = types_NativeFn.NIntersect(runtime_natives_Intersect.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_INTERSECT",value);
}
{
	let value = types_NativeFn.NUnique(runtime_natives_Unique.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_UNIQUE",value);
}
{
	let value = types_NativeFn.NDifference(runtime_natives_Difference.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_DIFFERENCE",value);
}
{
	let value = types_NativeFn.NExclude(runtime_natives_Exclude.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_EXCLUDE",value);
}
{
	let value = types_NativeFn.NShift(runtime_natives_Shift.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_SHIFT",value);
}
{
	let value = types_NativeFn.NSign_q(runtime_natives_Sign_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_SIGN?",value);
}
{
	let value = types_NativeFn.NSwitch(runtime_natives_Switch.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_SWITCH",value);
}
{
	let value = types_NativeFn.NThrow(runtime_natives_Throw.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_THROW",value);
}
{
	let value = types_NativeFn.NToHex(runtime_natives_ToHex.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_TO_HEX",value);
}
{
	let value = types_NativeFn.NTranscode(runtime_natives_Transcode.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_TRANSCODE",value);
}
{
	let value = types_NativeFn.NSine(runtime_natives_Sine.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_SINE",value);
}
{
	let value = types_NativeFn.NCosine(runtime_natives_Cosine.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_COSINE",value);
}
{
	let value = types_NativeFn.NTangent(runtime_natives_Tangent.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_TANGENT",value);
}
{
	let value = types_NativeFn.NArcsine(runtime_natives_Arcsine.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_ARCSINE",value);
}
{
	let value = types_NativeFn.NArccosine(runtime_natives_Arccosine.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_ARCCOSINE",value);
}
{
	let value = types_NativeFn.NArctangent(runtime_natives_Arctangent.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_ARCTANGENT",value);
}
{
	let value = types_NativeFn.NArctangent2(runtime_natives_Arctangent2.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_ARCTANGENT2",value);
}
{
	let value = types_NativeFn.NTry(runtime_natives_Try.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_TRY",value);
}
{
	let value = types_NativeFn.NType_q(runtime_natives_Type_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_TYPE?",value);
}
{
	let value = types_NativeFn.NUnless(runtime_natives_Unless.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_UNLESS",value);
}
{
	let value = types_NativeFn.NUnset(runtime_natives_Unset.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_UNSET",value);
}
{
	let value = types_NativeFn.NUntil(runtime_natives_Until.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_UNTIL",value);
}
{
	let value = types_NativeFn.NValue_q(runtime_natives_Value_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_VALUE?",value);
}
{
	let value = types_NativeFn.NWhile(runtime_natives_While.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_WHILE",value);
}
{
	let value = types_NativeFn.NZero_q(runtime_natives_Zero_$q.call);
	runtime_actions_datatypes_NativeActions.MAPPINGS.set("NAT_ZERO?",value);
}
Cycles.size = 1000;
Cycles.cycles = new Array(Cycles.size);
Cycles.top = 0;
Cycles.end = Cycles.size;
RedJS.BUILD = "2025.3.15";
types_base_Context.GLOBAL = (types_base_Symbol.TABLE = new Map(), types_base_Symbol.INDEXES = new Map(), types_base_Symbol.MAX_INDEX = 0, new types_base_Context());
types_Datatype.TYPES = new Map();
Runtime.DATATYPES = [[types_base_Context.GLOBAL.add("datatype!",Load__dummy = new types_Datatype("datatype!",0)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("unset!",Load__dummy = new types_Datatype("unset!",1)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("none!",Load__dummy = new types_Datatype("none!",2)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("logic!",Load__dummy = new types_Datatype("logic!",3)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("block!",Load__dummy = new types_Datatype("block!",4)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("paren!",Load__dummy = new types_Datatype("paren!",5)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("string!",Load__dummy = new types_Datatype("string!",6)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("file!",Load__dummy = new types_Datatype("file!",7)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("url!",Load__dummy = new types_Datatype("url!",8)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("char!",Load__dummy = new types_Datatype("char!",9)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("integer!",Load__dummy = new types_Datatype("integer!",10)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("float!",Load__dummy = new types_Datatype("float!",11)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("word!",Load__dummy = new types_Datatype("word!",12)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("set-word!",Load__dummy = new types_Datatype("set-word!",13)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("lit-word!",Load__dummy = new types_Datatype("lit-word!",14)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("get-word!",Load__dummy = new types_Datatype("get-word!",15)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("refinement!",Load__dummy = new types_Datatype("refinement!",16)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("issue!",Load__dummy = new types_Datatype("issue!",17)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("native!",Load__dummy = new types_Datatype("native!",18)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("action!",Load__dummy = new types_Datatype("action!",19)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("op!",Load__dummy = new types_Datatype("op!",20)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("function!",Load__dummy = new types_Datatype("function!",21)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("path!",Load__dummy = new types_Datatype("path!",22)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("lit-path!",Load__dummy = new types_Datatype("lit-path!",23)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("set-path!",Load__dummy = new types_Datatype("set-path!",24)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("get-path!",Load__dummy = new types_Datatype("get-path!",25)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("bitset!",Load__dummy = new types_Datatype("bitset!",26)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("point2D!",Load__dummy = new types_Datatype("point2D!",27)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("point3D!",Load__dummy = new types_Datatype("point3D!",28)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("object!",Load__dummy = new types_Datatype("object!",29)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("typeset!",Load__dummy = new types_Datatype("typeset!",30)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("error!",Load__dummy = new types_Datatype("error!",31)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("hash!",Load__dummy = new types_Datatype("hash!",32)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("pair!",Load__dummy = new types_Datatype("pair!",33)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("percent!",Load__dummy = new types_Datatype("percent!",34)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("tuple!",Load__dummy = new types_Datatype("tuple!",35)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("map!",Load__dummy = new types_Datatype("map!",36)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("binary!",Load__dummy = new types_Datatype("binary!",37)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("time!",Load__dummy = new types_Datatype("time!",38)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("tag!",Load__dummy = new types_Datatype("tag!",39)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("email!",Load__dummy = new types_Datatype("email!",40)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("date!",Load__dummy = new types_Datatype("date!",41)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("money!",Load__dummy = new types_Datatype("money!",42)).symbol,Load__dummy],[types_base_Context.GLOBAL.add("ref!",Load__dummy = new types_Datatype("ref!",43)).symbol,Load__dummy]];
Util.IS_NODE = globalThis.XMLHttpRequest == null;
Util.CHILD_PROCESS = Util.IS_NODE ? require("child_process") : null;
Util.FS = Util.IS_NODE ? require("fs") : null;
haxe_http_HttpBase._hx_skip_constructor = false;
runtime_actions_datatypes_StringActions.URI_ENCODE_TBL = Uint8ClampedArray.of(...[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,0,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,255,0]);
runtime_actions_datatypes_StringActions.URL_ENCODE_TBL = Uint8ClampedArray.of(...[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,255,0]);
runtime_actions_datatypes_StringActions.WHITE_CHAR = (function($this) {
	var $r;
	let _g = [];
	{
		let _g1 = 0;
		while(_g1 < 33) _g.push(_g1++);
	}
	let values = _g.concat([133,160,5760,6158]);
	let _g2 = [];
	{
		let _g3 = 8192;
		while(_g3 < 8203) _g2.push(_g3++);
	}
	$r = new Set(values.concat(_g2).concat([8232,8233,8239,8287,12288]));
	return $r;
}(this));
runtime_actions_datatypes_StringActions.SPACE_CHAR = (function($this) {
	var $r;
	let _g = [];
	{
		let _g1 = 8192;
		while(_g1 < 8203) _g.push(_g1++);
	}
	$r = new Set([32,9,133,160,5760,6158].concat(_g).concat([8232,8233,8239,8287,12288]));
	return $r;
}(this));
runtime_actions_datatypes_DateActions.MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
runtime_Actions.ACTIONS = new Map([[0,new runtime_actions_datatypes_DatatypeActions()],[1,new runtime_actions_datatypes_UnsetActions()],[2,new runtime_actions_datatypes_NoneActions()],[3,new runtime_actions_datatypes_LogicActions()],[4,new runtime_actions_datatypes_BlockActions()],[5,new runtime_actions_datatypes_ParenActions()],[6,new runtime_actions_datatypes_StringActions()],[7,new runtime_actions_datatypes_FileActions()],[8,new runtime_actions_datatypes_UrlActions()],[9,new runtime_actions_datatypes_CharActions()],[10,new runtime_actions_datatypes_IntegerActions()],[11,new runtime_actions_datatypes_FloatActions()],[12,new runtime_actions_datatypes_WordActions()],[13,new runtime_actions_datatypes_SetWordActions()],[14,new runtime_actions_datatypes_LitWordActions()],[15,new runtime_actions_datatypes_GetWordActions()],[16,new runtime_actions_datatypes_RefinementActions()],[17,new runtime_actions_datatypes_IssueActions()],[18,new runtime_actions_datatypes_NativeActions()],[19,new runtime_actions_datatypes_ActionActions()],[20,new runtime_actions_datatypes_OpActions()],[21,new runtime_actions_datatypes_FunctionActions()],[22,new runtime_actions_datatypes_PathActions()],[23,new runtime_actions_datatypes_LitPathActions()],[24,new runtime_actions_datatypes_SetPathActions()],[25,new runtime_actions_datatypes_GetPathActions()],[26,new runtime_actions_datatypes_BitsetActions()],[27,new runtime_actions_datatypes_Point2DActions()],[28,new runtime_actions_datatypes_Point3DActions()],[29,new runtime_actions_datatypes_ObjectActions()],[31,new runtime_actions_datatypes_ErrorActions()],[30,new runtime_actions_datatypes_TypesetActions()],[32,new runtime_actions_datatypes_HashActions()],[33,new runtime_actions_datatypes_PairActions()],[34,new runtime_actions_datatypes_PercentActions()],[35,new runtime_actions_datatypes_TupleActions()],[36,new runtime_actions_datatypes_MapActions()],[37,new runtime_actions_datatypes_BinaryActions()],[38,new runtime_actions_datatypes_TimeActions()],[39,new runtime_actions_datatypes_TagActions()],[40,new runtime_actions_datatypes_EmailActions()],[41,new runtime_actions_datatypes_DateActions()],[42,new runtime_actions_datatypes_MoneyActions()],[43,new runtime_actions_datatypes_RefActions()]]);
runtime_actions_Copy.defaultOptions = { deep : false, part : null, types : null};
runtime_actions_Find.defaultOptions = { _case : false, any : false, last : false, match : false, only : false, part : null, reverse : false, same : false, skip : null, tail : false, 'with' : null};
runtime_actions_Form.defaultOptions = { part : null};
runtime_actions_Mold.defaultOptions = { all : false, flat : false, only : false, part : null};
runtime_actions_Put.defaultOptions = { _case : false};
runtime_actions_Select.defaultOptions = { _case : false, any : false, last : false, only : false, part : null, reverse : false, same : false, skip : null, 'with' : null};
types_None.NONE = new types_None();
types_Unset.UNSET = new types_Unset();
types_Object.maxID = 0;
types_Float.DBL_EPSILON = 2.2204460492503131e-16;
types_Logic.TRUE = new types_Logic(true);
types_Logic.FALSE = new types_Logic(false);
runtime_natives_As.STRING_TYPES = new Map([[6,types_String],[7,types_File],[8,types_Url],[39,types_Tag],[40,types_Email],[43,types_Ref]]);
runtime_natives_As.BLOCK_TYPES = new Map([[4,types_Block],[5,types_Paren],[22,types_Path],[23,types_LitPath],[24,types_SetPath],[25,types_GetPath]]);
util_Dec64.__meta__ = { statics : { toUnsignedZA1BigInt : { overload_processed : null}, toUnsignedZA1Int : { overload_processed : null}, toSignedZA1BigInt : { overload_processed : null}, ofZA2IntZ_Int : { overload_processed : null}, ofZA2BigIntZ_Int : { overload_processed : null}, ofZA2BigIntZ_BigInt : { overload_processed : null}}};
util_Dec64.MAX64 = 9223372036854775807n;
util_Dec64.ZERO = 0x000n;
util_Dec64.NAN = 0x8000000000000080n;
util_Dec64.POWER = BigInt64Array.of(1n,10n,100n,1000n,10000n,100000n,1000000n,10000000n,100000000n,1000000000n,10000000000n,100000000000n,1000000000000n,10000000000000n,100000000000000n,1000000000000000n,10000000000000000n,100000000000000000n,1000000000000000000n,10000000000000000000n,0n);
util_Dec64.FAST_TAB1 = Uint8ClampedArray.of(...[1,5,0,25,2,0,0,125,0,1,0,0,0,0,0,0,0,0,0,5,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,0,0,2]);
util_Dec64.FAST_TAB2 = Uint8ClampedArray.of(...[0,1,0,2,1,0,0,3,0,1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,2]);
runtime_natives_Bind.copyTypeset = new types_Typeset(new Set([Runtime.DATATYPES[4][1],Runtime.DATATYPES[5][1],Runtime.DATATYPES[32][1]]));
types_Date.ACCESSORS = ["date","year","month","day","zone","time","hour","minute","second","weekday","yearday","julian","timezone","week","isoweek"];
types_Time.ZERO = new types_Time(0);
runtime_natives_Reduce.defaultOptions = { into : null};
tokenizer_Regexps.wordMoney = /([+-]?)([a-zA-Z]{1,3})/y;
tokenizer_Regexps.word = /(?:[a-zA-Z_*=>&|!?~`^]|<+(?=[-:=>\[\](){}l^"\s!]|$)|(?:\.|[+-]\.?)(?!\d))(?:[\w+\-*=>&|!?~`\.'^]|<(?!<))*/y;
tokenizer_Regexps.hexa = /([A-F\d]{2,})h/y;
tokenizer_Regexps.integer = /[+-]?\d+\b(?!\.|#\{)/y;
tokenizer_Regexps.nanFloat = /[+-]?1\.#NaN\b/iy;
tokenizer_Regexps.infFloat = /([+-]?)1\.#Inf\b/iy;
tokenizer_Regexps.float = /[+-]?(?:(?:\d*\.\d+(?!\.)|\d+\.(?!\d+\.))(?:[eE][+-]?\d+)?|\d+[eE][+-]?\d+)/y;
tokenizer_Regexps.string = /"((?:\^.|[^"^]+)*)"/y;
tokenizer_Regexps.file = /%(?![\s%:;()\[\]{}])(?:([^\s;"]+)|"((?:\^.|[^"^]+)*)")/y;
tokenizer_Regexps.url = /[a-zA-Z_]+:[^\s]+/y;
tokenizer_Regexps.char = /#"(\^(?:[A-Z\[\]\\_@\-\/~"^]|\((?:[A-F\d]+|null|back|tab|line|page|esc|del)\))|.)"/iy;
tokenizer_Regexps.issue = /#(?!["\/()\[\]{}:;@\s])([^"\/()\[\]{}:;@\s]+)/y;
tokenizer_Regexps.specialWord = /(%+)(?=[\s()\[\]<>:]|$)/y;
tokenizer_Regexps.time = /([+-]?\d+):(\d+)(?::(\d+(?:\.\d+)?))?/y;
tokenizer_Regexps.pair = /([+-]?\d+)[xX]([+-]?\d+)/y;
tokenizer_Regexps.tuple = /(\d+)\.(\d+)\.(\d+)(?:\.(\d+))?(?:\.(\d+))?(?:\.(\d+))?(?:\.(\d+))?(?:\.(\d+))?(?:\.(\d+))?(?:\.(\d+))?(?:\.(\d+))?(?:\.(\d+))?/y;
tokenizer_Regexps.pointComma = /\s*,\s+/y;
tokenizer_Regexps.tag = /<([^-=>\[\](){}l^"\s](?:"[^"]*"|'[^']*'|[^>])*)>/y;
tokenizer_Regexps.ref = /@([^#$',=>@\\^"(, "y");<\[\]{}\s]*)/y;
tokenizer_Regexps.refinement = /\/([^\/\\^,\[\](){}"#$%@:;\s]+)/y;
tokenizer_Regexps.beginRawString = /(%+)\{/y;
tokenizer_Regexps.comment = /;.*$/my;
tokenizer_Regexps.div = /\/\/?(?=[\s()\[\]]|$)/y;
tokenizer_Regexps.getDiv = /:(\/\/?)/y;
tokenizer_Regexps.litDiv = /'(\/\/?)/y;
tokenizer_Regexps.setDiv = /(\/\/?):/y;
tokenizer_Regexps.date = (function($this) {
	var $r;
	let anyCase = function(str) {
		let _this = [...str];
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			let ch = _this[i];
			result[i] = "[" + ch + ch.toUpperCase() + "]";
		}
		return result.join("");
	};
	let rule = function(str) {
		let rx = /\s+/gm;
		return str.replace(rx,"");
	};
	let m = "1[012]|0?[1-9]";
	let mon = "jan feb mar apr may jun jul aug sep oct nov dec".split(" ").map(anyCase).join("|");
	let month = "january february march april may june july august september october november december".split(" ").map(anyCase).join("|");
	let sec = rule("\n\t\t\t" + "\\d{1,2}" + "\n\t\t\t(?:\n\t\t\t\t\\.\n\t\t\t\t" + "\\d+" + "\n\t\t\t)?\n\t\t");
	let zone = rule("\n\t\t\t(?<zone_sign> " + "[+-]" + ")\n\t\t\t(?:\n\t\t\t\t(?<zone_hm15>\n\t\t\t\t\t(?<zone_hm15_hour> " + "\\d{1,2}" + ")\n\t\t\t\t\t:\n\t\t\t\t\t(?<zone_hm15_min15> " + "\\d{1,2}" + ")\n\t\t\t\t)\n\t\t\t\t| (?<zone_hour> " + "\\d{1,2}" + "\\b)\n\t\t\t\t| (?<zone_hhmm> " + "\\d{4}" + ")\n\t\t\t)\n\t\t");
	let time = rule("\n\t\t\t(?<time_hms>\n\t\t\t\t(?<time_hms_hour> " + "\\d{1,2}" + ")\n\t\t\t\t:\n\t\t\t\t(?<time_hms_min> " + "\\d{1,2}" + ")\n\t\t\t\t(?:\n\t\t\t\t\t:\n\t\t\t\t\t(?<time_hms_sec> " + sec + ")\n\t\t\t\t)?\n\t\t\t)\n\t\t\t| (?<time_hhmmss>\n\t\t\t\t(?<time_hhmmss_hhmmss> " + "\\d{6}" + ")\n\t\t\t\t(?:\n\t\t\t\t\t\\.\n\t\t\t\t\t(?<time_hhmmss_dec> " + "\\d+" + ")\n\t\t\t\t)?\n\t\t\t)\n\t\t\t| (?<time_hhmm> " + "\\d{4}" + ")\n\t\t");
	let mmm = function(outer) {
		return rule("\n\t\t\t(?<" + outer + "_mmm_m> " + m + ")\n\t\t\t| (?<" + outer + "_mmm_mon> " + mon + ")\n\t\t\t| (?<" + outer + "_mmm_month> " + month + ")\n\t\t");
	};
	let date = rule("\n\t\t\t(?<date_yyyymmmdd>\n\t\t\t\t(?<date_yyyymmmdd_yyyy> " + "\\d{3,4}" + ")\n\t\t\t\t" + "[/-]" + "\n\t\t\t\t(?<date_yyyymmmdd_mmm> " + mmm("date_yyyymmmdd") + ")\n\t\t\t\t" + "[/-]" + "\n\t\t\t\t(?<date_yyyymmmdd_dd> " + "3[01]|[12]\\d|0?[1-9]" + ")\n\t\t\t)\n\t\t\t| (?<date_ddmmmy>\n\t\t\t\t(?<date_ddmmmy_dd> " + "3[01]|[12]\\d|0?[1-9]" + ")\n\t\t\t\t" + "[/-]" + "\n\t\t\t\t(?<date_ddmmmy_mmm> " + mmm("date_ddmmmy") + ")\n\t\t\t\t" + "[/-]" + "\n\t\t\t\t(?:\n\t\t\t\t\t(?<date_ddmmmy_yyyy> " + "\\d{3,4}" + ")\n\t\t\t\t\t| (?<date_ddmmmy_yy> " + "\\d{1,2}" + ")\n\t\t\t\t)\n\t\t\t)\n\t\t\t| (?<date_yyyyddd>\n\t\t\t\t(?<date_yyyyddd_yyyy> " + "\\d{3,4}" + ")\n\t\t\t\t-\n\t\t\t\t(?<date_yyyyddd_ddd> " + "36[0-6]|3[0-5]\\d|[12]\\d{2}|0\\d[1-9]|0[1-9]\\d" + ")\n\t\t\t)\n\t\t\t| (?<date_yyyyW>\n\t\t\t\t(?<date_yyyyW_yyyy> " + "\\d{3,4}" + ")\n\t\t\t\t-W\n\t\t\t\t(?<date_yyyyW_ww> " + "5[012]|[1-4]\\d|0[1-9]" + ")\n\t\t\t\t(?:\n\t\t\t\t\t-\n\t\t\t\t\t(?<date_yyyyW_d> " + "[1-7]" + ")\n\t\t\t\t)?\n\t\t\t)\n\t\t");
	let dateT = rule("\n\t\t\t(?<dateT_yyyy> " + "\\d{3,4}" + ")\n\t\t\t(?<dateT_mm> " + "1[012]|0[1-9]" + ")\n\t\t\t(?<dateT_dd> " + "3[01]|[12]\\d|0?[1-9]" + ")\n\t\t");
	$r = new RegExp(rule("\n\t\t\t(?:\n\t\t\t\t(?<date> " + date + ")\n\t\t\t\t| (?<dateT> " + dateT + ") (?=T)\n\t\t\t)\n\t\t\t(?:\n\t\t\t\t[/T]\n\t\t\t\t(?<time> " + time + ")\n\t\t\t\t(?:\n\t\t\t\t\t(?<Z> Z)\n\t\t\t\t\t| (?<zone> " + zone + ")\n\t\t\t\t)?\n\t\t\t)?\n\t\t"),"y");
	return $r;
}(this));
tokenizer_RegexpChecks.wordMoney = /([+-]?)([a-zA-Z]{1,3})/y;
tokenizer_RegexpChecks.word = /(?:[a-zA-Z_*=>&|!?~`^]+|<+(?=[-:=>\[\](){}l^"\s!]|$)|(?:\.|[+-]\.?)(?!\d))(?:[\w+\-*=>&|!?~`\.'^]|<(?!<))*/y;
tokenizer_RegexpChecks.integer = /[+-]?\d+\b(?!\.|#\{)/y;
tokenizer_RegexpChecks.specialFloat = /[+-]?1\.#/y;
tokenizer_RegexpChecks.float = /[+-]?(?:\d*\.\d+(?![\.\d])|\d+\.(?!\d+\.)|\d+[eE][+-]?\d+)/y;
tokenizer_RegexpChecks.string = "\"";
tokenizer_RegexpChecks.file = /%(?![\s%:;()\[\]{}])/y;
tokenizer_RegexpChecks.url = /[a-zA-Z_]+:[^\s]/y;
tokenizer_RegexpChecks.char = "#\"";
tokenizer_RegexpChecks.issue = /#(?!["\/()\[\]{}:;@\s])/y;
tokenizer_RegexpChecks.specialWord = /%+(?=[\s()\[\]<>:]|$)/y;
tokenizer_RegexpChecks.time = /[+-]?\d+:\d/y;
tokenizer_RegexpChecks.pair = /[+-]?\d+[xX]/y;
tokenizer_RegexpChecks.tuple = /(?:\d+\.){2}/y;
tokenizer_RegexpChecks.point = /\(\d+(?:\.(?:#Inf|#NaN|\d+(?:[eE][+-]?\d+)?)|e[+-]?\d+)?\s*,\s/y;
tokenizer_RegexpChecks.tag = /<[^-=>\[\](){}l^"\s](?:"[^"]*"|'[^']*'|[^>"']+)*/y;
tokenizer_RegexpChecks.ref = "@";
tokenizer_RegexpChecks.refinement = "/";
tokenizer_RegexpChecks.date = /\d+[\/\-T]/y;
tokenizer_RegexpChecks.paren = "(";
tokenizer_RegexpChecks.multiString = "{";
var tokenizer_DateMatch_MONTHS = "jan feb mar apr may jun jul aug sep oct nov dec".split(" ");
runtime_natives_Transcode.defaultOptions = { into : null, next : false, one : false, part : null, prescan : false, scan : false, trace : null};
//Main.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

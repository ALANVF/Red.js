RedJS.initRuntime();

// some of this was generated by deepseek bc I can't be bothered to learn xterm.js api lol

// Initialize the terminal
const term = new Terminal();
const fitAddon = new FitAddon.FitAddon();

// Load the fit addon
term.loadAddon(fitAddon);

// Attach the terminal to the div
term.open(document.getElementById('terminal'));

// Fit the terminal to the screen size
fitAddon.fit();

// Optionally, you can add some text to the terminal
term.writeln('Welcome to Red.js!');

// Handle window resize events to keep the terminal size updated
window.addEventListener('resize', () => {
	fitAddon.fit();
});

// TODO: multiline input support
let replHistory = [];
function readLine(/*callback /* (input: string) => void */) /* Promise<string> */ {
	return new Promise((resolve) => {
		let historyPos = 0;
		let input = '', oldInput = null, pos = 0;
		const disposable = term.onData((data) => {
			console.log(data, data.charCodeAt(0));
			const UP = "\x1b[A";
			const DOWN = "\x1b[B";
			const LEFT = "\x1b[D";
			const RIGHT = "\x1b[C";
			const ENTER = "\r"; // why does it use cr instead of nl?????
			const TAB = "\t";
			const BACKSPACE = "\x7f";

			switch(data) {
				case UP:
					// ...
				break;

				case DOWN:
					// ...
				break;

				case LEFT:
					console.log(pos);
					if(pos !== 0) {
						term.write(data);
						pos--;
					}
				break;

				case RIGHT:
					if(pos !== input.length) {
						term.write(data);
						pos++;
					}
				break;

				case ENTER:
					term.writeln(data);
					replHistory.push(input);
					disposable.dispose();
					resolve(input);
				break;

				//case TAB:
					// ...
				//break;

				case BACKSPACE:
					if(pos !== 0) {
						// Move cursor back, overwrite with space, move back again
						if(input.charAt(pos-1) === TAB) {
							term.write('\b\b\b\b');
						} else {
							if(pos === input.length) {
								term.write('\b \b');
							} else {
								term.write('\b');
								term.write(' '.repeat(input.length + 1 - pos) + LEFT.repeat(input.length - pos + 1));
								term.write(input.slice(pos));
								term.write(`\x1b[${3 + pos}G`)
							}
						}
						
						input = input.slice(0, pos-1) + input.slice(pos); // Remove last character from input buffer
						pos--;
					}
				break;

				default:
					term.write(data);

					// TODO: handle tabs in middle of input
					if(pos === input.length) {
						input += data;
					} else if(pos === 0) {
						term.write(input);
						term.write(`\x1b[${3 + pos + 2}G`)
						input = data + input;
					} else {
						term.write(input.slice(pos));
						term.write(`\x1b[${3 + pos + 2}G`)
						input = input.slice(0, pos) + data + input.slice(pos);
					}
					
					pos++;
				break;
			}
		});
	});
}

RedJS.setPrintHandler(input => {
	term.writeln(input);
});

RedJS.setPrinHandler(input => {
	term.write(input);
});

RedJS.setInputHandler(() => {
	//return await readLine(); // doesn't work >:(
	let result = [null];
	readLine().then(res => {
		result[0] = res;
	});

	while(result[0] === null) {}

	return result[0];
});

async function main() {
	while(true) {
		term.write('>> ');
		const input = await readLine();
		try {
			const result = RedJS.evalCode(input);
			if(!result.isUnset()) {
				term.writeln(`== ${RedJS.mold(result)}`);
			}
		} catch(e) {
			console.log(e);
			term.writeln(`\x1b[31m${e}\x1b[0m`);
		}
	}
}

// Start the main loop
main();